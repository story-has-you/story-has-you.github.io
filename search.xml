<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Spring Boot启动之前做了哪些事</title>
    <url>/posts/64841/</url>
    <content><![CDATA[<p>探究一下在调用我们写的main方法之前，SpringBoot框架为我们做了哪些事情。</p>
<a id="more"></a>


<h2 id="Spring-Boot-Jar文件探究"><a href="#Spring-Boot-Jar文件探究" class="headerlink" title="Spring Boot Jar文件探究"></a>Spring Boot Jar文件探究</h2><p>初始化一个Spring 应用，添加如下依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1.6.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span> <span class="comment">&lt;!-- lookup parent from repository --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fxipp.spring<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>first-app-by-gui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>first-app-by-gui<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span>Demo project for Spring Boot<span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>执行<code>mvn package</code>命令打包，查看jar包的目录结构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── BOOT-INF</span><br><span class="line">│   ├── classes</span><br><span class="line">│   │   ├── application.properties</span><br><span class="line">│   │   └── com</span><br><span class="line">│   │       └── fxipp</span><br><span class="line">│   │           └── spring</span><br><span class="line">│   │               └── FirstAppByGuiApplication.class</span><br><span class="line">│   └── lib</span><br><span class="line">│       ├── classmate-1.4.0.jar</span><br><span class="line">│       ├── hibernate-validator-6.0.17.Final.jar</span><br><span class="line">│       ├── jackson-annotations-2.9.0.jar</span><br><span class="line">│       ├── jackson-core-2.9.9.jar</span><br><span class="line">│       ......</span><br><span class="line">├── META-INF</span><br><span class="line">│   ├── MANIFEST.MF</span><br><span class="line">│   └── maven</span><br><span class="line">│       └── com.fxipp.spring</span><br><span class="line">│           └── first-app-by-gui</span><br><span class="line">│               ├── pom.properties</span><br><span class="line">│               └── pom.xml</span><br><span class="line">└── org</span><br><span class="line">    └── springframework</span><br><span class="line">        └── boot</span><br><span class="line">            └── loader</span><br><span class="line">                ├── ExecutableArchiveLauncher.class</span><br><span class="line">                ├── JarLauncher.class</span><br><span class="line">                ├── LaunchedURLClassLoader$UseFastConnectionExceptionsEnumeration.class</span><br><span class="line">                ├── LaunchedURLClassLoader.class</span><br><span class="line">                ├── ......</span><br><span class="line">                ├── archive</span><br><span class="line">                │   ├── Archive$Entry.class</span><br><span class="line">                │   ├── Archive$EntryFilter.class</span><br><span class="line">                │   ├── Archive.class</span><br><span class="line">                │   ├── ......</span><br><span class="line">                ├── data</span><br><span class="line">                │   ├── RandomAccessData.class</span><br><span class="line">                │   ├── RandomAccessDataFile$1.class</span><br><span class="line">                │   ├──......</span><br><span class="line">                ├── jar</span><br><span class="line">                │   ├── AsciiBytes.class</span><br><span class="line">                │   ├── Bytes.class</span><br><span class="line">                │   ├── ......</span><br><span class="line">                └── util</span><br><span class="line">                    └── SystemPropertyUtils.class</span><br><span class="line">18 directories, 91 files</span><br></pre></td></tr></table></figure>



<p>文件结构比较复杂，解释一下</p>
<ul>
<li><code>BOOT-INF/classes</code>: 存放应用编译后的class文件;</li>
<li><code>BOOT-INF/lib</code>:class path目录， 存放应用依赖的jar包;</li>
<li><code>META-INF</code>: 存放应用的元信息，如<code>MANIFEST.MF</code>文件;</li>
<li><code>org</code>:存放Spring Boot自身的class文件;</li>
</ul>
<h2 id="Jar文件的执行器-Spring-Boot-Loader"><a href="#Jar文件的执行器-Spring-Boot-Loader" class="headerlink" title="Jar文件的执行器: Spring Boot Loader"></a>Jar文件的执行器: Spring Boot Loader</h2><p>我们先从<code>MANIFEST.MF</code>文件查看</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Manifest-Version: 1.0</span><br><span class="line">Implementation-Title: first-app-by-gui</span><br><span class="line">Implementation-Version: 0.0.1-SNAPSHOT</span><br><span class="line">Start-Class: com.fxipp.spring.FirstAppByGuiApplication</span><br><span class="line">Spring-Boot-Classes: BOOT-INF&#x2F;classes&#x2F;</span><br><span class="line">Spring-Boot-Lib: BOOT-INF&#x2F;lib&#x2F;</span><br><span class="line">Build-Jdk-Spec: 1.8</span><br><span class="line">Spring-Boot-Version: 2.1.6.RELEASE</span><br><span class="line">Created-By: Maven Archiver 3.4.0</span><br><span class="line">Main-Class: org.springframework.boot.loader.JarLauncher</span><br></pre></td></tr></table></figure>

<p>里面记录了应用的元信息，Spring的版本，应用的版本，Maven的版本，Main-Class等信息。不难发现，MainClass指向的是<code>org.springframework.boot.loader.JarLauncher</code>（以下简称<code>JarLauncher</code>），而不是我们自己编写的<code>com.fxipp.spring.FirstAppByGuiApplication</code>。</p>
<p><code>JarLauncher</code>从名字看出是一个jar的执行器，他的class文件位于<code>org.springframework.boot.loader</code>目录下，可见它是Spring自身的class文件。</p>
<blockquote>
<p>JarLauncher的GAV org.springframework.boot:spring-boot-loader:2.1.6.RELEASE</p>
</blockquote>
<p>通常情况下，他会在<code>spring-boot-starter-parent</code>引入到应用中，既然main-class指向到是<code>JarLauncher</code>，那我们也可以直接执行<code>java org.springframework.boot.loader.JarLauncher</code>，也可以启动Spring项目的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">java org.springframework.boot.loader.JarLauncher</span><br><span class="line"></span><br><span class="line">  .   ____          _            __ _ _</span><br><span class="line"> &#x2F;\\ &#x2F; ___&#39;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="line">( ( )\___ | &#39;_ | &#39;_| | &#39;_ \&#x2F; _&#96; | \ \ \ \</span><br><span class="line"> \\&#x2F;  ___)| |_)| | | | | || (_| |  ) ) ) )</span><br><span class="line">  &#39;  |____| .__|_| |_|_| |_\__, | &#x2F; &#x2F; &#x2F; &#x2F;</span><br><span class="line"> &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|_|&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;|___&#x2F;&#x3D;&#x2F;_&#x2F;_&#x2F;_&#x2F;</span><br><span class="line"> :: Spring Boot ::        (v2.1.6.RELEASE)</span><br><span class="line"></span><br><span class="line">2019-06-19 20:30:52.202  INFO 3094 --- [           main] c.fxipp.spring.FirstAppByGuiApplication  : Starting FirstAppByGuiApplication on fangxideMacBook-Pro.local with PID 3094 (&#x2F;Users&#x2F;fangxi&#x2F;Java&#x2F;workspace&#x2F;default&#x2F;spring-boot&#x2F;first-app-by-gui&#x2F;target&#x2F;temp&#x2F;BOOT-INF&#x2F;classes started by fangxi in &#x2F;Users&#x2F;fangxi&#x2F;Java&#x2F;workspace&#x2F;default&#x2F;spring-boot&#x2F;first-app-by-gui&#x2F;target&#x2F;temp)</span><br></pre></td></tr></table></figure>

<p>既然可以执行，那就说明了，<code>JarLauncher</code>这个类才是Spring项目真正的入口。如果我们执行自己写的<code>com.fxipp.spring.FirstAppByGuiApplication</code>会怎么样？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">➜  classes java com.fxipp.spring.FirstAppByGuiApplication</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.NoClassDefFoundError: org&#x2F;springframework&#x2F;boot&#x2F;SpringApplication</span><br><span class="line">	at com.fxipp.spring.FirstAppByGuiApplication.main(FirstAppByGuiApplication.java:10)</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.springframework.boot.SpringApplication</span><br><span class="line">	at java.net.URLClassLoader.findClass(URLClassLoader.java:382)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">	at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349)</span><br><span class="line">	at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">	... 1 more</span><br></pre></td></tr></table></figure>

<p>启动报错，原因是找不到<code>org.springframework.boot.SpringApplication</code>这个类，说白了就是没有指定Class Path，Spring Boot应用的Class Path目录是<code>BOOT-INF/lib</code>。</p>
<p>也就是说，<code>JarLauncher</code>可以执行成功，是因为Spring Boot知道了Class Path的路径，说明<code>JarLauncher</code>在启动调用<code>com.fxipp.spring.FirstAppByGuiApplication</code>之前，指定了Class Path的位置。</p>
<p><code>JarLauncher</code>的代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JarLauncher</span> <span class="keyword">extends</span> <span class="title">ExecutableArchiveLauncher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_CLASSES = <span class="string">"BOOT-INF/classes/"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="keyword">final</span> String BOOT_INF_LIB = <span class="string">"BOOT-INF/lib/"</span>;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">JarLauncher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="title">JarLauncher</span><span class="params">(Archive archive)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(archive);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isNestedArchive</span><span class="params">(Archive.Entry entry)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.isDirectory()) &#123;</span><br><span class="line">         <span class="keyword">return</span> entry.getName().equals(BOOT_INF_CLASSES);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> entry.getName().startsWith(BOOT_INF_LIB);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      <span class="keyword">new</span> JarLauncher().launch(args);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>Archive.Entry</code>:这个类对对象，代编jar包中的资源文件。</li>
</ul>
<p><code>isNestedArchive</code>方法判断entry对象是不是位于jar包内，如果在jar内部，返回true。如果不在jar包里面，也就是我们解压了jar包，返回false。</p>
<p>重点看<code>launch(String[])</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   <span class="comment">// 1</span></span><br><span class="line">	JarFile.registerUrlProtocolHandler();</span><br><span class="line">   <span class="comment">// 2</span></span><br><span class="line">	ClassLoader classLoader = createClassLoader(getClassPathArchives());</span><br><span class="line">   <span class="comment">// 3</span></span><br><span class="line">	launch(args, getMainClass(), classLoader);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个方法一共3步</p>
<ol>
<li>扩展JAR协议<ol>
<li>JDK默认支持file、http、jar等协议，所以JDK内部有默认的实现，位于<code>sun.net.www.protocol</code>包下。</li>
<li><code>JarFile.registerUrlProtocolHandler();</code>这个方法将<code>org.springframework.boot.loader</code>包下对应的JAR协议实现，覆盖原有的JAR实现。</li>
<li>因为原有的JAR实现，ClassPath是我们自己配置环境变量的时候制定的，不是<code>BOOT-INF/lib</code>。</li>
</ol>
</li>
<li>创建一个classloader，用于加载<code>JarLauncher</code>类，因为jar包可能会被解压，解压前和解压后的的ClassLoader是不同的。</li>
<li>调用<code>launch</code>方法，将参数传递。<ol>
<li>args是我们自己指定的参数。</li>
<li>getMainClass()是获取<code>MANIFEST.MF</code>文件里面Statr-Class属性，也就是获取我们自定义主类的Class 文件地址。</li>
<li>传递推出的类加载器</li>
</ol>
</li>
</ol>
<p>launch方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launch</span><span class="params">(String[] args, String mainClass, ClassLoader classLoader)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">   Thread.currentThread().setContextClassLoader(classLoader);</span><br><span class="line">   createMainMethodRunner(mainClass, args, classLoader).run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> MainMethodRunner <span class="title">createMainMethodRunner</span><span class="params">(String mainClass, String[] args, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> MainMethodRunner(mainClass, args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainMethodRunner</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String mainClassName;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> String[] args;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">MainMethodRunner</span><span class="params">(String mainClass, String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.mainClassName = mainClass;</span><br><span class="line">      <span class="keyword">this</span>.args = (args != <span class="keyword">null</span>) ? args.clone() : <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">      Class&lt;?&gt; mainClass = Thread.currentThread().getContextClassLoader().loadClass(<span class="keyword">this</span>.mainClassName);</span><br><span class="line">      Method mainMethod = mainClass.getDeclaredMethod(<span class="string">"main"</span>, String[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">      mainMethod.invoke(<span class="keyword">null</span>, <span class="keyword">new</span> Object[] &#123; <span class="keyword">this</span>.args &#125;);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>launch方法分析：</p>
<ol>
<li>将ClassLoader放入当前线程里面的ClassLoader里面</li>
<li>创建<code>MainMethodRunner</code>对象，调用里面的<code>run()</code>方法。<ol>
<li><code>run()</code>方法先获取到之前设定的ClassLoader。</li>
<li>利用ClassLoader加载Start-Class之类的类，也就是我们自己的主类。</li>
<li>获取主类里面的<code>main</code>方法，通过反射执行。</li>
</ol>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过分析，我们可以看出，Spring Boot Loader在调用我们自己的主类之前，主要做了三件事</p>
<ol>
<li>扩展JDK默认的支持JAR对应的协议，因为Spring Boot启动不仅仅需要JDK半身的JAR文件，还需要<code>BOOT-INF/lib</code>这个目录下的文件。默认实现无法将<code>BOOT-INF/lib</code>这个目录当作ClassPath，故需要替换实现。</li>
<li>判断当前的介质，是<code>java -jar</code>启动，还是<code>java org.springframework.boot.loader.JarLauncher</code>启动。以便获取对应的ClassLoader。</li>
<li>获取<code>MANIFEST.MF</code>文件中的Start-Class属性，也就是我们自定义的主类。通过第二步获取的ClassLoader加载获取到Class文件，通过反射调用<code>main</code>方法，启动应用。</li>
</ol>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>RabbitMQ延迟队列</title>
    <url>/posts/6794/</url>
    <content><![CDATA[<h2 id="什么是延迟队列"><a href="#什么是延迟队列" class="headerlink" title="什么是延迟队列"></a>什么是延迟队列</h2><p>延迟队列就是进入该队列的消息会被延迟消费的队列。而一般的队列，消息一旦入队了之后就会被消费者马上消费。</p>
<a id="more"></a>


<h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul>
<li>用户生成订单之后，需要过一段时间校验订单的支付状态，如果订单仍未支付则需要及时地关闭订单。</li>
<li>用户注册成功之后，需要过一段时间比如一周后校验用户的使用情况，如果发现用户活跃度较低，则发送邮件或者短信来提醒用户使用。</li>
</ul>
<p>如果不使用延迟队列，那么我们只能通过一个轮询扫描程序去完成。这种方案既不优雅，也不方便做成统一的服务便于开发人员使用。但是使用延迟队列的话，我们就可以轻而易举地完成</p>
<h2 id="RabbitMQ的两个特性"><a href="#RabbitMQ的两个特性" class="headerlink" title="RabbitMQ的两个特性"></a>RabbitMQ的两个特性</h2><h3 id="Time-To-Live-Extensions"><a href="#Time-To-Live-Extensions" class="headerlink" title="Time-To-Live Extensions"></a>Time-To-Live Extensions</h3><p>RabbitMQ允许我们为消息或者队列设置TTL（time to live），也就是过期时间。TTL表明了一条消息可在队列中存活的最大时间，单位为毫秒。也就是说，当某条消息被设置了TTL或者当某条消息进入了设置了TTL的队列时，这条消息会在经过TTL秒后“死亡”，成为Dead Letter。如果既配置了消息的TTL，又配置了队列的TTL，那么较小的那个值会被取用。</p>
<h3 id="Dead-Letter-Exchange"><a href="#Dead-Letter-Exchange" class="headerlink" title="Dead Letter Exchange"></a>Dead Letter Exchange</h3><p>刚才提到了，被设置了TTL的消息在过期后会成为Dead Letter。其实在RabbitMQ中，一共有三种消息的“死亡”形式：</p>
<ul>
<li>消息被拒绝。通过调用basic.reject或者basic.nack并且设置的requeue参数为false。</li>
<li>消息因为设置了TTL而过期。</li>
<li>消息进入了一条已经达到最大长度的队列。</li>
</ul>
<p>如果队列设置了Dead Letter Exchange（DLX），那么这些Dead Letter就会被重新publish到Dead Letter Exchange，通过Dead Letter Exchange路由到其他队列。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p>将RabbitMQ的TTL和DLX特性结合在一起，实现一个延迟队列。</p>
<p>延迟消费是延迟队列最为常用的使用模式。如下图所示，生产者产生的消息首先会进入缓冲队列（图中红色队列）。通过RabbitMQ提供的TTL扩展，这些消息会被设置过期时间，也就是延迟消费的时间。等消息过期之后，这些消息会通过配置好的DLX转发到实际消费队列（图中蓝色队列），以此达到延迟消费的效果</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/zu1j3.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>首先我们在Intellij中创建一个Spring Boot工程，并且添加<code>spring-boot-starter-amqp</code>扩展。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>application.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">rabbitmq:</span></span><br><span class="line">    <span class="attr">addresses:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:5672</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">admin</span></span><br><span class="line">    <span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line">    <span class="attr">connection-timeout:</span> <span class="number">15000</span></span><br><span class="line">    <span class="comment"># 生产者配置: 启动消息确认模式</span></span><br><span class="line">    <span class="attr">publisher-confirm-type:</span> <span class="string">correlated</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="attr">direct:</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">      <span class="attr">simple:</span></span><br><span class="line">        <span class="comment"># 消费者配置: 表示消费成功之后需要手工进行签收(ack)，默认为auto</span></span><br><span class="line">        <span class="attr">acknowledge-mode:</span> <span class="string">manual</span></span><br><span class="line">        <span class="attr">concurrency:</span> <span class="number">5</span></span><br><span class="line">        <span class="attr">max-concurrency:</span> <span class="number">10</span></span><br><span class="line">        <span class="comment"># 消费者配置: 批量消息消费则一条条的消费</span></span><br><span class="line">        <span class="attr">prefetch:</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>从上述的流程图中我们可以看到，一个延迟队列的实现，需要一个缓冲队列以及一个实际的消费队列。</p>
<p>MqConstant</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String DELAY_QUEUE = <span class="string">"test-delay-queue"</span>; <span class="comment">// 实际的消费队列</span></span><br><span class="line">String DEAD_QUEUE = <span class="string">"dead-letter-queue"</span>;  <span class="comment">// 缓冲队列</span></span><br><span class="line"></span><br><span class="line">String DEAD_EXCHANGE = <span class="string">"dead-letter-exchange"</span>; <span class="comment">// 缓冲队列exchange</span></span><br><span class="line"></span><br><span class="line">String DELAY_ROUTING_KEY = <span class="string">"test-delay-routingKey.*"</span>; <span class="comment">// 实际消费队列routing-key</span></span><br><span class="line">String DEAD_ROUTING_KEY = <span class="string">"dead-letter-routingKey.*"</span>; <span class="comment">// 缓冲队列routing-key</span></span><br></pre></td></tr></table></figure>

<p>创建缓冲队列:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">deadLetterQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 出现dead letter之后将dead letter重新发送到指定exchange</span></span><br><span class="line">    map.put(<span class="string">"x-dead-letter-exchange"</span>, MqConstant.DEAD_EXCHANGE);</span><br><span class="line">    <span class="comment">// 出现dead letter之后将dead letter重新按照指定的routing-key发送</span></span><br><span class="line">    map.put(<span class="string">"x-dead-letter-routing-key"</span>, MqConstant.DELAY_ROUTING_KEY);</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(MqConstant.DEAD_QUEUE).withArguments(map).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>创建缓冲队列交换机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Exchange <span class="title">deadLetterExchange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ExchangeBuilder.directExchange(MqConstant.DEAD_EXCHANGE).durable(<span class="keyword">true</span>).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>绑定缓冲队列和缓冲队列交换机</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">deadLetterBinding</span><span class="params">(Queue deadLetterQueue, Exchange deadLetterExchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(deadLetterQueue).to(deadLetterExchange).with(MqConstant.DEAD_ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>创建实际消费队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Queue <span class="title">redirectQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> QueueBuilder.nonDurable(MqConstant.DELAY_QUEUE).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将实际消费队列与缓冲队列的交换机绑定</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Binding <span class="title">redirectBinding</span><span class="params">(Queue redirectQueue, Exchange deadLetterExchange)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> BindingBuilder.bind(redirectQueue).to(deadLetterExchange).with(MqConstant.DELAY_ROUTING_KEY).noargs();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>消息消费者，监听实际消费队列</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RabbitListener</span>(queues = MqConstant.DELAY_QUEUE)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delay</span><span class="params">(Message&lt;String&gt; message, Channel channel, @Header(AmqpHeaders.DELIVERY_TAG)</span> <span class="keyword">long</span> tag) <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    log.info(<span class="string">"延迟队列: &#123;&#125;"</span>, message.getPayload());</span><br><span class="line">    channel.basicAck(tag, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>发送消息, 向缓冲队列发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RabbitMQExampleApplicationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RabbitTemplate rabbitTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message&lt;String&gt; msg = MessageBuilder.withPayload(<span class="string">"hello delay"</span>).build();</span><br><span class="line">        CorrelationData correlationData = <span class="keyword">new</span> CorrelationData(UUID.randomUUID().toString());</span><br><span class="line">        rabbitTemplate.convertAndSend(</span><br><span class="line">                MqConstant.DEAD_EXCHANGE,</span><br><span class="line">                MqConstant.DEAD_ROUTING_KEY,</span><br><span class="line">                msg,</span><br><span class="line">                message -&gt; &#123;</span><br><span class="line">                    <span class="comment">// 设置该消息的延迟时间</span></span><br><span class="line">                    <span class="keyword">long</span> millis = TimeUnit.SECONDS.toMillis(<span class="number">10</span>);</span><br><span class="line">                    message.getMessageProperties().setExpiration(String.valueOf(millis));</span><br><span class="line">                    <span class="keyword">return</span> message;</span><br><span class="line">                &#125;,</span><br><span class="line">                correlationData);</span><br><span class="line">        log.info(<span class="string">"已发送延迟队列消息"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14:17:14.534  INFO 9400 --- [           main] c.s.e.r.RabbitMQExampleApplicationTest   : 已发送延迟队列消息</span><br><span class="line">&#x2F;&#x2F; 10s 后</span><br><span class="line">14:17:24.586  INFO 9396 --- [ntContainer#1-1] c.s.e.rabbitmq.receive.RabbitReceive     : 延迟队列: hello delay</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Redis + Lua脚本实现服务限流</title>
    <url>/posts/8163/</url>
    <content><![CDATA[<p>保障服务稳定的三大利器：熔断降级、服务限流和故障模拟。今天和大家谈谈限流算法的几种实现方式，本文所说的限流并非是Nginx层面的限流，而是业务代码中的逻辑限流。</p>
<a id="more"></a>


<h2 id="限流的作用"><a href="#限流的作用" class="headerlink" title="限流的作用"></a>限流的作用</h2><p>由于 API 接口无法控制调用方的行为，因此当遇到瞬时请求量激增时，会导致接口占用过多服务器资源，使得其他请求响应速度降低或是超时，更有甚者可能导致服务器宕机。<br>限流 (Ratelimiting) 指对应用服务的请求进行限制，例如某一接口的请求限制为 100 个每秒, 对超过限制的请求则进行快速失败或丢弃。<br>限流可以应对：</p>
<ul>
<li>热点业务带来的突发请求；</li>
<li>调用方 bug 导致的突发请求；</li>
<li>恶意攻击请求。</li>
</ul>
<h2 id="为什么要分布式限流"><a href="#为什么要分布式限流" class="headerlink" title="为什么要分布式限流"></a>为什么要分布式限流</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/n5f5g.png" alt=""></p>
<p>当应用为单点应用时，只要应用进行了限流，那么应用所依赖的各种服务也都得到了保护。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/weji9.png" alt=""></p>
<p>但线上业务出于各种原因考虑，多是分布式系统，单节点的限流仅能保护自身节点，但无法保护应用依赖的各种服务，并且在进行节点扩容、缩容时也无法准确控制整个服务的请求限制。</p>
<p>而如果实现了分布式限流，那么就可以方便地控制整个服务集群的请求限制，且由于整个集群的请求数量得到了限制，因此服务依赖的各种资源也得到了限流的保护。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>使用注解实现限流，在需要限流的方法上添加注解以及参数即可</p>
<p>新建一个SpringBoot工程</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-aop<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>28.1-jre<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>限流的Lua脚本，在resources下<br>为什么会使用lua脚本，限流大多数发生在高并发场景下，redis执行lua脚本的时候是原子性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 获取方法签名特征</span><br><span class="line">local methodKey &#x3D; KEYS[1]</span><br><span class="line"></span><br><span class="line">-- 调用脚本的传入的限流大小</span><br><span class="line">local limit &#x3D; tonumber(ARGV[1])</span><br><span class="line">local timeout &#x3D; tonumber(ARGV[2])</span><br><span class="line"></span><br><span class="line">-- 获取该方法的流量大小，默认0</span><br><span class="line">local count &#x3D; tonumber(redis.call(&#39;get&#39;, methodKey) or &quot;0&quot;)</span><br><span class="line"></span><br><span class="line">-- 是否超出限流阈值</span><br><span class="line">if count + 1 &gt; limit then</span><br><span class="line">    -- 超过阈值</span><br><span class="line">    return false</span><br><span class="line">else</span><br><span class="line">    -- 累加阈值</span><br><span class="line">    redis.call(&quot;INCRBY&quot;, methodKey, 1)</span><br><span class="line">    redis.call(&quot;PEXPIRE&quot;, methodKey, timeout)</span><br><span class="line">    return true</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>Redis加载Lua脚本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.io.ClassPathResource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.DefaultRedisScript;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisScriptConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DefaultRedisScript&lt;Boolean&gt; <span class="title">redisScript</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DefaultRedisScript&lt;Boolean&gt; redisScript = <span class="keyword">new</span> DefaultRedisScript&lt;&gt;();</span><br><span class="line">        <span class="comment">// 脚本位置</span></span><br><span class="line">        redisScript.setLocation(<span class="keyword">new</span> ClassPathResource(<span class="string">"ratelimiter.lua"</span>));</span><br><span class="line">        <span class="comment">// 脚本的返回值，这里返回 boolean</span></span><br><span class="line">        redisScript.setResultType(Boolean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> redisScript;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>限流具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.StringRedisTemplate;</span><br><span class="line"><span class="keyword">import</span> org.springframework.data.redis.core.script.RedisScript;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> *  限流，拦截用户请求</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLimiterHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> StringRedisTemplate redisTemplate;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * lua脚本</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisScript&lt;Boolean&gt; rateLimitLua;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> limit 限流个数，默认每秒的限流个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">limitAccess</span><span class="params">(String key, Integer limit, Long pexpire)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 执行Lua脚本, Collections.singletonList(key) lua脚本中的key</span></span><br><span class="line">        <span class="keyword">boolean</span> acquired = redisTemplate.execute(rateLimitLua, Collections.singletonList(key), limit.toString(), pexpire.toString());</span><br><span class="line">        <span class="keyword">if</span> (!acquired) &#123;</span><br><span class="line">            <span class="comment">// 被拦截了</span></span><br><span class="line">            log.error(<span class="string">"Your access is blocked, key: &#123;&#125;"</span>, key);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Your access is blocked"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




<p>新建一个注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> AccessLimiter &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 限流方法,redis中的key。默认是方法签名</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">String <span class="title">methodKey</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单位时间内允许的请求</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">limit</span><span class="params">()</span> <span class="keyword">default</span> 10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间单位</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">TimeUnit <span class="title">unit</span><span class="params">()</span> <span class="keyword">default</span> TimeUnit.SECONDS</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">timeout</span><span class="params">()</span> <span class="keyword">default</span> 1</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用aop对标注注解的方法拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.storyhasyou.example.ratelimiter.annotation.AccessLimiter;</span><br><span class="line"><span class="keyword">import</span> com.storyhasyou.example.ratelimiter.limiter.AccessLimiterHandler;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Aspect;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.Before;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.reflect.MethodSignature;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.StringUtils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccessLimiterAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> AccessLimiterHandler accessLimiterHandler;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PREFIX = <span class="string">"rate:limiter:"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"@annotation(accessLimiter)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(JoinPoint joinPoint, AccessLimiter accessLimiter)</span> </span>&#123;</span><br><span class="line">        String key = accessLimiter.methodKey();</span><br><span class="line">        <span class="keyword">int</span> limit = accessLimiter.limit();</span><br><span class="line">        <span class="keyword">long</span> timeout = accessLimiter.timeout();</span><br><span class="line">        TimeUnit timeUnit = accessLimiter.unit();</span><br><span class="line">        <span class="keyword">long</span> pexpire = timeUnit.toMillis(timeout);</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isEmpty(key)) &#123;</span><br><span class="line">            MethodSignature signature = (MethodSignature) joinPoint.getSignature();</span><br><span class="line">            String name = signature.getName();</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = signature.getParameterTypes();</span><br><span class="line">            key = name + Stream.of(parameterTypes).map(Class::getName).collect(Collectors.joining(<span class="string">","</span>, <span class="string">"("</span>, <span class="string">")"</span>));</span><br><span class="line">            <span class="comment">// log.info("key = &#123;&#125;", key);</span></span><br><span class="line">        &#125;</span><br><span class="line">        accessLimiterHandler.limitAccess(PREFIX + key, limit, pexpire);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用注解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiterController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 一分钟限流10个请求</span></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/limit"</span>)</span><br><span class="line">    <span class="meta">@AccessLimiter</span>(limit = <span class="number">10</span>, timeout = <span class="number">1</span>, unit = TimeUnit.MINUTES)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseEntity&lt;Void&gt; <span class="title">limit</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResponseEntity.ok().build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>中间件</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot国际化</title>
    <url>/posts/216/</url>
    <content><![CDATA[<p>让国际友人也能快乐的访问的你的服务</p>
<p><code>spring-boot-starter-web</code>里面有国际化需要的API，因此我们不需要引入其他的API了。</p>
  <a id="more"></a>

<h2 id="定义国际化的配置文件"><a href="#定义国际化的配置文件" class="headerlink" title="定义国际化的配置文件"></a>定义国际化的配置文件</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.LocaleResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I18nConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Accept-Language Header 区域解析器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LocaleResolver <span class="title">localeResolver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AcceptHeaderLocaleResolver acceptHeaderLocaleResolver = <span class="keyword">new</span> AcceptHeaderLocaleResolver();</span><br><span class="line">        acceptHeaderLocaleResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE);</span><br><span class="line">        <span class="keyword">return</span> acceptHeaderLocaleResolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加载国际化配置文件资源</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ReloadableResourceBundleMessageSource <span class="title">messageSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ReloadableResourceBundleMessageSource messageSource = <span class="keyword">new</span> ReloadableResourceBundleMessageSource();</span><br><span class="line">        <span class="comment">//设置国际化配置文件存放目录</span></span><br><span class="line">        messageSource.setBasename(<span class="string">"classpath:i18n/messages"</span>);</span><br><span class="line">        <span class="comment">//设置加载资源的缓存失效时间，-1表示永久有效，默认为-1</span></span><br><span class="line">        messageSource.setCacheSeconds(-<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//设定 Resource Bundle 编码方式，默认为UTF-8</span></span><br><span class="line">        messageSource.setDefaultEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> messageSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>AcceptHeaderLocaleResolver</code>：Spring内置的国际化处理，获取Http请求头中的<code>Accept-Language</code>属性，判断当前环境是哪种语言。</p>
<h2 id="在resources目录下，创建i18n目录和两个国际化的文件，要以message开头"><a href="#在resources目录下，创建i18n目录和两个国际化的文件，要以message开头" class="headerlink" title="在resources目录下，创建i18n目录和两个国际化的文件，要以message开头"></a>在<code>resources</code>目录下，创建<code>i18n</code>目录和两个国际化的文件，要以message开头</h2><p>messages_en_US.properties，英文提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete.success&#x3D;delete success.</span><br><span class="line">save.success&#x3D;Save Success.</span><br><span class="line">update.success&#x3D;Update Success.</span><br></pre></td></tr></table></figure>


<p>messages_zh_CN.properties，中文提示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delete.success&#x3D;删除成功</span><br><span class="line">save.success&#x3D;保存成功</span><br><span class="line">update.success&#x3D;更新成功</span><br></pre></td></tr></table></figure>

<h2 id="定义一个工具类，根据当前语言环境和国际化提示中的key获取对应的提示"><a href="#定义一个工具类，根据当前语言环境和国际化提示中的key获取对应的提示" class="headerlink" title="定义一个工具类，根据当前语言环境和国际化提示中的key获取对应的提示"></a>定义一个工具类，根据当前语言环境和国际化提示中的key获取对应的提示</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.i18n.LocaleContextHolder;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ReloadableResourceBundleMessageSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Locale;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">I18nUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReloadableResourceBundleMessageSource messageSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    I18nUtils(ReloadableResourceBundleMessageSource messageSource) &#123;</span><br><span class="line">        I18nUtils.messageSource = messageSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toLocale</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        Locale locale = LocaleContextHolder.getLocale();</span><br><span class="line">        <span class="keyword">return</span> messageSource.getMessage(message, <span class="keyword">null</span>, locale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为了统一管理key，我们用枚举保存。"><a href="#为了统一管理key，我们用枚举保存。" class="headerlink" title="为了统一管理key，我们用枚举保存。"></a>为了统一管理key，我们用枚举保存。</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.AllArgsConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.stream.Stream;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> I18nEnum &#123;</span><br><span class="line"></span><br><span class="line">    SAVE_SUCCESS(<span class="string">"save.success"</span>),</span><br><span class="line">    UPDATE_SUCCESS(<span class="string">"update.success"</span>),</span><br><span class="line">    DELETE_SUCCESS(<span class="string">"delete.success"</span>),</span><br><span class="line">    ;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">message</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Stream.of(I18nEnum.values())</span><br><span class="line">                .map(I18nEnum::message)</span><br><span class="line">                .anyMatch(s::equals);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：用枚举是因为我们在全局异常处理的时候，要获遍历枚举里面的常量，从而判断是否要国际化。</p>
</blockquote>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PostMapping</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ResponseEntity&lt;String&gt; <span class="title">save</span><span class="params">(@RequestBody @Validated UserRequestVO requestVO)</span> </span>&#123;</span><br><span class="line">    userService.save(requestVO);</span><br><span class="line">    <span class="keyword">return</span> ResponseEntity.status(HttpStatus.CREATED)</span><br><span class="line">        .body(I18nUtils.toLocale(I18nEnum.SAVE_SUCCESS.message()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>这样一来，会就完成了提示消息国际化功能。</p>
<p>上面的做法不能让入参校验进行国际化，比如<code>@NotNull(message = &quot;请传入xxxx&quot;)</code>。因此，我们还需要改造，定义两组提示信息</p>
<p>messages_zh_CN.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paging.tip&#x3D;请传入分页参数</span><br></pre></td></tr></table></figure>

<p>messages_en_US.properties</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">paging.tip&#x3D;Please pass in paging parameters</span><br></pre></td></tr></table></figure>


<p>改造注解上的提示信息：<code>@NotNull(message = &quot;paging.tip&quot;)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.validation.constraints.NotNull;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PageRequestVO</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"paging.tip"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer page;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NotNull</span>(message = <span class="string">"paging.tip"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>现在一般提交数据的方式用两种：<strong>表单提交和JSON格式</strong>。</p>
<p>如果是表单提交，校验不通过的话，会抛出<code>BindException</code>。JSON格式的提交，校验不通过则会抛出<code>MethodArgumentNotValidException</code>。所以，我们要拦截这两种异常处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.isecstar.print.common.enums.I18nEnum;</span><br><span class="line"><span class="keyword">import</span> com.isecstar.print.common.utils.I18nUtils;</span><br><span class="line"><span class="keyword">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.DefaultMessageSourceResolvable;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.http.ResponseEntity;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.BindingResult;</span><br><span class="line"><span class="keyword">import</span> org.springframework.validation.FieldError;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.MethodArgumentNotValidException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ExceptionHandler;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.ResponseStatus;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestControllerAdvice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"><span class="keyword">import</span> java.util.stream.Collectors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestControllerAdvice</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GlobalExceptionHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(MethodArgumentNotValidException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">BAD_REQUEST</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="title">methodArgumentNotValidExceptionHandler</span>(<span class="title">MethodArgumentNotValidException</span> <span class="title">methodArgumentNotValidException</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getError(methodArgumentNotValidException, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ExceptionHandler</span>(BindException<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">    @<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">BAD_REQUEST</span>)</span></span><br><span class="line"><span class="class">    <span class="title">public</span> <span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt; <span class="title">bindException</span>(<span class="title">BindException</span> <span class="title">bindException</span>, <span class="title">HttpServletRequest</span> <span class="title">request</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getError(bindException, request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Map&lt;String, Object&gt; <span class="title">getError</span><span class="params">(Exception e, HttpServletRequest request)</span> </span>&#123;</span><br><span class="line">        log.error(<span class="string">""</span>, e);</span><br><span class="line">        Map&lt;String, Object&gt; error = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">5</span>);</span><br><span class="line">        String message = e.getMessage();</span><br><span class="line">        error.put(<span class="string">"message"</span>, I18nEnum.exists(message) ? I18nUtils.toLocale(message) : message);</span><br><span class="line">        error.put(<span class="string">"code"</span>, HttpStatus.INTERNAL_SERVER_ERROR.value());</span><br><span class="line">        <span class="keyword">if</span> (e <span class="keyword">instanceof</span> MethodArgumentNotValidException) &#123;</span><br><span class="line">            MethodArgumentNotValidException methodArgumentNotValidException = (MethodArgumentNotValidException) e;</span><br><span class="line">            BindingResult bindingResult = methodArgumentNotValidException.getBindingResult();</span><br><span class="line">            <span class="comment">// messageList就是写在@NotNull(message = "")message的信息, 这里获取到的是 paging.tip</span></span><br><span class="line">            Set&lt;String&gt; messageList = bindingResult.getFieldErrors().stream().map(FieldError::getDefaultMessage).collect(Collectors.toSet());</span><br><span class="line">            List&lt;String&gt; globalizationMessage = messageList.stream().map(I18nUtils::toLocale).collect(Collectors.toList());</span><br><span class="line">            error.put(<span class="string">"message"</span>, globalizationMessage);</span><br><span class="line">            error.put(<span class="string">"httpStatus"</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">            error.put(<span class="string">"code"</span>, HttpStatus.BAD_REQUEST.value());</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> BindException) &#123;</span><br><span class="line">            BindException bindException = (BindException) e;</span><br><span class="line">            <span class="comment">// messageList就是写在@NotNull(message = "")message的信息, 这里获取到的是 paging.tip</span></span><br><span class="line">            Set&lt;String&gt; messageList = bindException.getBindingResult().getAllErrors().stream().map(DefaultMessageSourceResolvable::getDefaultMessage).collect(Collectors.toSet());</span><br><span class="line">            List&lt;String&gt; globalizationMessage = messageList.stream().map(I18nUtils::toLocale).collect(Collectors.toList());</span><br><span class="line">            error.put(<span class="string">"message"</span>, globalizationMessage);</span><br><span class="line">            error.put(<span class="string">"httpStatus"</span>, HttpStatus.BAD_REQUEST);</span><br><span class="line">            error.put(<span class="string">"code"</span>, HttpStatus.BAD_REQUEST.value());</span><br><span class="line">        &#125;</span><br><span class="line">        error.put(<span class="string">"path"</span>, request.getRequestURI());</span><br><span class="line">        error.put(<span class="string">"timestamp"</span>, LocalDateTime.now());</span><br><span class="line">        <span class="keyword">return</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样一来，我们就可以在校验中，对外国际化之后的异常信息。</p>
]]></content>
      <categories>
        <category>Spring Boot</category>
      </categories>
  </entry>
  <entry>
    <title>线程池详解</title>
    <url>/posts/18252/</url>
    <content><![CDATA[<p>java.uitl.concurrent.ThreadPoolExecutor类是线程池中最核心的一个类，因此如果要透彻地了解Java中的线程池，必须先了解这个类。<br>线程池使用场景：并行操作，异步提交等</p>
<a id="more"></a>

<p>简单理解，它就是一个管理线程的池子。具体作用:</p>
<ul>
<li>它帮我们管理线程，避免增加创建线程和销毁线程的资源损耗。因为线程其实也是一个对象，创建一个对象，需要经过类加载过程，销毁一个对象，需要走GC垃圾回收流程，都是需要资源开销的。</li>
<li>提高响应速度。 如果任务到达了，相对于从线程池拿线程，重新去创建一条线程执行，速度肯定慢很多。</li>
<li>重复利用。 线程用完，再放回池子，可以达到重复利用的效果，节省资源。</li>
</ul>
<h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><p>构造方法如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure>

<p>几个核心参数的作用:</p>
<ul>
<li>corePoolSize：核心线程数</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：空闲超时时间</li>
<li>unit：时间单位</li>
<li>workQueue：工作队列</li>
<li>threadFactory：线程工厂</li>
<li>handler：拒绝策略</li>
</ul>
<p>假设：corePoolSize=5，maximumPoolSize=10，workQueue=10。如果有30个任务提交，线程池的执行机制是什么样的？</p>
<ul>
<li>先使用corePoolSize运行5个任务，接下来会装10个到workQueue中。后面15个的话，会先判断maximumPoolSize，如果大于corePoolSize，会再次创建maximumPoolSize-corePoolSize 个线程执行。目前已经有20个任务在执行了，剩下来的10个会被根据拒绝策略被拒绝掉。</li>
</ul>
<h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><ul>
<li>DiscardOldestPolicy：丢弃最老的任务</li>
<li>DiscardPolicy：直接丢弃</li>
<li>AbortPolicy：抛出异常</li>
<li>CallerRunsPolicy：等待后续的线程执行<br>可以实现RejectedExecutionHandler接口，自定义拒绝策略</li>
</ul>
<h2 id="五种状态"><a href="#五种状态" class="headerlink" title="五种状态"></a>五种状态</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS; <span class="comment">// 000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS; <span class="comment">// 001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS; <span class="comment">// 010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS; <span class="comment">// 011</span></span><br></pre></td></tr></table></figure>
<ul>
<li>RUNNING(111)：运行状态，可以接受新任务，也可以处理队列中任务</li>
<li>SHUTDOWN(000)：待关闭状态，不再接受新任务，但是可以继续处理队列中的任务</li>
<li>STOP(001)：停止状态，不接收新任务，并且会尝试结束执行中任务，当线工作线程数为0时，进入TIDYING状态</li>
<li>TIDYING(010)：整理状态，此时任务都执行完毕，并且也没有工作线程，执行terminated方法后进入TERMINATED状态</li>
<li>TERMINATED(011)：终止状态，此时线程池完全终止了，并且成功释放了所有资源</li>
</ul>
<p>五种状态的扭转图如下<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/121n9.png" alt=""></p>
<p>获取线程状态和工作线程数量分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure>
<p>ctl 这个变量用于保存当前容器的运行状态和容器大小，并存在于ThreadPoolExecutor的整个生命周期 (32bit = 3 + 29)，高三位去表示状态，低29位表示工作线程数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>; <span class="comment">// Integer.SIZE = 32</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p><code>COUNT_BITS</code>就是低29位，CAPACITY相当于掩码_ </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125; <span class="comment">// ~CAPACITY表示取反，获得高三位，得到运行状态</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125; <span class="comment">// 得到低29位，worker的运行数量</span></span><br></pre></td></tr></table></figure>


<h2 id="线程池的工作队列"><a href="#线程池的工作队列" class="headerlink" title="线程池的工作队列"></a>线程池的工作队列</h2><p>线程池都有哪几种工作队列？</p>
<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>DelayQueue</li>
<li>PriorityBlockingQueue</li>
<li>SynchronousQueue</li>
</ul>
<h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>ArrayBlockingQueue（有界队列）是一个用数组实现的有界阻塞队列，按FIFO排序量。</p>
<h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue（可设置容量队列）基于链表结构的阻塞队列，按FIFO排序任务，容量可以选择进行设置，不设置的话，将是一个无边界的阻塞队列，最大长度为<code>Integer.MAX_VALUE</code>，吞吐量通常要高于ArrayBlockingQuene；newFixedThreadPool线程池使用了这个队列。</p>
<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue（延迟队列）是一个任务定时周期的延迟执行的队列。根据指定的执行时间从小到大排序，否则根据插入到队列的先后排序。newScheduledThreadPool线程池使用了这个队列。</p>
<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue（优先级队列）是具有优先级的无界阻塞队列。</p>
<h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>ynchronousQueue（同步队列）一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene，newCachedThreadPool线程池使用了这个队列。</p>
<h2 id="线程池参数配置"><a href="#线程池参数配置" class="headerlink" title="线程池参数配置"></a>线程池参数配置</h2><p>线程池参数配置一般有两种类型：CPU密集型和IO密集型</p>
<ul>
<li>CPU密集型：corePoolSize = CPU核心数 + 1 或者 CPU核心数 x 2, maximumPoolSize =cpu数量 x 2 + 1。目的减少线程的切换</li>
<li>IO密集型：corePoolSize = CPU核心数 / (1 - 阻塞系数)，maximumPoolSize = (cpu数量 / (1 - 阻塞系数)) x 2。阻塞系数在<code>0.8~0.9</code>之间。目的减少线程的等待时间<br>以上只是大致的配置，具体情况根据业务情况自行判断<h3 id="使用JDK的ThreadPoolExecutor配置"><a href="#使用JDK的ThreadPoolExecutor配置" class="headerlink" title="使用JDK的ThreadPoolExecutor配置"></a>使用JDK的ThreadPoolExecutor配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.LinkedBlockingQueue;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadFactory;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicInteger;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolExecutor <span class="title">threadPoolExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpu = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> corePoolSize = cpu + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maximumPoolSize = cpu * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> keepAliveTime = <span class="number">1L</span>;</span><br><span class="line">        <span class="keyword">final</span> TimeUnit timeUnit = TimeUnit.SECONDS;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxQueueNum = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(</span><br><span class="line">                corePoolSize,</span><br><span class="line">                maximumPoolSize,</span><br><span class="line">                keepAliveTime,</span><br><span class="line">                timeUnit,</span><br><span class="line">                <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(maxQueueNum),</span><br><span class="line">                <span class="keyword">new</span> CustomThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy()</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> ThreadGroup group;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger threadNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> String namePrefix;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        CustomThreadFactory() &#123;</span><br><span class="line">            SecurityManager s = System.getSecurityManager();</span><br><span class="line">            group = (s != <span class="keyword">null</span>) ? s.getThreadGroup() : Thread.currentThread().getThreadGroup();</span><br><span class="line">            AtomicInteger poolNumber = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line">            namePrefix = <span class="string">"fx-pool-"</span> + poolNumber.getAndIncrement() + <span class="string">"-thread-"</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">            Thread thread = <span class="keyword">new</span> Thread(group, runnable, namePrefix + threadNumber.getAndIncrement(), <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 设置不是守护线程</span></span><br><span class="line">            <span class="keyword">if</span> (thread.isDaemon()) &#123;</span><br><span class="line">                thread.setDaemon(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 设置优先级为默认的</span></span><br><span class="line">            <span class="keyword">if</span> (thread.getPriority() != Thread.NORM_PRIORITY) &#123;</span><br><span class="line">                thread.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> thread;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<h3 id="使用SpringBoot配置"><a href="#使用SpringBoot配置" class="headerlink" title="使用SpringBoot配置"></a>使用SpringBoot配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.scheduling.concurrent.ThreadPoolTaskExecutor;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ThreadPoolExecutor;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ThreadPoolTaskExecutor <span class="title">threadPoolTaskExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> cpu = Runtime.getRuntime().availableProcessors();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> corePoolSize = cpu + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maximumPoolSize = cpu * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> keepAliveTime = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> maxQueueNum = <span class="number">1</span> &lt;&lt; <span class="number">7</span>;</span><br><span class="line">        ThreadPoolTaskExecutor executor = <span class="keyword">new</span> ThreadPoolTaskExecutor();</span><br><span class="line">        executor.setCorePoolSize(corePoolSize);</span><br><span class="line">        executor.setMaxPoolSize(maximumPoolSize);</span><br><span class="line">        executor.setQueueCapacity(maxQueueNum);</span><br><span class="line">        executor.setWaitForTasksToCompleteOnShutdown(<span class="keyword">true</span>);</span><br><span class="line">        executor.setKeepAliveSeconds(keepAliveTime);</span><br><span class="line">        <span class="comment">// CALLER_RUNS：不在新线程中执行任务，而是有调用者所在的线程来执行</span></span><br><span class="line">        executor.setRejectedExecutionHandler(<span class="keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());</span><br><span class="line">        executor.setThreadNamePrefix(<span class="string">"fxipp-pool-thread-"</span>);</span><br><span class="line">        executor.initialize();</span><br><span class="line">        <span class="keyword">return</span> executor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="核心方法解析"><a href="#核心方法解析" class="headerlink" title="核心方法解析"></a>核心方法解析</h2><h3 id="整体工作流程分析"><a href="#整体工作流程分析" class="headerlink" title="整体工作流程分析"></a>整体工作流程分析</h3><p>先看一下线程池的任务流程图<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/lfya7.png" alt=""></p>
<ul>
<li>execute(): 起始方法</li>
<li>Worker: 执行任务的角色, 存储在workers中。worker的目的就是为了执行一个个的任务。一个worker对象就是一个线程</li>
<li>Runnable Task: 阻塞队列，如果核心线程数满了，任务会放在该队列</li>
</ul>
<h3 id="execute-方法分析"><a href="#execute-方法分析" class="headerlink" title="execute() 方法分析"></a>execute() 方法分析</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前线程池中的线程数少于corePoolSize，则调用addWorker(任务, 是否核心线程)创建一个新核心线程执行任务</span></span><br><span class="line">    <span class="comment">// workerCountOf: 获取当前核心线程数</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果核心线程已满，调用workQueue.offer() 方法，把当前任务添加到队列中。</span></span><br><span class="line">    <span class="comment">// 如果当前是运行状态 &amp;&amp; 成功添加到阻塞队列中</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">// 重新检查状态</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果不是运行状态，进行删除队列元素并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (!isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工作线程数为0，而且是运行状态</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 第一个参数是null，表示没有任务加入。第二个参数是false，说明当前线程池中工作线程数大于corePoolSize</span></span><br><span class="line">            <span class="comment">// 还需要创建一个线程执行任务</span></span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加入失败，核心线程已满，队列已满，则尝试创建一个线程执行</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        <span class="comment">// 创建线程失败，执行拒绝策略</span></span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="addWorker-方法分析"><a href="#addWorker-方法分析" class="headerlink" title="addWorker() 方法分析"></a>addWorker() 方法分析</h3><p>对一些参数进行判断，如果通过则创建新线程执行任务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1.线程池已经shutdown之后，直接拒绝</span></span><br><span class="line">        <span class="comment">// 2. showdown状态时，传进来的任务为空，且队列不为空，是允许添加新线程的。如果条件取反，就表示不允许添加worker</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 获取worker工作线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果工作线程数大于默认容量或者大于动态线程数大小，则直接返回false，表示不能添加worker</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 通过cas操作添加工作线程数量，如果成功，直接退出执行for循环之后的操作。失败则重试。数量+1，线程还没创建</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 再次获取运行状态</span></span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs)</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上面代码主要对workers的数量做cas + 1操作，下面才是构建worker对象</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;    <span class="comment">// worker是否已经启动</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;      <span class="comment">// worker是否添加完成</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 创建一个worker，入参是当前提交的任务.worker的目的就是开启新线程执行一个个的任务</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取当前worker中的线程</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取worker的锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 加锁阻塞，避免并发</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">    </span><br><span class="line">                <span class="comment">// 获取运行状态</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果是运行状态，或者SHUTDOWN状态且firstTask是空(队列中有任务)，才能添加到workers集合中</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">    </span><br><span class="line">                    <span class="comment">// 任务封装到worker里面，还没start</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 添加到工作集合</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 如果集合中的工作线程数大于最大线程数，这个最大线程数是曾经出现过的最大线程数</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        <span class="comment">// 更新线程池中出现的最大线程数</span></span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    <span class="comment">// 工作线程已经添加完毕，打个标识</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 释放锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                <span class="comment">// 如果添加成功，则启动工作线程。并标记启动成功</span></span><br><span class="line">                t.start();</span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果启动线程失败，则调用addWorkerFailed。递减实际工作线程数，还原之前的cas+1操作</span></span><br><span class="line">        <span class="keyword">if</span> (!workerStarted)</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否启动成功标识</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="runWorker-方法分析"><a href="#runWorker-方法分析" class="headerlink" title="runWorker() 方法分析"></a>runWorker() 方法分析</h3><p>runWorker主要执行任务</p>
<ol>
<li>addWorker主要是添加工作线程</li>
<li>runWorker具体的执行任务方法</li>
<li>如果task不为空，则直接执行</li>
<li>如果task为空，通过getTask()方法获取任务，如果取到的不为空则执行该任务</li>
<li>执行完毕后，通过while循环继续获取任务</li>
<li>如果还是获取不到任务，这个runWorker()执行完毕</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock();</span><br><span class="line">    <span class="comment">// 标记变量，表示执行中是否出现异常</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 上锁不是为了并发控制，因为worker本身就是单线程执行的。</span></span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否被中断</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                 (Thread.interrupted() &amp;&amp;</span><br><span class="line">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                !wt.isInterrupted())</span><br><span class="line">                wt.interrupt();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 任务运行前缀处理器</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 执行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">// 任务运行后缀处理器</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">// 记录该Worker完成数量</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 如果发生异常，删除该任务，销毁工作线程</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>Spring IOC⾼级特性</title>
    <url>/posts/14511/</url>
    <content><![CDATA[<p>主要介绍四个高级特性: SpringBean的生命周期，lazy-Init 延迟加载，FactoryBean 和 BeanFactory，后置处理器</p>
<a id="more"></a>


<h2 id="SpringBean的生命周期"><a href="#SpringBean的生命周期" class="headerlink" title="SpringBean的生命周期"></a>SpringBean的生命周期</h2><ol>
<li>实例化Bean，根据配置情况调⽤ Bean 构造⽅法或⼯⼚⽅法实例化 Bean。</li>
<li>设置属性值，利⽤依赖注⼊完成 Bean 中所有属性值的配置注⼊。</li>
<li>调⽤BeanNameAware的setBeanName⽅法，如果 Bean 实现了 BeanNameAware 接⼝，则 Spring 调⽤ Bean 的 setBeanName() ⽅法传⼊当前 Bean 的 id 值。</li>
<li>调⽤BeanFactoryAware的setBeanFactory⽅法，如果 Bean 实现了 BeanFactoryAware 接⼝，则 Spring 调⽤ setBeanFactory() ⽅法传⼊当前⼯⼚实例的引⽤。</li>
<li>调⽤ ApplicationContextAware的setApplicationContext⽅法，如果 Bean 实现了 ApplicationContextAware 接⼝，则 Spring 调⽤ setApplicationContext() ⽅法传⼊当前 ApplicationContext 实例的引⽤。</li>
<li>调⽤ BeanPostProcessor 的预初始化⽅法，如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调⽤该接⼝的预初始化⽅法postProcessBeforeInitialzation() 对 Bean 进⾏加⼯操作。_此处⾮常重要，Spring 的 AOP 就是利⽤它实现的。_</li>
<li>调⽤InitializingBean的afterPropertiesSet⽅法，如果 Bean 实现了 InitializingBean 接⼝，则 Spring 将调⽤ afterPropertiesSet() ⽅法。</li>
<li>调⽤定制的初始化⽅法init-method，如果在配置⽂件中通过 init-method 属性指定了初始化⽅法，则调⽤该初始化⽅法。</li>
<li>调⽤ BeanPostProcessor 的后初始化⽅法，如果 BeanPostProcessor 和 Bean 关联，则 Spring 将调⽤该接⼝的初始化⽅法 postProcessAfterInitialization()。此时，Bean 已经可以被应⽤系统使⽤了。</li>
<li>如果Bean是单例的，则将该 Bean 放⼊ Spring IoC 的缓存池中。如果Bean是原型，则将该 Bean 交给调⽤者</li>
<li>如果 Bean 实现了 DisposableBean 接⼝，则 Spring 会调⽤ destory() ⽅法将 Spring 中的 Bean 销毁。如果在配置⽂件中通过 destory-method 属性指定了 Bean 的销毁⽅法，则 Spring 将调⽤该⽅法对 Bean 进⾏销毁。</li>
</ol>
<h2 id="lazy-Init-延迟加载"><a href="#lazy-Init-延迟加载" class="headerlink" title="lazy-Init 延迟加载"></a>lazy-Init 延迟加载</h2><p>ApplicationContext 容器的默认⾏为是在启动服务器时将所有 singleton bean 提前进⾏实例化。提前实例化意味着作为初始化过程的⼀部分，ApplicationContext 实例会创建并配置所有的singleton bean。</p>
<p>如果不想让⼀个singleton bean 在 ApplicationContext实现初始化时被提前实例化，那么可以将bean 设置为延迟实例化。</p>
<p>在bean的类上，加入<code>@Lazy</code>则会被延迟加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Lazy</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果⼀个设置了⽴即加载的 bean1，引⽤了⼀个延迟加载的 bean2 ，那么 bean1 在容器启动时被实例 化，⽽ bean2 由于被 bean1 引⽤，所以也被实例化，这种情况也符合延时加载的 bean 在第⼀次调⽤ 时才被实例化的规则。</p>
<p>应⽤场景</p>
<ul>
<li>开启延迟加载⼀定程度提⾼容器启动和运转性能</li>
<li>对于不常使⽤的 Bean 设置延迟加载，这样偶尔使⽤的时候再加载，不必要从⼀开始该 Bean 就占 ⽤资源</li>
</ul>
<h2 id="FactoryBean-和-BeanFactory"><a href="#FactoryBean-和-BeanFactory" class="headerlink" title="FactoryBean 和 BeanFactory"></a>FactoryBean 和 BeanFactory</h2><p>BeanFactory接⼝是容器的顶级接⼝，定义了容器的⼀些基础⾏为，负责⽣产和管理Bean的⼀个⼯⼚， 具体使⽤它下⾯的⼦接⼝类型，⽐如ApplicationContext；此处我们重点分析FactoryBean</p>
<p>Spring中Bean有两种，⼀种是普通Bean，⼀种是⼯⼚Bean（FactoryBean），FactoryBean可以⽣成 某⼀个类型的Bean实例（返回给我们），也就是说我们可以借助于它⾃定义Bean的创建过程。</p>
<p>Bean创建的三种⽅式中的静态⽅法和实例化⽅法和FactoryBean作⽤类似，FactoryBean使⽤较多，尤 其在Spring框架⼀些组件中会使⽤，还有其他框架和Spring框架整合时使⽤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FactoryBean</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	String OBJECT_TYPE_ATTRIBUTE = <span class="string">"factoryBeanObjectType"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回FactoryBean创建的Bean实例，如果isSingleton返回true，则该实例会放到Spring容器 的单例对象缓存池中Map</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function">T <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回FactoryBean创建的Bean类型</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	Class&lt;?&gt; getObjectType();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 返回作⽤域是否单例</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>简单使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Company</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> scale;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现FactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompanyFactoryBean</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span>&lt;<span class="title">Company</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公司名称,地址,规模</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String companyInfo;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CompanyFactoryBean</span><span class="params">(String companyInfo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.companyInfo = companyInfo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Company <span class="title">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟创建复杂对象Company</span></span><br><span class="line">        Company company = <span class="keyword">new</span> Company();</span><br><span class="line">        String[] strings = companyInfo.split(<span class="string">","</span>);</span><br><span class="line">        company.setName(strings[<span class="number">0</span>]);</span><br><span class="line">        company.setAddress(strings[<span class="number">1</span>]);</span><br><span class="line">        company.setScale(Integer.parseInt(strings[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">return</span> company;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Company<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注册FactoryBean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryBeanConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CompanyFactoryBean <span class="title">companyBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompanyFactoryBean(<span class="string">"明日曦月,南京,2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取两个Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"com.storyhasyou.spring"</span>);</span><br><span class="line">	<span class="comment">// 获取FactoryBean产⽣的对象</span></span><br><span class="line">    Company company = applicationContext.getBean(<span class="string">"companyBean"</span>, Company<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">	<span class="comment">// 获取FactoryBean，需要在id之前添加“&amp;”</span></span><br><span class="line">    CompanyFactoryBean companyFactoryBean = applicationContext.getBean(<span class="string">"&amp;companyBean"</span>, CompanyFactoryBean<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    System.out.println(company); <span class="comment">// Company(name=明日曦月, address=南京, scale=2)</span></span><br><span class="line">    System.out.println(companyFactoryBean); <span class="comment">// com.storyhasyou.spring.factorybean.CompanyFactoryBean@52e677af</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用场景</p>
<ul>
<li>在与Spring整合中的框架用的多，比如spring-mybatis</li>
</ul>
<h2 id="后置处理器"><a href="#后置处理器" class="headerlink" title="后置处理器"></a>后置处理器</h2><p>Spring提供了两种后处理bean的扩展接⼝，分别为 BeanPostProcessor 和 BeanFactoryPostProcessor，两者在使⽤上是有所区别的。</p>
<p>⼯⼚初始化（BeanFactory）—&gt; Bean对象，在BeanFactory初始化之后可以使⽤BeanFactoryPostProcessor进⾏后置处理做⼀些事情，在Bean对象实例化（并不是Bean的整个⽣命周期完成）之后可以使⽤BeanPostProcessor进⾏后置处理做⼀些事情。</p>
<p><em>对象不⼀定是spring bean，⽽spring bean⼀定是个对象</em></p>
<h3 id="BeanPostProcessor"><a href="#BeanPostProcessor" class="headerlink" title="BeanPostProcessor"></a>BeanPostProcessor</h3><p>BeanPostProcessor是针对Bean级别的处理，可以针对某个具体的Bean.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="meta">@Nullable</span></span><br><span class="line">	<span class="function"><span class="keyword">default</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> bean;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接⼝提供了两个⽅法，分别在Bean的初始化⽅法前和初始化⽅法后执⾏。<br>具体这个初始化⽅法指的是什么⽅法？类似我们在定义bean时，定义了init-method所指定的⽅法。</p>
<p>定义⼀个类实现了BeanPostProcessor，默认是会对整个Spring容器中所有的bean进⾏处理。如果要对 具体的某个bean处理，可以通过⽅法参数判断，两个类型参数分别为Object和String，第⼀个参数是每个bean的实例，第⼆个参数是每个bean的name或者id属性的值。所以我们可以通过第⼆个参数，来判断我们将要处理的具体的bean。</p>
<p><em>处理是发⽣在Spring容器的实例化和依赖注⼊之后。</em></p>
<p>准备Bean对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Data;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String phone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>拦截具体实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.beans.BeansException;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> fangxi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2020/4/13</span></span><br><span class="line"><span class="comment"> * 拦截实例化之后的对象，实例化了并且注入属性了</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"user"</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"user bean 被UserBeanPostProcessor#before"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"user"</span>.equals(beanName)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"user bean 被UserBeanPostProcessor#after"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> AnnotationConfigApplicationContext(<span class="string">"com.storyhasyou.spring"</span>);</span><br><span class="line">        User user = applicationContext.getBean(<span class="string">"user"</span>, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">user bean 被UserBeanPostProcessor#before</span><br><span class="line">user bean 被UserBeanPostProcessor#after</span><br><span class="line">User(name=<span class="keyword">null</span>, phone=<span class="keyword">null</span>)</span><br></pre></td></tr></table></figure>

<h3 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h3><p>BeanFactory级别的处理，是针对整个Bean的⼯⼚进⾏处理，典型应⽤:PropertyPlaceholderConﬁgurer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此接⼝只提供了⼀个⽅法，⽅法参数为ConﬁgurableListableBeanFactory，该参数类型定义了⼀些⽅法<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/dkgap.png" alt=""></p>
<p>其中有个⽅法名为getBeanDeﬁnition的⽅法，我们可以根据此⽅法，找到我们定义bean 的 BeanDeﬁnition对象。然后我们可以对定义的属性进⾏修改。</p>
<blockquote>
<p>BeanDeﬁnition对象：我们在 XML 中定义的 bean 标签，Spring 解析 bean 标签成为⼀个 JavaBean， 这个JavaBean 就是 BeanDeﬁnition</p>
</blockquote>
<p>调⽤ BeanFactoryPostProcessor ⽅法时，这时候bean还没有实例化，此时 bean 刚被解析成 BeanDeﬁnition对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="string">"user"</span>);</span><br><span class="line">        <span class="comment">// 可以使用beanDefinition对象干涉spring创建bean的动作</span></span><br><span class="line">        beanDefinition.setLazyInit(<span class="keyword">true</span>);</span><br><span class="line">        beanDefinition.setDescription(<span class="string">"hehe"</span>);</span><br><span class="line">        beanDefinition.setPrimary(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
  </entry>
  <entry>
    <title>大型网站架构演化</title>
    <url>/posts/13992/</url>
    <content><![CDATA[<p>对于技术人员来说，“架构”是一个再常见不过的词了。我们会对新员工培训整个系统的架构，参加架构设计评审，学习业界开源系统（例如，MySQL、Hadoop）的架构，研究大公司的架构实现（例如，微信架构、淘宝架构）……虽然“架构”这个词常见，但如果深究一下“架构”到底指什么，大部分人也许并不一定能够准确地回答。</p>
<a id="more"></a>


<h2 id="大型网站软件系统的特点"><a href="#大型网站软件系统的特点" class="headerlink" title="大型网站软件系统的特点"></a>大型网站软件系统的特点</h2><ul>
<li>高并发、大流量：需要面对高并发用户，大流量访问。</li>
<li>高可用：系统 7x24小时不间断服务。</li>
<li>海量数据：需要存储、管理海量数据，需要使用大量的服务器。</li>
<li>用户分布广泛，网络情况复杂：很多大型互联网服务的用户都是全球各地的，而且各个运营商之间的通信也是难题。</li>
<li>安全环境恶劣：互联网的开放性，使得有很多网站遭受攻击。</li>
<li>需求快速变更，发布频繁：和传统软件不同，互联网项目为了快速适应市场，满足用户需求，其发布的速度是极高的。</li>
<li>渐进式发展：很多大型的互联网都是从一个小网站开始的，逐渐的发展起来的。</li>
</ul>
<h2 id="大型网站架构演化发展历程"><a href="#大型网站架构演化发展历程" class="headerlink" title="大型网站架构演化发展历程"></a>大型网站架构演化发展历程</h2><ol>
<li>初始阶段的网站架构：应用程序、数据库、文件等所有的资源都放在一个服务器上，通常是Linux。用户一多导致性能越来越差。</li>
<li>应用服务和数据服务分离：应用程序、数据库、文件分别放在三个不同的服务器上。用户多了会导致数据库压力太大，影响整个性能。</li>
<li>使用缓存改善网站性能：网站访问也遵循着二八定律：80%的业务访问集中在20%的数据上。我们可以将一小部分数据缓存在内存中，就可以减少数据库的压力，改善数据库的写入性能。</li>
<li>使用应用服务器集群改善网络的并发处理能力：一个服务部署多个节点，通过负载均衡，可以将单台服务器的压力分散到多个服务器上。</li>
<li>数据库读写分离：大部分主流数据库提供热备功能，通过配置两台数据库的主从关系，可以将一台数据库服务器的数据同步到另一台上。写数据访问主数据库，读数据访问从数据库。</li>
<li>使用反向代理和CDN加速响应：CDN和反向代理其实都是缓存，区别在于CDN部署在网络提供商的机房，可以在用户访问的时候访问所在最近的机房获取数据；用户首先访问反向代理服务器，如果服务器上有用户请求的资源，可以直接返回给用户。</li>
<li>使用分布式文件系统和分布式数据库系统：可以使用云上的OSS系统，数据量如果很多，采用分库分表的方式访问。</li>
<li>使用NoSQL和搜索引擎：随着业务的发展，对数据的存储和检索也很复杂，网站需要一些NoSQL和非数据库查询手段。</li>
<li>业务拆分：业务越来越多的时候，通过使用分而治之的手段将这个业务分拆不同的产品线，如大型的电商可以分为首页、商铺、订单、买家、卖家等。</li>
<li>分布式服务：可以将许多相同的业务操作，如用户管理，商品管理等这些公共等业务抽取出来，独立部署。</li>
</ol>
<h2 id="大型网站演化的价值观"><a href="#大型网站演化的价值观" class="headerlink" title="大型网站演化的价值观"></a>大型网站演化的价值观</h2><p>没有什么网站一开始就是大型网站，都是从小型网站发展过来的，淘宝、京东也是如此。大型网站架构要做到可变形，随着网站所要的需求灵活应对。驱动大型网站架构发展的力量是网站的业务发展。不要一味这追随大公司的解救方案，学会借鉴大公司的经验成功模式，而不是跟着抄。也不要盲目追求最新的技术，适合就行。</p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
  </entry>
  <entry>
    <title>PropertyMapper使用</title>
    <url>/posts/42061/</url>
    <content><![CDATA[<p><code>PropertyMapper</code>是Spring提供的一个工具类，主要用于重新赋值，转换等操作，位于<code>org.springframework.boot.context.properties.PropertyMapper</code>下。</p>
<a id="more"></a>

<p>我第一次发现这个类是在<code>spring-boot-starter-amqp</code>中，配置<code>RabbitTemplate</code>中看到的</p>
<p>代码位于<code>org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration.RabbitTemplateConfiguration</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConditionalOnSingleCandidate</span>(ConnectionFactory<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ConditionalOnMissingBean</span>(<span class="title">RabbitOperations</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">RabbitTemplate</span> <span class="title">rabbitTemplate</span>(<span class="title">RabbitProperties</span> <span class="title">properties</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">ObjectProvider</span>&lt;<span class="title">MessageConverter</span>&gt; <span class="title">messageConverter</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">ObjectProvider</span>&lt;<span class="title">RabbitRetryTemplateCustomizer</span>&gt; <span class="title">retryTemplateCustomizers</span>,</span></span><br><span class="line"><span class="class">                                     <span class="title">ConnectionFactory</span> <span class="title">connectionFactory</span>) </span>&#123;</span><br><span class="line">    PropertyMapper map = PropertyMapper.get();</span><br><span class="line">    RabbitTemplate template = <span class="keyword">new</span> RabbitTemplate(connectionFactory);</span><br><span class="line">    messageConverter.ifUnique(template::setMessageConverter);</span><br><span class="line">    template.setMandatory(determineMandatoryFlag(properties));</span><br><span class="line">    RabbitProperties.Template templateProperties = properties.getTemplate();</span><br><span class="line">    <span class="keyword">if</span> (templateProperties.getRetry().isEnabled()) &#123;</span><br><span class="line">        template.setRetryTemplate(</span><br><span class="line">            <span class="keyword">new</span> RetryTemplateFactory(retryTemplateCustomizers.orderedStream().collect(Collectors.toList()))</span><br><span class="line">            .createRetryTemplate(templateProperties.getRetry(),</span><br><span class="line">                                 RabbitRetryTemplateCustomizer.Target.SENDER));</span><br><span class="line">    &#125;</span><br><span class="line">    map.from(templateProperties::getReceiveTimeout).whenNonNull().as(Duration::toMillis)</span><br><span class="line">        .to(template::setReceiveTimeout);</span><br><span class="line">    map.from(templateProperties::getReplyTimeout).whenNonNull().as(Duration::toMillis)</span><br><span class="line">        .to(template::setReplyTimeout);</span><br><span class="line">    map.from(templateProperties::getExchange).to(template::setExchange);</span><br><span class="line">    map.from(templateProperties::getRoutingKey).to(template::setRoutingKey);</span><br><span class="line">    map.from(templateProperties::getDefaultReceiveQueue).whenNonNull().to(template::setDefaultReceiveQueue);</span><br><span class="line">    <span class="keyword">return</span> template;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那一个个的 from….to…让我很好奇，于是便研究了一下他的用法。</p>
<p>在实际工作中，经常会遇到将数据库的实体类Entity转成DTO类的操作，通常情况。我们有可以将属性一个个get出来，在set进去。还有一种就是用BeanUtils工具类将对应类型的属性一个个copy进去。</p>
<p>了解了<code>PropertyMapper</code>之后，我们有多了一种方法转换了。</p>
<p>先建立两个类，Order和OrderDTO</p>
<p>Order.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalAmout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> LocalDateTime createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>OrderDTO.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderDTO</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> BigDecimal totalAmout;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long userId;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String createTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>使用<code>PropertyMapper</code>转换</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Order order = <span class="keyword">new</span> Order();</span><br><span class="line">order.setId(<span class="number">1L</span>);</span><br><span class="line">order.setStatus(<span class="number">1</span>);</span><br><span class="line">order.setTotalAmout(BigDecimal.ONE);</span><br><span class="line">order.setUserId(<span class="number">100L</span>);</span><br><span class="line">order.setCreateTime(LocalDateTime.now());</span><br><span class="line"></span><br><span class="line">PropertyMapper propertyMapper = PropertyMapper.get();</span><br><span class="line">OrderDTO orderDTO = <span class="keyword">new</span> OrderDTO();</span><br><span class="line">propertyMapper.from(order::getId).to(orderDTO::setId);</span><br><span class="line"><span class="comment">// 如果from获取到的元素不是null，则执行to里面的动作</span></span><br><span class="line">propertyMapper.from(order::getStatus).whenNonNull().to(orderDTO::setStatus);</span><br><span class="line">propertyMapper.from(order::getUserId).to(orderDTO::setUserId);</span><br><span class="line">propertyMapper.from(order::getTotalAmout).to(orderDTO::setTotalAmout);</span><br><span class="line"><span class="comment">// 因为Order里面的createTime是LocalDateTime类型，OrderDTO里面则是String类型，需要转换一下</span></span><br><span class="line">propertyMapper.from(order::getCreateTime).as(createTime -&gt; &#123;</span><br><span class="line">    DateTimeFormatter formatter = DateTimeFormatter.ofPattern(<span class="string">"yyyy-MM-dd HH:mm:ss"</span>);</span><br><span class="line">    <span class="keyword">return</span> createTime.format(formatter);</span><br><span class="line">&#125;).to(orderDTO::setCreateTime);</span><br></pre></td></tr></table></figure>

<p>这样一来就可以通过<code>PropertyMapper</code>将Order对象的值set到OrderDTO对象中。</p>
<p><code>PropertyMapper</code>常用方法</p>
<ul>
<li><code>&lt;T&gt; Source&lt;T&gt; from(Supplier&lt;T&gt; supplier)</code>：提供值的来源，入参为<code>Supplier</code></li>
<li><code>&lt;T&gt; Source&lt;T&gt; from(T value)</code>：一种重载形式，入参可以为一个对象</li>
<li><code>void to(Consumer&lt;T&gt; consumer)</code>：通过将任何未过滤的值传递给指定的使用者来完成映射</li>
<li><code>&lt;R&gt; R toInstance(Function&lt;T, R&gt; factory)</code>：通过从未过滤的值创建新实例来完成映射</li>
<li><code>void toCall(Runnable runnable)</code>：当值还没有时，通过调用指定的方法来完成映射</li>
<li><code>&lt;R&gt; Source&lt;R&gt; as(Function&lt;T, R&gt; adapter)</code>：将T类型的入参转成R类型的出参，类似于Stream中的map</li>
<li><code>Source&lt;T&gt; when...</code>：这一系列方法，都是过滤用的。在<code>from</code>后面调用，如果满足条件，就直接<code>to</code>方法</li>
<li><code>static PropertyMapper get()</code>：提供<code>PropertyMapper</code>实例</li>
<li><code>PropertyMapper alwaysApplyingWhenNonNull()</code>：提供实例时，当前实例就过滤掉<code>from</code>之后是null的元素。<code>PropertyMapper.get().alwaysApplyingWhenNonNull();</code></li>
<li><code>PropertyMapper alwaysApplying(SourceOperator operator)</code>：自定义过滤规则，参考代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PropertyMapper propertyMapper = PropertyMapper.get().alwaysApplying(<span class="keyword">new</span> PropertyMapper.SourceOperator() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> &lt;T&gt; PropertyMapper.<span class="function">Source&lt;T&gt; <span class="title">apply</span><span class="params">(PropertyMapper.Source&lt;T&gt; source)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> source.when(t -&gt; t <span class="keyword">instanceof</span> LocalDateTime);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>就好比，当前 <code>PropertyMapper</code>只会映射 <code>LocalDateTime</code>类型的字段。</p>
<p>注意：如果<code>from</code>方法后面有<code>when</code>条件，则<code>alwaysApplying</code>中设置的初始化提交将会失效。</p>
<p>Spring里面还有各式各样的类似这样的高逼格，方便使用的小工具。多多阅读Spring源码，就可以发现好多。</p>
]]></content>
      <categories>
        <category>小工具</category>
      </categories>
  </entry>
  <entry>
    <title>通过 CompletableFuture 组装异步计算单元</title>
    <url>/posts/41791/</url>
    <content><![CDATA[<p>CompletableFuture是1.8引入的新特性，一些比较复杂的异步计算场景，尤其是需要串联多个异步计算单元的场景，可以考虑使用 CompletableFuture 来实现。</p>
<a id="more"></a>


<h2 id="CompletableFuture-介绍"><a href="#CompletableFuture-介绍" class="headerlink" title="CompletableFuture 介绍"></a>CompletableFuture 介绍</h2><p>在现实世界中，我们需要解决的复杂问题都是要分为若干步骤。就像我们的代码一样，一个复杂的逻辑方法中，会调用多个方法来一步一步实现。</p>
<p>设想如下场景，植树节要进行植树，分为下面几个步骤：</p>
<ol>
<li>挖坑 10 分钟</li>
<li>拿树苗 5 分钟</li>
<li>种树苗 20 分钟</li>
<li>浇水 5 分钟</li>
</ol>
<p>其中 1 和 2 可以并行，1 和 2 都完成了才能进行步骤 3，然后才能进行步骤 4。</p>
<p>我们有如下几种实现方式：</p>
<h3 id="只有一个人种树"><a href="#只有一个人种树" class="headerlink" title="只有一个人种树"></a>只有一个人种树</h3><p>如果现在只有一个人植树，要种 100 棵树，那么只能按照如下顺序执行：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/a9udw.jpg" alt=""></p>
<p>图中仅列举种三棵树示意。可以看到串行执行，只能种完一棵树再种一棵，那么种完 100 棵树需要 <code>40 * 100 = 4000 分钟</code>。<br>这种方式对应到程序，就是单线程同步执行。</p>
<h3 id="三个人同时种树，每个人负责种一棵树"><a href="#三个人同时种树，每个人负责种一棵树" class="headerlink" title="三个人同时种树，每个人负责种一棵树"></a>三个人同时种树，每个人负责种一棵树</h3><p>如何缩短种树时长呢？你肯定想这还不好办，学习了这么久的并发，这肯定难不倒我。不是要种 100 棵树吗？那我找 100 个人一块种，每个人种一棵。那么只需要 40 分钟就可以种完 100 棵树了。</p>
<p>没错，如果你的程序有个方法叫做 plantTree，里面包含了如上四部，那么你起 100 个线程就可以了。但是，请注意，100 个线程的创建和销毁需要消耗大量的系统资源。并且创建和销毁线程都有时间消耗。此外CPU的核数并不能真的支持100个线程并发。如果我们要种1万棵树呢？总不能起一万个线程吧？</p>
<p>所以这只是理想情况，我们一般是通过线程池来执行，并不会真的启动100个线程。</p>
<h3 id="多个人同时种树。种每一棵树的时候，不依赖的步骤可以分不同的人并行干"><a href="#多个人同时种树。种每一棵树的时候，不依赖的步骤可以分不同的人并行干" class="headerlink" title="多个人同时种树。种每一棵树的时候，不依赖的步骤可以分不同的人并行干"></a>多个人同时种树。种每一棵树的时候，不依赖的步骤可以分不同的人并行干</h3><p>这种方式可以进一步缩短种树的时长，因为第一步挖坑和第二步拿树苗可以两个人并行去做，所以每棵树只需要35 分钟。如下图：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/5hw1e.jpg" alt=""></p>
<p>如果程序还是 100 个主线程并发运行 plantTree 方法，那么只需要 35 分钟种完 100 颗树。<br>这里需要注意每个线程中，由于还要并发两个线程去做 1，2 两个步骤。实际运行中会又 100 x 3 = 300 个线程参与植树。但是负责 1，2 步骤的线程只会短暂参与，然后就闲置了。</p>
<p>这种方法和第二种方式也存在大量创建线程的问题。所以也只是理想情况。</p>
<h3 id="假如只有-4-个人植树，每个人只负责自己的步骤"><a href="#假如只有-4-个人植树，每个人只负责自己的步骤" class="headerlink" title="假如只有 4 个人植树，每个人只负责自己的步骤"></a>假如只有 4 个人植树，每个人只负责自己的步骤</h3><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/z9ce1.jpg" alt=""></p>
<p>可以看到一开始小王挖完第一个坑后，小李已经取回两个树苗，但此时小张才能开始种第一个树苗。此后小张就可以一个接一个的去种树苗了，并且在他种下一棵树苗的时候，小赵可以并行浇水。按照这个流程走下来，种完 100 颗树苗需要 10+20x100+5=2015 分钟。比单线程的4000分钟好了很多，但是远远比不上 100 个线程并发种树的速度。不过不要忘记 100 个线程并发只是理想情况，而本方法只用了 4 个线程。</p>
<p>我们再对分工做下调整。每个人不只干自己的工作，一旦自己的工作做完了就看有没有其他工作可以做。比如小王挖坑完后，发现可以种树苗，那么他就去种树苗。小李拿树苗完成后也可以去挖坑或者种树苗。这样整体的效率就会更高了。如果基于这种思想，那么我们实际上把任务分成了 4 类，每类 100 件，一共 400 件任务。400 件任务全部完成，意味着整个任务就完成了。那么任务的参与者只需要知道任务的依赖，然后不断领取可以执行的任务去执行。这样的效率将会是最高的。</p>
<p>前文说到我们不可能通过100个线程并发来执行任务，所以一般情况下我们都会使用线程池，这和上面的设计思想不谋而合。使用线程池后，由于第四种方式把步骤拆的更细，提高了并发的可能性。因此速度会比第二种方式更快。那么和第三种比起来，哪种更快呢？如果线程数量可以无穷大，这两个方法能达到的最短时间是一样的，都是 35 分钟。不过在线程有限的情况下，第四种方式对线程的使用率会更高，因为每个步骤都可以并行执行（参与种树的人完成自己的工作后，都可以去帮助其他人），线程的调度更为灵活，所以线程池中的线程很难闲下来，一直保持在运转之中。是的，谁都不能偷懒。而第三种由于只能并发在 plantTree 方法及挖坑和拿树苗，所以不如第四种方式灵活</p>
<p>上文讲了这么多，主要是要说明 CompletableFuture 出现的原因。他用来把复杂任务拆解为一个个衔接的异步执行步骤，从而提升整体的效率。我们回一下小节题目：谁都不能偷懒。没错，这就是 CompletableFuture 要达到的效果，通过对计算单元的抽象，让线程能够高效的并发参与每一个步骤。同步的代码通过 CompletableFuture 可以完全改造为异步代码。下面我们就来看看如何使用 CompletableFuture。</p>
<h2 id="CompletableFuture-使用"><a href="#CompletableFuture-使用" class="headerlink" title="CompletableFuture 使用"></a>CompletableFuture 使用</h2><p>CompletableFuture 实现了 Future 接口并且实现了 CompletionStage 接口。Future 接口我们已经很熟悉了，而CompletionStage 接口定了异步计算步骤之间的规范，这样确保一步一步能够衔接上。CompletionStage 定义了38 个 public 的方法用于异步计算步骤间的衔接。接下来我们会挑选一些常用的，相对使用频率较高的方法，来看看如何使用。</p>
<h3 id="已知计算结果"><a href="#已知计算结果" class="headerlink" title="已知计算结果"></a>已知计算结果</h3><p>如果你已经知道 CompletableFuture 的计算结果，可以使用静态方法 completedFuture。传入计算结果，声明CompletableFuture 对象。在调用 get 方法时会立即返回传入的计算结果，不会被阻塞，如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.completedFuture(<span class="string">"Hello World"</span>);</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is Hello World</span></span><br></pre></td></tr></table></figure>

<p>是不是觉得这种用法没有什么意义？既然知道计算结果了，直接使用就好了，为什么还要通过 CompletableFuture 进行包装？这是因为异步计算单元需要通过 CompletableFuture 进行衔接，所以有的时候我们即使已经知道计算结果，也需要包装为 CompletableFuture，才能融入到异步计算的流程之中。</p>
<h3 id="封装有返回值的异步计算逻辑"><a href="#封装有返回值的异步计算逻辑" class="headerlink" title="封装有返回值的异步计算逻辑"></a>封装有返回值的异步计算逻辑</h3><p>这是我们最常用的方式。把需要异步计算的逻辑封装为一个计算单元，交由 CompletableFuture 去运行。如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>);</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is 挖坑完成</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用了 CompletableFuture 的 supplyAsync 方法，以 lambda 表达式的方式向其传递了一个 supplier 接口的实现。</p>
<p>可见 <code>completableFuture.get()</code> 拿到的计算结果就是你传入函数执行后 return 的值。那么如果你有需要异步计算的逻辑，那么就可以放到 supplyAsync 传入的函数体中。这段函数是如何被异步执行的呢？如果你跟入代码可以看到其实 supplyAsync 是通过 Executor，也就是线程池来运行这段函数的。completableFuture 默认使用的是ForkJoinPool，当然你也可以通过为 supplyAsync 指定其他 Excutor，通过第二个参数传入 supplyAsync 方法。</p>
<p>supplyAsync 使用场景非常多，举个简单的例子，主程序需要调用多个微服务的接口请求数据，那么就可以启动多个 CompletableFuture，调用 supplyAsync，函数体中是关于不同接口的调用逻辑。这样不同的接口请求就可以异步同时运行，最后再等全部接口返回时，执行后面的逻辑。</p>
<h3 id="封装无返回值的异步计算逻辑"><a href="#封装无返回值的异步计算逻辑" class="headerlink" title="封装无返回值的异步计算逻辑"></a>封装无返回值的异步计算逻辑</h3><p>supplyAsync 接收的函数是有返回值的。有些情况我们只是一段计算过程，并不需要返回值。这就像 Runnable 的run 方法，并没有返回值。这种情况我们可以使用 runAsync方法，如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">"挖坑完成"</span>));</span><br><span class="line">    completableFuture.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖坑完成</span></span><br></pre></td></tr></table></figure>

<p>runAsync 接收 runnable 接口的函数。所以并无返回值。栗子中的逻辑只是打印“挖坑完成”。</p>
<h3 id="进一步处理异步返回的结果，并返回新的计算结果"><a href="#进一步处理异步返回的结果，并返回新的计算结果" class="headerlink" title="进一步处理异步返回的结果，并返回新的计算结果"></a>进一步处理异步返回的结果，并返回新的计算结果</h3><p>当我们通过 supplyAsync 完成了异步计算，返回 CompletableFuture，此时可以继续对返回结果进行加工，如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>)</span><br><span class="line">            .thenApply(s -&gt; s + <span class="string">", 并且归还铁锹"</span>)</span><br><span class="line">            .thenApply(s -&gt; s + <span class="string">", 全部完成。"</span>);</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is 挖坑完成, 并且归还铁锹, 全部完成。</span></span><br></pre></td></tr></table></figure>

<p>在调用 supplyAsync 后，我们两次链式调用 thenApply 方法。s 是前一步 supplyAsync 返回的计算结结果，我们对结算结果进行了两次再加工。我们可以通过 thenApply 不断对计算结果进行加工处理。<br>如果想异步运行 thenApply 的逻辑，可以使用 thenApplyAsync。使用方法相同，只不过会通过线程池异步运行。</p>
<h3 id="进一步处理异步返回的结果，无返回"><a href="#进一步处理异步返回的结果，无返回" class="headerlink" title="进一步处理异步返回的结果，无返回"></a>进一步处理异步返回的结果，无返回</h3><p>这种场景你可以使用thenApply。这个方法可以让你处理上一步的返回结果，但无返回值。参照如下代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>)</span><br><span class="line">            .thenAccept(s -&gt; System.out.println(s + <span class="string">", 并且归还铁锹"</span>));</span><br><span class="line">    completableFuture.get();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里可以看到 thenAccept 接收的函数没有返回值，只有业务逻辑。处理后返回 CompletableFuture 类型对象。</p>
<h3 id="既不需要返回值，也不需要上一步计算结果，只想在执行结束后再执行一段代码"><a href="#既不需要返回值，也不需要上一步计算结果，只想在执行结束后再执行一段代码" class="headerlink" title="既不需要返回值，也不需要上一步计算结果，只想在执行结束后再执行一段代码"></a>既不需要返回值，也不需要上一步计算结果，只想在执行结束后再执行一段代码</h3><p>此时你可以使用 thenRun 方法，他接收 Runnable 的函数，没有输入也没有输出，仅仅是在异步计算结束后回调一段逻辑，比如记录 log 等。参照下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>)</span><br><span class="line">            .thenAccept(s -&gt; System.out.println(s + <span class="string">", 并且归还铁锹"</span>))</span><br><span class="line">            .thenRun(() -&gt; System.out.println(<span class="string">"挖坑工作已经全部完成"</span>));</span><br><span class="line">    completableFuture.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖坑完成, 并且归还铁锹</span></span><br><span class="line"><span class="comment">// 挖坑工作已经全部完成</span></span><br></pre></td></tr></table></figure>

<p>可以看到在 thenAccept 之后继续调用了 thenRun，仅仅是打印了日志而已</p>
<h3 id="组合-Future-处理逻辑"><a href="#组合-Future-处理逻辑" class="headerlink" title="组合 Future 处理逻辑"></a>组合 Future 处理逻辑</h3><p>我们可以把两个 CompletableFuture 组合起来使用，如下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>)</span><br><span class="line">            .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">", 并且归还铁锹"</span>));</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is 挖坑完成, 并且归还铁锹</span></span><br></pre></td></tr></table></figure>

<p>thenApply 和 thenCompose 的关系就像 stream中的 map 和 flatmap。从上面的例子来看，thenApply 和thenCompose 都可以实现同样的功能。但是如果你使用一个第三方的库，有一个API返回的是CompletableFuture 类型，那么你就只能使用 thenCompose方法。</p>
<h3 id="组合Futurue结果"><a href="#组合Futurue结果" class="headerlink" title="组合Futurue结果"></a>组合Futurue结果</h3><p>如果你有两个异步操作互相没有依赖，但是第三步操作依赖前两部计算的结果，那么你可以使用 thenCombine 方法来实现，如下面代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; <span class="string">"挖坑完成"</span>)</span><br><span class="line">            .thenCombine(CompletableFuture.supplyAsync(() -&gt; <span class="string">", 拿树苗完成"</span>), (x, y) -&gt; x + y + <span class="string">"植树完成"</span>);</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is 挖坑完成, 拿树苗完成植树完成</span></span><br></pre></td></tr></table></figure>

<p>挖坑和拿树苗可以同时进行，但是第三步植树则祖尧前两步完成后才能进行。</p>
<p>可以看到符合我们的预期。使用场景之前也提到过。我们调用多个微服务的接口时，可以使用这种方式进行组合。处理接口调用间的依赖关系。<br>当你需要两个 Future 的结果，但是不需要再加工后向下游传递计算结果时，可以使用 thenAcceptBoth，用法一样，只不过接收的函数没有返回值。</p>
<h3 id="并行处理多个-Future"><a href="#并行处理多个-Future" class="headerlink" title="并行处理多个 Future"></a>并行处理多个 Future</h3><p>假如我们对微服务接口的调用不止两个，并且还有一些其它可以异步执行的逻辑。主流程需要等待这些所有的异步操作都返回时，才能继续往下执行。此时我们可以使用 CompletableFuture.allOf 方法。它接收 n 个 CompletableFuture，返回一个 CompletableFuture。对其调用 get 方法后，只有所有的 CompletableFuture 全完成时才会继续后面的逻辑。我们看下面示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;Void&gt; future1 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"挖坑完成"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future2 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">5</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"取树苗完成"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture&lt;Void&gt; future3 = CompletableFuture.runAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"取肥料完成"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    CompletableFuture.allOf(future1, future2, future3).get();</span><br><span class="line">    System.out.println(<span class="string">"植树准备工作完成！"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 挖坑完成</span></span><br><span class="line"><span class="comment">// 取肥料完成</span></span><br><span class="line"><span class="comment">// 取树苗完成</span></span><br><span class="line"><span class="comment">// 植树准备工作完成！</span></span><br></pre></td></tr></table></figure>

<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在异步计算链中的异常处理可以采用 handle 方法，它接收两个参数，第一个参数是计算及过，第二个参数是异步计算链中抛出的异常。使用方法如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CompletableFuture&lt;String&gt; completableFuture = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Computation error"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"挖坑完成"</span>;</span><br><span class="line">    &#125;).handle((result, throwable) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"挖坑异常"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"result is "</span> + completableFuture.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result is 挖坑异常</span></span><br></pre></td></tr></table></figure>

<p>代码中会抛出一个 RuntimeException，抛出这个异常时 result 为 null，而 throwable 不为null。根据这些信息你可以在 handle 中进行处理，如果抛出的异常种类很多，你可以判断 throwable 的类型，来选择不同的处理逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>CompletableFuture它的方法远不止这些，其它的方法大家可以参照文档进行学习。在实际开发中，我推荐使用 CompletableFuture 进行异步计算，它更为灵活，并且可以采用 lambda 表达式进行函数式编程，代码更为简洁，可读性也更高。</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
  </entry>
  <entry>
    <title>业务代表模式</title>
    <url>/posts/39308/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>业务代表模式（Business Delegate Pattern）主要是为了实现表现层和业务层的解耦，使用业务代表模式可以支持各种场景，在这些场景中，客户端可以根据需要自行选择不同的业务代表，每个业务代表负责的服务各有不同或者说服务类型不同，业务查询服务一般是负责公共的业务查询，提供给业务代表使用。</p>
<a id="more"></a>


<p>业务代表模式是一种经典的 J2EE 设计模式，是业务解耦的一种手段。举个例子：生活中比较常见的去银行办理业务时，每种业务都会有不同的业务顾问（业务代表），客户办理业务时可以选择具体的业务顾问，每个业务顾问又负责不同的业务范畴，业务顾问进行业务办理时需要先进行业务询问或查询，也就说根据客户业务范畴选择可以进行服务的服务窗口，完事后就交由服务窗口负责客户具体服务了。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>业务代表模式包含如下角色：</p>
<ul>
<li>客户端（Client）：表现层，可以是 JSP、Servlet 或者 Java 代码。上面的例子中指的就是去银行办理业务的客户；</li>
<li>业务代表（Business Delegate）：和客户端打交道的实体类，提供了对业务服务方法的访问。对应的是业务顾问；</li>
<li>查询服务（Look Up Service）：用来查询具体业务范畴或对象的具体业务实现，对应上文的就是业务顾问要根据查询服务查询对客户进行服务的具体窗口（服务实现）；</li>
<li>业务服务（Business Service）：具体的业务服务实现类，对应的就是具体的服务窗口。</li>
</ul>
<p>业务代表模式的通用 UML 类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/hq59f.jpg" alt=""></p>
<h2 id="业务代表模式代码实现"><a href="#业务代表模式代码实现" class="headerlink" title="业务代表模式代码实现"></a>业务代表模式代码实现</h2><p>业务代表模式的通用代码如下：</p>
<h3 id="业务服务"><a href="#业务服务" class="headerlink" title="业务服务"></a>业务服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务服务抽象接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提供的服务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务服务的具体实现类"><a href="#业务服务的具体实现类" class="headerlink" title="业务服务的具体实现类"></a>业务服务的具体实现类</h3><p>服务实现类 1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务服务具体实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessServiceImpl1</span> <span class="keyword">implements</span> <span class="title">BusinessService</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Processing task by invoking BusinessServiceImpl1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务实现类 2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务服务的具体实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessServiceImpl2</span> <span class="keyword">implements</span> <span class="title">BusinessService</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Processing task by invoking BusinessServiceImpl2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="业务查询服务"><a href="#业务查询服务" class="headerlink" title="业务查询服务"></a>业务查询服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务查询服务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessLookUp</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据具体的业务类型，查询具体的业务类型的办理人（服务）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BusinessService <span class="title">getBusinessService</span><span class="params">(String serviceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"type1"</span>.equalsIgnoreCase(serviceType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BusinessServiceImpl1();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BusinessServiceImpl2();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="业务代表"><a href="#业务代表" class="headerlink" title="业务代表"></a>业务代表</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务代表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务查询</span></span><br><span class="line">    <span class="keyword">private</span> BusinessLookUp lookUpService = <span class="keyword">new</span> BusinessLookUp();</span><br><span class="line">    <span class="comment">// 业务服务</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line">    <span class="comment">// 服务类型</span></span><br><span class="line">    <span class="keyword">private</span> String serviceType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceType</span><span class="params">(String serviceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceType = serviceType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务代表的服务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找具体的服务窗口</span></span><br><span class="line">        businessService = lookUpService.getBusinessService(serviceType);</span><br><span class="line">        <span class="comment">// 委托窗口进行业务处理</span></span><br><span class="line">        businessService.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端-表现层</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务代表</span></span><br><span class="line">    <span class="keyword">private</span> BusinessDelegate businessDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Client</span><span class="params">(BusinessDelegate businessDelegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.businessDelegate = businessDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 客户端的业务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托业务代表处理</span></span><br><span class="line">        businessDelegate.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="测试验证"><a href="#测试验证" class="headerlink" title="测试验证"></a>测试验证</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务代表模式测试类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessDelagateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 生成一个服务范畴类型为type1的业务代表</span></span><br><span class="line">        BusinessDelegate businessDelegate = <span class="keyword">new</span> BusinessDelegate();</span><br><span class="line">        businessDelegate.setServiceType(<span class="string">"type1"</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 指定客户的业务代表为businessDelegate</span></span><br><span class="line">        Client client = <span class="keyword">new</span> Client(businessDelegate);</span><br><span class="line">        <span class="comment">// 客户办理业务</span></span><br><span class="line">        client.doTask();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 生成一个服务范畴类型为type2的业务代表</span></span><br><span class="line">        businessDelegate.setServiceType(<span class="string">"type2"</span>);</span><br><span class="line">        client.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Processing task by invoking BusinessServiceImpl1</span><br><span class="line"></span><br><span class="line">Processing task by invoking BusinessServiceImpl2</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>业务代表模式的优点：</p>
<ul>
<li>表现层和业务层分离，利于应用解耦；</li>
<li>客户端可以根据需要自主选择业务代表，符合面向对象的特点。<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2>业务代表模式典型应用场景如下：</li>
<li>业务的表现层和业务层解耦：传统的 MVC 架构中，为了实现 JSP、Servlet 等与业务层解耦，可以提高系统的开发效率以及模块的复用性。<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2>下面我们以本节开始时讲解的银行业务办理场景进行 Demo 讲解，具体代码设计如下：</li>
</ul>
<h3 id="抽象业务服务"><a href="#抽象业务服务" class="headerlink" title="抽象业务服务"></a>抽象业务服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象业务服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要进行的业务-开户</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doCreateCount</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 要进行的业务-存钱</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSaveMoney</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="服务窗口-张"><a href="#服务窗口-张" class="headerlink" title="服务窗口 - 张"></a>服务窗口 - 张</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务窗口-张</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessConsultantZh</span> <span class="keyword">implements</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCreateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务窗口-张：开户成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSaveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务窗口-张：存钱成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="服务窗口-李"><a href="#服务窗口-李" class="headerlink" title="服务窗口 - 李"></a>服务窗口 - 李</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 服务窗口-李</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessConsultantLi</span> <span class="keyword">implements</span> <span class="title">BusinessService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doCreateCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务窗口-李：开户成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSaveMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务窗口-李：存钱成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务查询服务-1"><a href="#业务查询服务-1" class="headerlink" title="业务查询服务"></a>业务查询服务</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务查询服务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessLookUp</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据具体的业务类型，查询具体的业务类型的办理人（服务）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> serviceType</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BusinessService <span class="title">getBusinessService</span><span class="params">(String serviceType)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 开户业务暂由 BusinessConsultantZh 窗口办理</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"doCreateCount"</span>.equalsIgnoreCase(serviceType)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BusinessConsultantZh();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 存钱业务暂由 BusinessConsultantLi 窗口办理</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> BusinessConsultantLi();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务顾问"><a href="#业务顾问" class="headerlink" title="业务顾问"></a>业务顾问</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务顾问或者大堂业务专员</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessDelegate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 业务查询</span></span><br><span class="line">    <span class="keyword">private</span> BusinessLookUp lookUpService = <span class="keyword">new</span> BusinessLookUp();</span><br><span class="line">    <span class="comment">// 业务服务</span></span><br><span class="line">    <span class="keyword">private</span> BusinessService businessService;</span><br><span class="line">    <span class="comment">// 服务类型</span></span><br><span class="line">    <span class="keyword">private</span> String serviceType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setServiceType</span><span class="params">(String serviceType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serviceType = serviceType;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 业务顾问的服务方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 查找具体的服务窗口</span></span><br><span class="line">        businessService = lookUpService.getBusinessService(serviceType);</span><br><span class="line">        <span class="comment">// 委托窗口进行业务处理</span></span><br><span class="line">        <span class="keyword">if</span> (serviceType.equalsIgnoreCase(<span class="string">"doCreateCount"</span>)) &#123;</span><br><span class="line">            businessService.doCreateCount();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            businessService.doSaveMoney();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户"><a href="#客户" class="headerlink" title="客户"></a>客户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 普通客户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalCustomer</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 要提供服务的业务代表</span></span><br><span class="line">    <span class="keyword">private</span> BusinessDelegate businessDelegate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NormalCustomer</span><span class="params">(BusinessDelegate businessDelegate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.businessDelegate = businessDelegate;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 客户端的业务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托业务代表处理</span></span><br><span class="line">        businessDelegate.doTask();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成一个服务范畴类型为开户的业务代表</span></span><br><span class="line">BusinessDelegate businessDelegate = <span class="keyword">new</span> BusinessDelegate();</span><br><span class="line">businessDelegate.setServiceType(<span class="string">"doCreateCount"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定客户的业务代表为businessDelegate</span></span><br><span class="line">NormalCustomer client = <span class="keyword">new</span> NormalCustomer(businessDelegate);</span><br><span class="line"><span class="comment">// 客户办理业务</span></span><br><span class="line">client.doTask();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成一个服务范畴类型为存钱的业务代表</span></span><br><span class="line">businessDelegate.setServiceType(<span class="string">"doSaveMoney"</span>);</span><br><span class="line">client.doTask();</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">服务窗口 - 张：开户成功</span><br><span class="line"></span><br><span class="line">服务窗口 - 李：存钱成功</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>业务代表模式比较简单，在做 MVC 开发的时候就能体会到表现层和业务层分离的好处，这里要和建造者模式区分下，建造者模式强调的是构建与表现相分离，强调的是内部构建，而业务代表模式强调的是表现层。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>MVC模式</title>
    <url>/posts/12522/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>MVC 全称是 Model-View-Controller（模型 - 视图 - 控制器） ，是一种软件设计典范，用一种业务逻辑、数据、界面进行分离的开发模式。<br>MVC 模式是一种经典的设计模式，被广泛地应用在程序开发当中，例如，目前比较知名的经典框架：Spring MVC、ASP.NET MVC、Struts2 等，都是基于 MVC 模式实现的。</p>
<a id="more"></a>


<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>MVC 模式包含如下角色：</p>
<ul>
<li>Model（模型）：用于存储和操作数据（库）的类，可以是存储容器，也可以带有逻辑，用于返回结果给控制器；</li>
<li>View（视图）：展示给用户的界面，用于展示和操作；</li>
<li>Controller（控制器）：用于连接模型层和视图层的中间控制器。</li>
</ul>
<p>角色之间的执行流程图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/4516q.jpg" alt=""></p>
<h2 id="MVC-模式代码实现"><a href="#MVC-模式代码实现" class="headerlink" title="MVC 模式代码实现"></a>MVC 模式代码实现</h2><p>本文并不打算使用现成的 MVC 框架来做演示，比如 Spring MVC 框架等，因为本身框架太重，且已经是封装好的，不便于读者理解，所以本文会用代码的方式，手动实现 MVC 模式。</p>
<h3 id="模型层"><a href="#模型层" class="headerlink" title="模型层"></a>模型层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模型层（伪代码）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Model</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm Model."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="视图层"><a href="#视图层" class="headerlink" title="视图层"></a>视图层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视图层（伪代码）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I'm View."</span>);</span><br><span class="line">        Controller.doController();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端调用（伪代码）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开页面</span></span><br><span class="line">        View view = <span class="keyword">new</span> View();</span><br><span class="line">        <span class="comment">// 执行查询，并展现结果</span></span><br><span class="line">        view.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">I’m View.</span><br><span class="line"></span><br><span class="line">I’m Controller.</span><br><span class="line"></span><br><span class="line">I’m Model.</span><br></pre></td></tr></table></figure>

<p>以上模型层、视图层、客户端调用都是伪代码，模拟的是用户打开页面，再执行查询、展示的流程，程序的实际执行流程是：用户先调用视图层（页面），视图层再调用控制器，控制器再调用模型层，最终再把结果返回给用户的过程。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>MVC 模式的优点：</p>
<ul>
<li>分工明确：有利于团队开发分工协作和质量控制，降低开发成本；</li>
<li>耦合性低：模块间相互比较独立，比如，在业务流程和交互方式不变的情况下，可以任意调整前端页面的样式，而不影响其他模块；</li>
<li>重用性高：以模型层来说，可以提供给多个控制器来使用。<br>MVC 模式的缺点：</li>
<li>增加了系统实现的复杂性，对于简单的应用并不适用；</li>
<li>减低了系统的运行性能，因为程序的执行经过的层数过多，所以会带来一定的性能损耗。<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2>MVC 模式典型应用场景如下：</li>
<li>Web 开发领域：由于 Web 开发的特殊性，采用 MVC 进行结构划分，一方面会提升团队的协同开发效率，专人干专事，另一方面也有利于日后软件产品的维护和升级，同时能够提升软件模块的复用性；</li>
<li>移动互联开发：目前移动互联开发，比如：Android、iOS 开发也在采用 MVC 框架，对于这种展示层修改频率比较高的应用，采用 MVC 的方式，使得修改展示层更加的高效；</li>
<li>实用型工具类程序：与前两种开发不同，实用型工具类程序，更多修改的是展示层之外的代码，这种在不更改用户操作习惯的方式下，静默地调整和升级代码的方式，也比较适合用 MVC 设计模式。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>以图书馆中查询书籍简介为例，比如，我们在图书馆的电脑上，输入书名再点击查询，就会在数据库中查询书籍信息，并展示给用户，具体实现代码如下。</p>
<h3 id="模型层-1"><a href="#模型层-1" class="headerlink" title="模型层"></a>模型层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模型层</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MvcModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String desc;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> desc;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDesc</span><span class="params">(String desc)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.desc = desc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="前端页面（视图层）"><a href="#前端页面（视图层）" class="headerlink" title="前端页面（视图层）"></a>前端页面（视图层）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视图层</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MvcView</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MvcView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"页面展示"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 接收用户请求，调用控制器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">find</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用控制器，输出结果</span></span><br><span class="line">        System.out.println(<span class="string">"输出结果："</span> + <span class="keyword">new</span> MvcController().getDesc(name));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制器（层）</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MvcController</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 简介内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 根据名称获取简介</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> name 名称</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDesc</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 最终返回的结果</span></span><br><span class="line">        String result = <span class="string">"暂无"</span>;</span><br><span class="line">        <span class="comment">// 以模型层为基础，通过数据层，查询到相关的数据</span></span><br><span class="line">        MvcModel mvcModel = MvcDB.findByName(name);</span><br><span class="line">        <span class="keyword">if</span> (mvcModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            result = mvcModel.getDesc();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="数据层（提供数据）"><a href="#数据层（提供数据）" class="headerlink" title="数据层（提供数据）"></a>数据层（提供数据）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">**</span><br><span class="line"> * 数据层</span><br><span class="line"> **/</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MvcDB</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Description</span> 根据书名返回数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@Param</span> name 书名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 模型对象数据</span></span><br><span class="line"><span class="comment">     **/</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MvcModel <span class="title">findByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        MvcModel model = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Java"</span>:</span><br><span class="line">                model = <span class="keyword">new</span> MvcModel();</span><br><span class="line">                model.setName(<span class="string">"Java面试全解析"</span>);</span><br><span class="line">                model.setDesc(<span class="string">"这是一本包含了 505 道面试题的 Java 书籍。"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"MySQL"</span>:</span><br><span class="line">                model = <span class="keyword">new</span> MvcModel();</span><br><span class="line">                model.setName(<span class="string">"MySQL面试金典"</span>);</span><br><span class="line">                model.setDesc(<span class="string">"这是一本包含了 208 道面试题的 MySQL 书籍。"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用-1"><a href="#客户端调用-1" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 打开页面</span></span><br><span class="line">        MvcView mvcView = <span class="keyword">new</span> MvcView();</span><br><span class="line">        <span class="comment">// 输入书名：Java</span></span><br><span class="line">        mvcView.name = <span class="string">"Java"</span>;</span><br><span class="line">        <span class="comment">// 点击查询，执行相关流程并展示结果</span></span><br><span class="line">        mvcView.find();</span><br><span class="line">        <span class="comment">// 输入书名：MySQL</span></span><br><span class="line">        mvcView.name = <span class="string">"MySQL"</span>;</span><br><span class="line">        <span class="comment">// 点击查询，执行相关流程并展示结果</span></span><br><span class="line">        mvcView.find();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">页面展示</span><br><span class="line"></span><br><span class="line">输出结果：这是一本包含了 <span class="number">505</span> 道面试题的 Java 书籍。</span><br><span class="line"></span><br><span class="line">输出结果：这是一本包含了 <span class="number">208</span> 道面试题的 MySQL 书籍。</span><br></pre></td></tr></table></figure>

<p>细心的读者可能会发现，这个实例中又多了一个数据层，其实它并没有特殊的含义，只是为整个实例提供数据来源而已。在这个实例中，模型层相对来说功能比较单一，只是一个数据载体（数据容器）而已，但广义上来说 MVC 模式中的模型层，也可以是业务模型层，并带有逻辑判断代码，就相当于这个例子中的 MvcModel 类 + MvcDB 类的合体。但设计模式只是一种思想，并没有严格的实现标准，这同时也是学习设计模式的精髓，读者可以根据实际情况，灵活变通，只要符合程序设计的七大经典原则即可。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>MVC 模式 Model-View-Controller（模型 - 视图 - 控制器），可以有效地将程序分层，提高了开发效率，让专业的人干专业的事，同时降低了代码间的耦合，提升了代码的复用性，但也因此减低了程序的执行性能，拉长了程序调试的流程，增加了开发的难度。所以对于中小型系统来说，要谨慎地使用 MVC 模式，不要死记硬套，要学会变通地使用各种设计模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/posts/65163/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>这节中我们将介绍一种新的结构型模式——享元模式 （Flyweight Pattern），Flyweight 模式是以共享的模式来支持大量细粒度对象的复用。听起来可能有点绕，Java 中的 String 就是享元模式的一个应用：</p>
<a id="more"></a>


<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String a = <span class="string">"abc"</span>;</span><br><span class="line">String b = <span class="string">"abc"</span>;</span><br><span class="line">System.out.println(a == b); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上述例子中，分别创建两个字符串对象的时候，a、b 其实都指向了常量池中的某个字符串“abc”，这种对象创建的模式，就避免了大量对象创建时非必要的资源消耗，享元模式的“享”就有一物被众人所共享的意思，所以享元模式也是池技术的重要实现方式，其定义如下：<strong>使用共享对象有效地支持大量的细粒度的对象。</strong></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面我们用一个最简单的考试报名的例子进行说明，假设我们有 2 个科目，有 3 位考生分别进行报考，我们一般会定义考试实体 ExamInfo，如果不使用模式的话，可以想象，每次有考生参与一场科目考试的话，我们就会实例化一个 ExamInfo，总共我们要实例化 6 个这样的实体，倘若使用享元模式，我们就只需要实例化 2 个这样的实体，然后通过内部状态的 set 方法进行不同对象的赋值操作，节省了不少的内存，很神奇吧？</p>
<p>先来看看我们的 ExamInfo 如何？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamInfo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部状态，用于在各个对象之间共享，不随环境改变而改变，存储在享元对象内部，往往作为对象的动态附加信息存在</span></span><br><span class="line">    <span class="keyword">private</span> String user; <span class="comment">// 考生</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部状态，随环境改变而改变，属于不可共享的状态，是对象得以依赖的一个标记</span></span><br><span class="line">    <span class="keyword">private</span> String subject; <span class="comment">// 考试科目</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExamInfo</span><span class="params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subject = subject;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(String user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.user = user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"ExamInfo&#123;"</span> +</span><br><span class="line">                <span class="string">"user='"</span> + user + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", subject='"</span> + subject + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在考试信息里面，我们将考试科目作为考试信息的唯一标识，以此来实现对象复用。</p>
<p>然后是我们的享元工厂，也就是我们的池，该池中留有细粒度对象的引用实例，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExamInfoFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对象池，用来支持细粒度对象的复用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, ExamInfo&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExamInfo <span class="title">getExamInfo</span><span class="params">(String subject)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置返回的对象</span></span><br><span class="line">        ExamInfo examInfo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(subject)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"建立对象，并放到池中..."</span> + subject);</span><br><span class="line">            examInfo = <span class="keyword">new</span> ExamInfo(subject);</span><br><span class="line">            pool.put(subject, examInfo);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            examInfo = pool.get(subject);</span><br><span class="line">            System.out.println(<span class="string">"直接从池中获取..."</span> + subject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> examInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们使用一个 map 对象来实现池的功能，通过科目我们可以获取池中的某个考试信息实例，如果存在则直接从池中获取返回，如果不存在，我们会手动 new 一个考试信息，然后再将其放入池中，之后再返回。</p>
<p>接下来是我们的测试类，也就是 main 函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 假设有2个科目，初始化一遍池子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">            String subject = <span class="string">"科目"</span> + i;</span><br><span class="line">            ExamInfoFactory.getExamInfo(subject);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 假设3个考生考试</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>; j++) &#123;</span><br><span class="line">                ExamInfo examInfo = ExamInfoFactory.getExamInfo(<span class="string">"科目"</span> + j);</span><br><span class="line">                examInfo.setUser(<span class="string">"考生"</span> + i);</span><br><span class="line">                System.out.println(examInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">建立对象，并放到池中...科目0</span><br><span class="line">建立对象，并放到池中...科目1</span><br><span class="line">直接从池中获取...科目0</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生0&#39;, subject&#x3D;&#39;科目0&#39;&#125;</span><br><span class="line">直接从池中获取...科目1</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生0&#39;, subject&#x3D;&#39;科目1&#39;&#125;</span><br><span class="line">直接从池中获取...科目0</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生1&#39;, subject&#x3D;&#39;科目0&#39;&#125;</span><br><span class="line">直接从池中获取...科目1</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生1&#39;, subject&#x3D;&#39;科目1&#39;&#125;</span><br><span class="line">直接从池中获取...科目0</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生2&#39;, subject&#x3D;&#39;科目0&#39;&#125;</span><br><span class="line">直接从池中获取...科目1</span><br><span class="line">ExamInfo&#123;user&#x3D;&#39;考生2&#39;, subject&#x3D;&#39;科目1&#39;&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的信息中我们可以发现，实际上初始化 ExamInfo 实体的操作我们只进行了 2 次，也就说内存中保存的对象引用只有 2 份，相比预不使用享元模式需要进行 6 次实例化的方案是不是一下省了部分内存，设想一下，倘若有 100000 个考生那又节省了多少内存？</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/zt2ry.png" alt=""></p>
<p>享元模式包含的角色列举如下：</p>
<ul>
<li>抽象享元角色（Flyweight）：一般是一个具体的抽象类，同时定义了对象的外部状态和内部状态的接口或实现；</li>
<li>具体享元角色（ConcreteFlyweight）：具体的一个产品类，实现了抽象享元角色中定义的接口，该角色需要注意的是内部状态的处理应该与环境无关；</li>
<li>享元工厂（FlyweightFactory）：该角色指责一般比较清晰，就是一个池工厂，提供池对象和获取池中对象的方法</li>
</ul>
<h2 id="享元模式代码实现"><a href="#享元模式代码实现" class="headerlink" title="享元模式代码实现"></a>享元模式代码实现</h2><p>享元模式的几个角色上面已经介绍了，该角色对应的通用代码如下，首先是抽象享元角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部状态</span></span><br><span class="line">    <span class="keyword">private</span> String intrinsic;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 外部状态</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> String extrinsic;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.extrinsic = extrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义的业务操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部状态的getter、setter</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIntrinsic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIntrinsic</span><span class="params">(String intrinsic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsic = intrinsic;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是具体的享元角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteFlyweight</span> <span class="keyword">extends</span> <span class="title">Flyweight</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受外部状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteFlyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(extrinsic);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据外部状态进行一些逻辑处理</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是享元工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 池容器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, Flyweight&gt; pool = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取池中对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String extrinsic)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 需要返回的对象</span></span><br><span class="line">        Flyweight flyweight = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (!pool.containsKey(extrinsic)) &#123;</span><br><span class="line">            <span class="comment">// 根据外部状态创建享元对象</span></span><br><span class="line">            flyweight = <span class="keyword">new</span> ConcreteFlyweight(extrinsic);</span><br><span class="line">            <span class="comment">// 再放入池中</span></span><br><span class="line">            pool.put(extrinsic, flyweight);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 池中有对象，则直接返回</span></span><br><span class="line">            flyweight = pool.get(extrinsic);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flyweight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节中，我们讲了下什么是享元模式，以及为什么要使用享元模式，下面我们归纳下本节的知识点，包括享元模式的应用场景，总结下如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/2n3zj.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/posts/55487/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>中介者？其实生活中大家再熟悉不过了这个词，我们熟悉的黄牛、房产中介等就是充当中介的角色，将我们的买票、购房等的需求自身消化再代为办理。又比如说中间件，马老师很忙，不能来一个人有事就直接找马老师对吧，所以要找一个中介，客户来了直接找中间人，中间人再和马老师沟通，这样马老师和客户那边就是一个不可见的关系，由中介者角色进行中间协调，马老师也能抽出更多时间去忙别的事了，解放了相当的生产力。</p>
<a id="more"></a>


<p>中介者模式（Mediator）的定义：<strong>定义一个中介对象来封装对象之间的交互，使原有对象之间耦合松散，并且可以独立地改变它们之间的交互。</strong></p>
<p>还记得迪米特法则吗？迪米特法则的初衷在于降低类之间的耦合，中介者模式就是迪米特法则的典型应用。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>中介者模式的组成角色如下：</p>
<ul>
<li>中介者（又称仲裁者，Mediator）：负责定义与 Colleague 角色进行通信和做出角色的接口；</li>
<li>具体中介者、仲裁者（ConcreteMediator）：负责实现 Mediator 角色定义的接口，负责具体的业务执行；</li>
<li>同事角色（Colleague）：负责定义与 Mediator 角色进行通信的接口；</li>
<li>具体同事角色（ConcreteColleague）：实现 Colleague 角色定义的接口，一般会有多个实现类。</li>
</ul>
<p>类图的话比较简单，就没有细分中介者角色了，抽象成了如下三种角色：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/kv9ef.png" alt=""></p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>每个同事角色都知道中介者角色的存在，比如房屋买卖中，卖家和买家都知道房产中介的存在一样，也就是同事角色间进行通信时都必须依赖于中介者角色，当然，如果同事角色只是简单对自身状态进行变更，不会影响其他同事角色的状态时就不需要中介者角色，这种同事角色自发改变自身行为的行为称为自发行为，第二种行为就是依赖其他对象进行操作的行为。</p>
<p>中介者模式的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象同事类</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 每个同事类角色都必须知道中介者角色的存在</span></span><br><span class="line">    <span class="keyword">protected</span> Mediator mediator;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colleague1</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague1</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自发行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelfMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"11111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托给中介者处理的任务</span></span><br><span class="line">        <span class="keyword">this</span>.mediator.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体同事类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Colleague2</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleague2</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自发行为</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSelfMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"22222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 依赖方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">depMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 委托给中介者处理的任务</span></span><br><span class="line">        <span class="keyword">this</span>.mediator.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象中介者角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中介者要协调的同事角色</span></span><br><span class="line">    <span class="keyword">protected</span> Colleague1 c1;</span><br><span class="line">    <span class="keyword">protected</span> Colleague2 c2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 中介者模式的业务逻辑抽象</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Colleague1 <span class="title">getC1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC1</span><span class="params">(Colleague1 c1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c1 = c1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Colleague2 <span class="title">getC2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setC2</span><span class="params">(Colleague2 c2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c2 = c2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体中介者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteMediator</span> <span class="keyword">extends</span> <span class="title">Mediator</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c1.doSelfMethod1();</span><br><span class="line">        <span class="keyword">this</span>.c2.doSelfMethod2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明中介者</span></span><br><span class="line">Mediator mediator = <span class="keyword">new</span> ConcreteMediator();</span><br><span class="line"><span class="comment">// 定义两个同事角色</span></span><br><span class="line">Colleague1 c1 = <span class="keyword">new</span> Colleague1(mediator);</span><br><span class="line">Colleague2 c2 = <span class="keyword">new</span> Colleague2(mediator);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给中介者设置同事角色</span></span><br><span class="line">mediator.setC1(c1);</span><br><span class="line">mediator.setC2(c2);</span><br><span class="line"></span><br><span class="line">c1.depMethod1();</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>中介者模式的优点：</p>
<ul>
<li>弱化对象间的依赖关系，即松耦合，降低同时类的耦合度，符合迪米特法则</li>
<li>将对象间的调用关系进行封装，使得对象更容易复用<br>中介者模式的缺点：</li>
<li>如果对象增多，就要去修改抽象中介者和具体的中介者角色</li>
<li>中介者角色承担了太多了业务逻辑功能，流程复杂时就会显得比较臃肿，不好管理</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>中介者模式的应用场景一般比较明确，当系统有一系列对象需要相互调用，为弱化对象间的依赖关系，使得这些对象之间松耦合。</p>
<p>生活中，最普遍熟悉的例子就是房屋中介或者 qq 群这种聊天案例，这里我们以房屋中介为例，中介公司就好比我们的中介者角色，而业主和买家就构成了两个不同的同事角色，买卖双方之间的这种交互就可以交给中介者去对接协调：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的中介公司角色，中介者角色中一般都要包含各个同事角色，因为它要负责这些对象之间的交互</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MeditorCompany</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中介公司名称</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> ColleagueSeller seller; <span class="comment">// 卖家-同事角色</span></span><br><span class="line">    <span class="keyword">protected</span> ColleagueBuyer buyer; <span class="comment">// 买家-同事角色</span></span><br><span class="line">    <span class="comment">// 发布一个需求，由中介公司去代为发布，入参为需求内容、发布人</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message, Colleaguer colleaguer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeditorCompany</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ColleagueSeller <span class="title">getSeller</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> seller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSeller</span><span class="params">(ColleagueSeller seller)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.seller = seller;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ColleagueBuyer <span class="title">getBuyer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> buyer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBuyer</span><span class="params">(ColleagueBuyer buyer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyer = buyer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体的中介公司-贝克找房</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeditorCompanyBeiKe</span> <span class="keyword">extends</span> <span class="title">MeditorCompany</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeditorCompanyBeiKe</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">publish</span><span class="params">(String message, Colleaguer colleaguer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (colleaguer <span class="keyword">instanceof</span> ColleagueSeller) &#123; <span class="comment">// 如果是卖家发布，则买家进行接收</span></span><br><span class="line">            buyer.accept(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(colleaguer <span class="keyword">instanceof</span> ColleagueBuyer) &#123; <span class="comment">// 如果是买家发布，则卖家进行接收</span></span><br><span class="line">            seller.accept(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象的同事角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleaguer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> MeditorCompany meditorCompany; <span class="comment">// 对同事类而言，中介者必须是可见的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Colleaguer</span><span class="params">(MeditorCompany meditorCompany)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.meditorCompany = meditorCompany;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卖家-同事角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueSeller</span> <span class="keyword">extends</span> <span class="title">Colleaguer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueSeller</span><span class="params">(MeditorCompany meditorCompany)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(meditorCompany);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 同事类发布一个需求，不过是通过中介公司去发布，发布人是自己</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        meditorCompany.publish(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"卖家接收到的消息是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 买家-同事角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ColleagueBuyer</span> <span class="keyword">extends</span> <span class="title">Colleaguer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ColleagueBuyer</span><span class="params">(MeditorCompany meditorCompany)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(meditorCompany);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        meditorCompany.publish(message, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"买家接收到的消息是："</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个中介者</span></span><br><span class="line">MeditorCompany meditorCompany = <span class="keyword">new</span> MeditorCompanyBeiKe(<span class="string">"贝克找房"</span>);</span><br><span class="line"><span class="comment">// 定义一个卖家一个买家同事类</span></span><br><span class="line">ColleagueSeller colleagueSeller = <span class="keyword">new</span> ColleagueSeller(meditorCompany);</span><br><span class="line">ColleagueBuyer colleagueBuyer = <span class="keyword">new</span> ColleagueBuyer(meditorCompany);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给中介公司注册买家、卖家</span></span><br><span class="line">meditorCompany.setBuyer(colleagueBuyer);</span><br><span class="line">meditorCompany.setSeller(colleagueSeller);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 操作</span></span><br><span class="line">colleagueSeller.send(<span class="string">"卖家发布需求..."</span>);</span><br><span class="line">colleagueBuyer.send(<span class="string">"买家发布需求..."</span>);</span><br></pre></td></tr></table></figure>

<p>结果输出：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">买家接收到的消息是：卖家发布需求...</span><br><span class="line">卖家接收到的消息是：买家发布需求...</span><br></pre></td></tr></table></figure>

<p>中介者模式的引入，其实就是为了解决系统对象相互依赖调用的情况，可以想象一下，使用中介者模式后，原本的错综复杂的网络结构就会变成以中介者为中心的网状结构，这是中介者模式要解决的问题。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节我们介绍了中介者模式，要注意的就是，中介者角色承担了太多的业务功能，并且中介者角色依赖具体的同事角色，一旦同事角色有变更或者添加，中介者角色就需要相应地发生变化，导致二次开发维护变得困难，所以使用的过程中还是要多加注意。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/posts/48005/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>代理模式的定义其实比较简单：代理模式给某对象提供一个代理对象，由代理对象来控制对原对象的引用。生活中比较常见的代理模式的应用比如：火车票代购、代办保险、UU 跑腿、武侠片中的替身、nginx 反向代理等等这种类似于中介的模式统统可以归于代理模式。“本人”和“代理人”都是对象，“代理人”可以代替“本人”去完成一些工作，甚至是出色完成（超期完成）某些工作，这里的“出色完成”就可以理解为对原工作的一种增强实现，这点有点类似于装饰器模式。感兴趣的读者不妨翻到前面装饰器模式一节中了解下装饰器模式。</p>
<a id="more"></a>


<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/lf03q.png" alt=""><br>图1 - 不使用代理模式</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/zeejg.png" alt=""><br>图2 - 使用代理模式</p>
<p>那么，为什么会存在代理模式呢？我们知道，存在即合理，很多情况下，客户类不想或不能直接引用委托对象，这时候使用代理类充当中介作用，这种情况下代理类和委托类实现相同的接口；另外，有时候我们会想增强委托类，这个时候使用代理类来完成也是再合适不过了，也是符合开闭原则（对拓展开放，对修改关闭）的。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>代理模式一般分为两种：静态代理和动态代理（jdk动态代理和cglib动态代理），这里我们先来看下静态代理，静态代理的通用类图如下<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/42yyf.png" alt=""></p>
<p>代理模式也叫做委托模式，代理类一般包含被委托类的引用，下面我们来说下上面三个角色的定义：</p>
<ul>
<li>抽象主题角色（Subject）：抽象主题角色往往是一个抽象类或接口，用来定义被委托类也就是真实的业务处理类和代理类的一些通用操作；</li>
<li>具体的主题角色（RealSubject）：该类实现 Subject，是真实被委托的类，也是具体业务逻辑的真正执行者；</li>
<li>代理类或委托类（Proxy）：该类同样实现 Subject，在客户类和本地之间充当中介作用，将客户端的业务操作委托给 RealSubject 执行，并在执行前后做一些预处理或者善后工作。有点类似于AOP，实际上AOP使用的也是代理模式，不过是动态代理。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>上面说了那么多，我们简单的举个静态代理模式的例子吧，我们以购票为例，定义一个购票接口 IBuyer，然后定义一个具体的实现类 Buyer，模式类图简单如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ca2ed.png" alt=""></p>
<p>代码非常简单，我们先来看下 IBuyer 接口的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IBuyer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 购票登录接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> username 用户名</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> password 密码</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟购票接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bugTicket</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是购票的具体实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Buyer</span> <span class="keyword">implements</span> <span class="title">IBuyer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 模拟当前购票人</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Buyer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户："</span> + username + <span class="string">" 使用密码："</span> + password + <span class="string">" 已登录成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bugTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 正在购票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"caiya"</span>;</span><br><span class="line"></span><br><span class="line">        IBuyer buyer = <span class="keyword">new</span> Buyer(name);</span><br><span class="line">        <span class="comment">// 登录</span></span><br><span class="line">        buyer.login(name, <span class="string">"123456"</span>);</span><br><span class="line">        <span class="comment">// 开始购票</span></span><br><span class="line">        buyer.bugTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户：caiya 使用密码：123456 已登录成功</span><br><span class="line">caiya 正在购票</span><br></pre></td></tr></table></figure>

<p>可以看到，在不使用代理模式的情况下一切实现起来也并不复杂，运行结果也都 ok。可是现实生活却并不是这般完美，我们往往买票时并非自己手动操作，而是会经常性地去“刷票”，这就体现出黄牛的价值了，黄牛可以理解成我们的 Buyer 的代理类，使用代理类时大致的类图设计如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/inuli.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyerProxy</span> <span class="keyword">implements</span> <span class="title">IBuyer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBuyer buyer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuyerProxy</span><span class="params">(IBuyer buyer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyer = buyer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buyer.login(username, password);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bugTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        before();</span><br><span class="line">        <span class="keyword">this</span>.buyer.bugTicket();</span><br><span class="line">        after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"准备定时任务，开始刷票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"刷票成功，短信通知客户"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这里我们给购票接口加入了 before 预处理和 after 的善后处理工作，测试及输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用代理类完成购票操作</span></span><br><span class="line">String name = <span class="string">"caiya"</span>;</span><br><span class="line">IBuyer buyer = <span class="keyword">new</span> Buyer(name);</span><br><span class="line">IBuyer proxyBuyer = <span class="keyword">new</span> BuyerProxy(buyer);</span><br><span class="line">proxyBuyer.login(name, <span class="string">"123456"</span>);</span><br><span class="line">proxyBuyer.bugTicket();</span><br></pre></td></tr></table></figure>

<p>具体输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户：caiya 使用密码：123456 已登录成功</span><br><span class="line">准备定时任务，开始刷票</span><br><span class="line">caiya 正在购票</span><br><span class="line">刷票成功，短信通知客户</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在正常购票的同时，前置和后置的增强功能也得到了实现，这就是代理模式的魅力，在不改变原有类代码的情况下实现功能增强。</p>
<h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>上面讲了一下静态代理的基础实例，接下来我们学习下什么是动态代理，在上面静态代理中我们使用手动创建的代理类来实现业务代理，倘若我们现在要服务多种类型的对象，那么是不是要为每个对象都要建立一份代理，这显然是不切实际的。另外静态代理中的接口一旦发生变化，那么意味着代理类也要进行重写，这在大型项目中是不允许的，针对以上两种情况，所以就产生了动态代理。</p>
<h3 id="jdk-动态代理"><a href="#jdk-动态代理" class="headerlink" title="jdk 动态代理"></a>jdk 动态代理</h3><p>jdk 的动态代理是通过反射技术来创建类的加载器并且创建类的实例，根据类执行方法并在方法执行前后进行前置或者后置通知等处理。使用到的就是 Proxy 类的静态方法 newProxyInstance，该方法会返回一个代理类对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces,InvocationHandler h )</span></span></span><br></pre></td></tr></table></figure>

<p>下面我们使用 jdk 的动态代理来实现下上面 BuyerProxy 代理类的功能，这里就直接贴代码来看吧：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"caiya"</span>;</span><br><span class="line">        IBuyer buyer = <span class="keyword">new</span> Buyer(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用jdk 代理类完成 BuyerProxy 操作，重点是如何实现前置后置通知</span></span><br><span class="line">        IBuyer proxy = (IBuyer) Proxy.newProxyInstance(buyer.getClass().getClassLoader(), buyer.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="comment">// 这里我们在 bugTicket 操作前后进行通知操作，来模拟 BuyerProxy</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"bugTicket"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"准备定时任务，开始刷票"</span>);</span><br><span class="line">                    obj = method.invoke(buyer, args);</span><br><span class="line">                    System.out.println(<span class="string">"刷票成功，短信通知客户"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obj = method.invoke(buyer, args);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        proxy.login(name, <span class="string">"123456"</span>);</span><br><span class="line">        proxy.bugTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户：caiya 使用密码：123456 已登录成功</span><br><span class="line">准备定时任务，开始刷票</span><br><span class="line">caiya 正在购票</span><br><span class="line">刷票成功，短信通知客户</span><br></pre></td></tr></table></figure>

<p>可以看到，使用 jdk 动态代理相比静态代理优势更加明显，免去了代理类的编写，由于使用了反射技术，往往 jdk 动态代理效率没有静态代理高。</p>
<p>jdk 的动态代理使用的静态方法第二个参数就是目标对象实现的接口类型，所以需要被代理的目标对象实现一个或多个接口，倘若目标对象没有实现的接口怎么办？这个时候就可以考虑 cglib 动态代理。</p>
<blockquote>
<p>注：静态代理和 jdk 动态代理有一个共同点就是代理类和被代理的目标对象要实现同样的即可。</p>
</blockquote>
<h3 id="cglib-动态代理"><a href="#cglib-动态代理" class="headerlink" title="cglib 动态代理"></a>cglib 动态代理</h3><p>我们来看个简单例子，对于如下购票类，是没有实现接口的比较直接的类，我们要对该类实现类似前置、后置操作就可以使用 cglib 动态代理，先来看下这个购票类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticketer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 模拟当前购票人</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ticketer</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Ticketer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"用户："</span> + username + <span class="string">" 使用密码："</span> + password + <span class="string">" 已登录成功"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bugTicket</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">" 正在购票"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来主角登场，我们使用 cglib 动态代理来实现 BuyerProxy 的类似功能（注意：cglib 需要引入 cglib 的 jar 文件，因为 spring 包含 cglib 的功能，所以引入 spring-core 的 jar 包也可以）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String name = <span class="string">"caiya"</span>;</span><br><span class="line">        Ticketer buyer = <span class="keyword">new</span> Ticketer(name);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 工具类</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">// 设置代理对象的父类</span></span><br><span class="line">        enhancer.setSuperclass(buyer.getClass());</span><br><span class="line">        <span class="comment">// 设置回调函数</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj;</span><br><span class="line">                <span class="comment">// 这里我们在 bugTicket 操作前后进行通知操作，来模拟 BuyerProxy</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"bugTicket"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"准备定时任务，开始刷票"</span>);</span><br><span class="line">                    obj = method.invoke(buyer, args);</span><br><span class="line">                    System.out.println(<span class="string">"刷票成功，短信通知客户"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    obj = method.invoke(buyer, objects);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> obj;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 创建子类（代理对象）</span></span><br><span class="line">        Ticketer ticketerProxy = (Ticketer)enhancer.create();</span><br><span class="line">        ticketerProxy.login(name, <span class="string">"123456"</span>);</span><br><span class="line">        ticketerProxy.bugTicket();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下，可以看出和之前功能完全一致：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">用户：caiya 使用密码：123456 已登录成功</span><br><span class="line">准备定时任务，开始刷票</span><br><span class="line">caiya 正在购票</span><br><span class="line">刷票成功，短信通知客户</span><br></pre></td></tr></table></figure>

<h2 id="代理模式-Vs-装饰器模式"><a href="#代理模式-Vs-装饰器模式" class="headerlink" title="代理模式 Vs 装饰器模式"></a>代理模式 Vs 装饰器模式</h2><p>前面一节中我们还介绍了装饰器模式，两者几乎类图是一致的，区别在于应用侧重点不同，装饰器模式侧重于类的装饰，而代理模式侧重于请求代理，这是我的个人理解，有不同意见的也可以相互讨论。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本小节我们介绍了代理模式的定义、应用等等，又列举了静态代理和动态代理以及相应的实例，想必大家已经知道代理模型的具体含义了，下面我们总结下本节的内容：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/wwp3c.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>传输对象模式</title>
    <url>/posts/8935/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>传输对象模式（Transfer Object Pattern）是指客户端到服务器一次性传递具有多个属性的数据，以避免多次调用远程服务器。传输对象是一个具有 getter/setter 方法的简单的实体类，可被序列化。服务器端业务类通常从数据库读取数据，然后填充到实体类，并把它发送到客户端。</p>
<a id="more"></a>


<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><ul>
<li>传输对象（Transfer Object）：简单的实体类，只有 getter/setter 方法；</li>
<li>业务对象（Business Object）：为客户端提供业务数据，用于数据处理和构建传输对象；</li>
<li>客户端（Client）：发送请求或者发送传输对象到业务对象。</li>
</ul>
<p>角色之间的 UML 关系图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/r3hnj.jpg" alt=""></p>
<h2 id="传输对象模式代码实现"><a href="#传输对象模式代码实现" class="headerlink" title="传输对象模式代码实现"></a>传输对象模式代码实现</h2><h3 id="传输对象"><a href="#传输对象" class="headerlink" title="传输对象"></a>传输对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传输对象，只提供传输对象的 getter/setter 方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransferObject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TransferObject</span><span class="params">(<span class="keyword">int</span> id, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="业务对象"><a href="#业务对象" class="headerlink" title="业务对象"></a>业务对象</h3><p>给系统提供业务数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 业务对象，提供业务数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusinessObject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数据来源的存储容器</span></span><br><span class="line">    List&lt;TransferObject&gt; list;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 填充业务数据（伪代码，模拟数据产生）</span></span><br><span class="line">        list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> TransferObject(<span class="number">0</span>, <span class="string">"Java"</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> TransferObject(<span class="number">1</span>, <span class="string">"SQL"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取所有业务数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;TransferObject&gt; <span class="title">getList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据下标查询相应的数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index 下标</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回单条数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TransferObject <span class="title">getDataById</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改业务数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> transferObject</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(TransferObject transferObject)</span> </span>&#123;</span><br><span class="line">        list.get(transferObject.getId()).setName(transferObject.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建业务对象，获取到数据（伪代码，初始化业务对象时会填充数据）</span></span><br><span class="line">        BusinessObject businessObject = <span class="keyword">new</span> BusinessObject();</span><br><span class="line">        <span class="comment">// 循环打印所有业务数据</span></span><br><span class="line">        <span class="keyword">for</span> (TransferObject t : businessObject.getList()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Id="</span> + t.getId() + <span class="string">" | "</span> + <span class="string">"Name="</span> + t.getName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新数据</span></span><br><span class="line">        TransferObject transferObject = businessObject.getList().get(<span class="number">0</span>);</span><br><span class="line">        System.out.println(<span class="string">"原名称："</span> + transferObject.getName());</span><br><span class="line">        transferObject.setName(<span class="string">"LaoWang"</span>);</span><br><span class="line">        businessObject.update(transferObject);</span><br><span class="line">        <span class="comment">// 打印修改的数据</span></span><br><span class="line">        System.out.println(<span class="string">"修改后的名称："</span> + businessObject.getList().get(<span class="number">0</span>).getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Id=<span class="number">0</span> | Name=Java</span><br><span class="line"></span><br><span class="line">Id=<span class="number">1</span> | Name=SQL</span><br><span class="line"></span><br><span class="line">原名称：Java</span><br><span class="line"></span><br><span class="line">修改后的名称：LaoWang</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>传输对象模式的优点：</p>
<ul>
<li>减少了远程调用次数：通过在单个远程调用中传输更多的数据，应用程序可以减少远程调用次数；</li>
<li>提高了性能：远程调用可以使应用程序的运行速度大大降低，减少调用次数是提高性能的最佳方法之一；</li>
<li>简化了程序代码：使用传输对象的模式使代码可读性更高，让程序看起来更简单。<br>传输对象模式的缺点：</li>
<li>增加了复杂性：由于要兼容多个版本的程序，可能需要创建更多的实体类来适用各个版本的程序，这会让程序变得更加复杂。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>传输对象模式典型的应用场景如下：</p>
<ul>
<li>希望减少程序中远程调用次数；</li>
<li>希望提高程序获取资源的性能；</li>
<li>程序需要传输多个数据时。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="创建物品表"><a href="#创建物品表" class="headerlink" title="创建物品表"></a>创建物品表</h3><p>快递的物品表。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 物品表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsInfo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String mobile;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GoodsInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GoodsInfo</span><span class="params">(String mobile, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMobile</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMobile</span><span class="params">(String mobile)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mobile = mobile;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="快递业务类"><a href="#快递业务类" class="headerlink" title="快递业务类"></a>快递业务类</h3><p>查询所有的快递和新增快递。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 快递业务类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Express</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 所有的快递物品存储容器</span></span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, String&gt; goods;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Express</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 模拟数据</span></span><br><span class="line">        goods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        goods.put(<span class="string">"18000000001"</span>, <span class="string">"Java面试全解析"</span>);</span><br><span class="line">        goods.put(<span class="string">"18000000002"</span>, <span class="string">"MySQL面试金典"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 邮寄物品（添加订单）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> goodsInfo 邮寄的物品</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(GoodsInfo goodsInfo)</span> </span>&#123;</span><br><span class="line">        goods.put(goodsInfo.getMobile(), goodsInfo.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有的邮件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;GoodsInfo&gt; <span class="title">getAllGoods</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;GoodsInfo&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        GoodsInfo goodsInfo;</span><br><span class="line">        goods.forEach((k, v) -&gt; &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> GoodsInfo(k, v));</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用-1"><a href="#客户端调用-1" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson29</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Client</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建快递业务类</span></span><br><span class="line">        Express express = <span class="keyword">new</span> Express();</span><br><span class="line">        <span class="comment">// 创建快递物品</span></span><br><span class="line">        GoodsInfo goodsInfo = <span class="keyword">new</span> GoodsInfo();</span><br><span class="line">        goodsInfo.setMobile(<span class="string">"18000000008"</span>);</span><br><span class="line">        goodsInfo.setName(<span class="string">"设计模式34讲"</span>);</span><br><span class="line">        <span class="comment">// 添加快递</span></span><br><span class="line">        express.insert(goodsInfo);</span><br><span class="line">        <span class="comment">// 打印所有快递信息</span></span><br><span class="line">        express.getAllGoods().forEach((goods) -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"手机号："</span> + goods.getMobile() + <span class="string">" | 快递物品："</span> + goods.getName());</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">手机号：<span class="number">18000000008</span> | 快递物品：设计模式<span class="number">34</span>讲</span><br><span class="line"></span><br><span class="line">手机号：<span class="number">18000000001</span> | 快递物品：Java面试全解析</span><br><span class="line"></span><br><span class="line">手机号：<span class="number">18000000002</span> | 快递物品：MySQL面试金典</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>传输对象模式是客户端每次对业务对象进行相关的业务操作，而客户端和业务对象之间通过传输对象（一个只包含 getter/setter 的实体类）进行信息传递的模式。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/posts/22548/</url>
    <content><![CDATA[<p>设计一个类的时候，我们通常会使用到构造函数，这里类和对象的关系好比模具和构件的关系，对象总是从类中创建的。但是某些场景下是不允许类的调用者直接调用构造函数，也就说对象未必需要从类中衍生出来，现实生活中存在太多案例是通过直接 “克隆” 来产生新的对象，而且克隆出来的本体和克隆体看不出任何区别。</p>
<a id="more"></a>

<p>原型模式不单是一种设计模式，也是一种编程范型。简单理解原型模式 Prototype：不根据类来生成实例，而是根据实例生成新的实例。也就说，如果需要一个和某对象一模一样的对象，那么就可以使用原型模式。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>从设计模式的角度讲，原型模式是一种创建型模式，摆脱了类的构造模式，原型模式告诉我们，想要创建一个对象，我们不必关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。</p>
<p>原型模式的实现关键，是语言本身是否提供了 clone 方法。js 中提供了 Object.create 方法，可以方便的克隆对象。来看下 js 中如何实现 clone 操作的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape - 父类(superclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法</span></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - 子类(subclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"><span class="built_in">console</span>.log(rect);  <span class="comment">// 输出：Rectangle &#123; x: 0, y: 0 &#125;</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// 输出：Shape moved.</span></span><br><span class="line"><span class="built_in">console</span>.log(rect); <span class="comment">// 输出：Rectangle &#123; x: 1, y: 1 &#125;</span></span><br></pre></td></tr></table></figure>

<p>这里我们使用 Object.create 实现了简单的克隆复用，java 中也有类似的操作方法实现：Cloneable 接口和 clone 方法。</p>
<blockquote>
<p>Prototype 模式中实现起来最困难的地方就是内存复制操作，所幸在 Java 中提供了 clone () 方法替我们做了绝大部分事情。</p>
</blockquote>
<p>大家都知道，所有的 java 类都继承自 java.lang.Object 类，而 Object 类默认提供了 clone 方法用来实现对象复制，能够实现的 java 类必须实现一个叫做 Cloneable 的接口，用来标识该类是可以被复制的，如果一个类没有实现 Cloneable 接口而调用 Object.clone 的话，那么 java 会抛出 CloneNotSupportedException 异常。</p>
<p>使用原型模式时，根据其成员是否也克隆，原型模式又分为：浅拷贝和深拷贝。</p>
<h2 id="浅拷贝-Vs-深拷贝"><a href="#浅拷贝-Vs-深拷贝" class="headerlink" title="浅拷贝 Vs 深拷贝"></a>浅拷贝 Vs 深拷贝</h2><p>首先来看一个例子，我们定义一个 Person 类，对它进行简单的测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 定义年龄字段</span></span><br><span class="line">    <span class="keyword">private</span> Date birth; <span class="comment">// 定义生日字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date);</span><br><span class="line">Person p2 = p1;</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure>

<p>打印结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.isoft.Person@1540e19d</span><br><span class="line">com.isoft.Person@1540e19d</span><br></pre></td></tr></table></figure>

<p>可以看出，两个对象地址都一模一样，那么这两个对象就是切切实实的一个对象，这种的话叫做 “复制引用”，使用图描述如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/l8n8n.png" alt=""></p>
<p>再来看看使用 clone 的情况下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line">System.out.println(p1);</span><br><span class="line">System.out.println(p2);</span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">com.isoft.Person@1540e19d</span><br><span class="line">com.isoft.Person@677327b6</span><br></pre></td></tr></table></figure>

<p>从结果看出，打印的对象已经是两个对象了，这种的话就叫做 “复制对象”，使用图简单描述如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/3vb4t.png" alt=""></p>
<p>我们继续，使用 clone 克隆的对象，其中 age 属于基础类型，而 Date 类型属于引用类型，基础类型数据直接复制时就是值的传递，没有任何问题，那么对于这种引用类型的数据使用 clone 后，到底如何呢？我们做一个测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line">System.out.println(p1); <span class="comment">// com.isoft.Person@1540e19d</span></span><br><span class="line">System.out.println(p2); <span class="comment">// com.isoft.Person@677327b6</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1.getAge() == p2.getAge()); <span class="comment">// true</span></span><br><span class="line">date.setTime(<span class="number">234234234L</span>);</span><br><span class="line">System.out.println(p1.getBirth()); <span class="comment">// Sun Jan 04 01:03:54 CST 1970</span></span><br><span class="line">System.out.println(p2.getBirth()); <span class="comment">// Sun Jan 04 01:03:54 CST 1970</span></span><br><span class="line">System.out.println(p1.getBirth() == p2.getBirth()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们改变 date 对象导致 p1 和 p2 的 birth 都发生了变化，所以可以想象 p1 的 birth 和 p2 的 birth 实际指向的还是同一个 Date 对象，<strong>针对这种引用类型，对其拷贝一般有两种，一种是直接将原对象 birth 属性的引用值赋给新的对象 p2 的 birth 属性，这样两个对象的 birth 指向的是用一个 Date 对象，这种就叫做 “浅拷贝”；还有一种就是，将原对象 birth 指向的 Date 对象复制一份，创建一个相同的 Date 对象，然后将这个新的 Date 对象的引用赋给新拷贝的 p2 对象的 birth 属性，这样 p1 和 p2 的 birth 就分别指向了两个不同的 Date 对象，这种就叫做 “深拷贝”。</strong></p>
<p>使用图简单描述如下，首先是浅拷贝：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/z4qk4.png" alt=""></p>
<p>然后是深拷贝的图示：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/okuyf.png" alt=""></p>
<p>那么，如何实现深拷贝，简单的思路就是：通过 Object.clone 方法单独对某个引用属性进行拷贝，来看下代码实现，</p>
<p>我们修改 Person 类的 clone 方法，附上完整类代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 定义年龄字段</span></span><br><span class="line">    <span class="keyword">private</span> Date birth; <span class="comment">// 定义生日字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person p = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        p.birth = (Date) birth.clone();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(p1 == p2);</span><br><span class="line"></span><br><span class="line">date.setTime(<span class="number">234234234L</span>);</span><br><span class="line">System.out.println(p1.getBirth()); <span class="comment">// Sun Jan 04 01:03:54 CST 1970</span></span><br><span class="line">System.out.println(p2.getBirth()); <span class="comment">// Wed Jun 26 19:43:15 CST 2019</span></span><br><span class="line">System.out.println(p1.getBirth() == p2.getBirth()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看到，我们同样地，修改 p1 对象的 birth 属性，但是 p2 中的 birth 并没有发生变化，这就是所谓的 “深拷贝”。</p>
<h2 id="真的是深拷贝？"><a href="#真的是深拷贝？" class="headerlink" title="真的是深拷贝？"></a>真的是深拷贝？</h2><p>上面我们测试了，当我们重写 clone 后实现了引用类型的深拷贝，但是，试想一下，如果引用类型内部还存在引用型属性的话，那么拷贝后的对象是否实现了这种深层的拷贝呢？同样地，我们做一个测试：</p>
<p>我们重新定义下 Person 类，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 定义年龄字段</span></span><br><span class="line">    <span class="keyword">private</span> Date birth; <span class="comment">// 定义生日字段</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Person p = (Person) <span class="keyword">super</span>.clone();</span><br><span class="line">        p.birth = (Date) birth.clone();</span><br><span class="line">        p.address = (Address) address.clone();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, Date birth, Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, Date birth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birth = birth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...省略get、set</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 Address、Code 类定义如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Code code; <span class="comment">// 地址的编号信息字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Code <span class="title">getCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> code;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCode</span><span class="params">(Code code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Address address = <span class="keyword">new</span> Address();</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date, address);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1.getAddress()); <span class="comment">// com.isoft.Address@1540e19d</span></span><br><span class="line">System.out.println(p2.getAddress()); <span class="comment">// com.isoft.Address@677327b6</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1.getAddress().getCode() == p2.getAddress().getCode()); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>经过测试我们发下，虽然 p1 和 p2 的 address 引用的对象已经区分开来了，但是这两对象的 code 属性还是指向的同一个 Code 对象，使用图示说明如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ilngd.png" alt=""></p>
<p>所以，上面的这种复制其实并非真正意义上的 “深拷贝”，如果要实现 code 也是指向不同的对象该如何做呢？</p>
<p>受到前面的启发，我们要实现 “深拷贝” 就需要单独拷贝某个属性来实现，这样修改后的 Address、Code 类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Code code; <span class="comment">// 地址的编号信息字段</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        Address address = (Address) <span class="keyword">super</span>.clone();</span><br><span class="line">        address.code = (Code) code.clone();</span><br><span class="line">        <span class="keyword">return</span> address;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(Code code)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.code = code;</span><br><span class="line">    &#125;</span><br><span class="line">    ...省略get、set</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Code</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样地测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Address address = <span class="keyword">new</span> Address(<span class="keyword">new</span> Code());</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date, address);</span><br><span class="line">Person p2 = (Person) p1.clone();</span><br><span class="line"></span><br><span class="line">System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1.getAddress()); <span class="comment">// com.isoft.Address@1540e19d</span></span><br><span class="line">System.out.println(p2.getAddress()); <span class="comment">// com.isoft.Address@677327b6</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1.getAddress().getCode() == p2.getAddress().getCode()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看到，p1 和 p2 的 address 对应的 code 属性已经是分别指向不同的对象了，图示如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/rzecu.png" alt=""></p>
<h2 id="序列化和反序列化实现深拷贝"><a href="#序列化和反序列化实现深拷贝" class="headerlink" title="序列化和反序列化实现深拷贝"></a>序列化和反序列化实现深拷贝</h2><p>首先来看下什么是序列化和反序列化：</p>
<p>序列化是指将对象的状态信息转换为可以存储或传输的形式的过程。在序列化期间，对象将其当前状态写入到临时或持久性存储区。以后，可以通过从存储区中读取或反序列化对象的状态，重新创建该对象。</p>
<p>从字节流创建对象的相反的过程称为反序列化。而创建的字节流是与平台无关的，在一个平台上序列化的对象可以在不同的平台上反序列化。</p>
<p>使用序列化和反序列化来实现深拷贝，我们还是以上面的代码进行示例：</p>
<p>首先需要为 Person、Address、Code 类实现 Serializable 接口，这里就不写了，测试类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Date date = <span class="keyword">new</span> Date();</span><br><span class="line"></span><br><span class="line">Address address = <span class="keyword">new</span> Address(<span class="keyword">new</span> Code());</span><br><span class="line">Person p1 = <span class="keyword">new</span> Person(<span class="number">23</span>, date, address);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 首先将p1序列化存储</span></span><br><span class="line">ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">oos.writeObject(p1);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化来实现p1的拷贝</span></span><br><span class="line"><span class="keyword">byte</span>[] bytes = bos.toByteArray();</span><br><span class="line">ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bytes);</span><br><span class="line">ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">Person p2 = (Person)ois.readObject();  <span class="comment">//克隆好的对象</span></span><br><span class="line"></span><br><span class="line">System.out.println(p1 == p2); <span class="comment">// false</span></span><br><span class="line">System.out.println(p1.getAddress() == p2.getAddress()); <span class="comment">// false</span></span><br><span class="line">System.out.println(p1.getAddress().getCode() == p2.getAddress().getCode()); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>可以看出，使用序列化和反序列化可以很方便的直接实现深拷贝。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>原型模式一般很少单独出现，一般都是和工厂方法模式一起搭配使用，通过 clone 来创建新的对象，然后由工厂方法返回。依赖倒置原则提醒我们创建对象的时候尽量不要依赖具体的对象类型，原型模式就很好的印证了这句话，避免僵硬地使用 new 来进行对象创建。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>原型模式的优点：</p>
<ul>
<li>向客户隐藏新实例生成的细节</li>
<li>某些环境下，复制对象比新建对象更有效</li>
<li>提供让客户自主创建未知类型对象的方法</li>
<li>减少子类的构造，原型模式通过克隆而不是工厂方法来产生一个对象<br>原型模式的缺点如下：</li>
<li>对象复制有时比较复杂，特别是对象层级嵌套很深时</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节我们介绍了一种新的对象创建的模式，又分别介绍了深拷贝、浅拷贝的概念以及示例，各个语言中其实都会涉及到对象的深浅拷贝问题，实现思路也都不尽相同。又讲解了序列化和反序列化在深拷贝中的应用。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/tiimo.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/posts/46132/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>大家都知道，一个对象的产生都是通过 new 关键字实现的（当然也存在其它方式，比如反射、复制等），new 的实现又是依托于构造函数的，默认一个类会自动生成一个无参的构造函数在不指定构造函数的情况下。构造函数一般都是 public 权限修饰的，想象一下，如果我们将类的构造函数的访问修饰符改为 private 不就可以禁止外部创建该对象了吗？这个时候外部想要实例化该类怎么办呢？</p>
<a id="more"></a>

<p>这时，私有化构造函数的类可以提供相应的 “接口”（一般就是静态方法）来返回自己的唯一实例供外部调用，像这样的确保只生成一个实例的模式被称作单例模式。单例模式一般应用在如下场景：</p>
<ul>
<li>想确保任何情况下都绝对只有一个实例</li>
<li>想在程序上表现出” 只存在一个实例 “</li>
</ul>
<p>概括一下就是：</p>
<ul>
<li>只有一个实例</li>
<li>自我实例化</li>
<li>提供全局访问点</li>
</ul>
<p>所谓的提供全局访问点，就是说除了公共访问点之外，不能通过其他访问点访问该实例。假设一个类只能创建一个实例，那么该类就称为单例类。</p>
<h2 id="单例模式代码实现"><a href="#单例模式代码实现" class="headerlink" title="单例模式代码实现"></a>单例模式代码实现</h2><p>单例模式的主要角色就是单例类，通常该类包含如下实现：</p>
<ul>
<li>私有化的构造函数</li>
<li>私有化的类成员变量</li>
<li>公共的类实例的访问方法</li>
</ul>
<p>其 UML 类图大致如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/6zzc5.png" alt=""></p>
<p>单例模式的实现一般有懒汉式和饿汉式两种，分别列举如下，首先是懒汉式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类变量来缓存创建过的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>; <span class="comment">// 保证instance线程同步</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用synchronized关键字修饰，确保线程安全</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton s1 = Singleton.getInstance();</span><br><span class="line">        Singleton s2 = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(s1 == s2); <span class="comment">// true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式的特点是，类加载时没有创建实例，而是在调用 getInstance 方法时才去创建单例，所以就会存在线程安全性问题。但是每次访问都有同步问题，消耗资源，影响性能，所以建议使用如下饿汉式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用类变量来缓存创建过的实例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>饿汉式就比较好理解，直接在类创建的同时就生成静态成员变量供外部使用，即预先加载法，所以不存在线程安全性问题。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>单例模式优缺点总结如下：</p>
<ul>
<li>单例模式一般拓展困难，除了修改代码几乎没有选择；</li>
<li>单例模式与单一职责原则冲突。一个类，通常只关心它要实现的业务逻辑，但是单例模式既要关心自己是否单例，又要实现业务逻辑，融合性比较高。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>前面讲过，单例模式只有一个实例，消耗资源少，具体场景如下：</p>
<ul>
<li>要求生成唯一序列号的环境；</li>
<li>网站计数器，一般采用单例模式，否则难以同步；</li>
<li>文件系统、打印机、资源管理器等，因为底层资源只能同时被一方操纵，所以这些模块暴露的接口必然是单例的</li>
<li>Java 中的 dao、service 一般都是单例的，而 action 层一般都是多例。</li>
</ul>
<h2 id="Spring-如何实现单例模式"><a href="#Spring-如何实现单例模式" class="headerlink" title="Spring 如何实现单例模式"></a>Spring 如何实现单例模式</h2><p>Spring 框架是我们经常使用的 Java Web 框架，在 Spring 中，Bean 可以被定义为两种模式：prototype（多例）和 singleton（单例）。</p>
<p>所谓的多例：对该 bean 每次请求时都会获取一个新的 bean 实例，类似于 new 操作。</p>
<p>Spring 的 bean 默认是单例模式。bean 的作用域可以通过 bean 标签的 scope 属性进行设置，一般 scope 有如下几种值：</p>
<ul>
<li>singleton（单例）：任何时候获取到的 bean 都是同一个实例；</li>
<li>prototype（多例）：任何时候获取到的 bean 都是新的实例；</li>
<li>request：在 WEB 应用程序中，每一个实例的作用域都为 request 范围；</li>
<li>session：在 WEB 应用程序中，每一个实例的作用域都为 session 范围;</li>
</ul>
<p>Spring 的单例模式又分为饿汉模式和懒汉模式，其中饿汉模式是缺省模式，懒汉模式则需要在 bean 的定义处使用 default-lazy-init=“true” 来声明为懒汉模式。</p>
<p>那么 Spring 对单例的底层实现，到底是饿汉式单例还是懒汉式单例呢？其实，都不是，Spring 对单例的实现是通过单例注册表的方式实现的，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanFactory</span> <span class="keyword">implements</span> <span class="title">ConfigurableBeanFactory</span></span>&#123;  </span><br><span class="line">       <span class="comment">/** </span></span><br><span class="line"><span class="comment">        * 充当了Bean实例的缓存，实现方式和单例注册表相同 </span></span><br><span class="line"><span class="comment">        */</span>  </span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Map singletonCache=<span class="keyword">new</span> HashMap();  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name)</span><span class="keyword">throws</span> BeansException</span>&#123;  </span><br><span class="line">           <span class="keyword">return</span> getBean(name,<span class="keyword">null</span>,<span class="keyword">null</span>);  </span><br><span class="line">       &#125;  </span><br><span class="line">    ...  </span><br><span class="line">       <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String name,Class requiredType,Object[] args)</span><span class="keyword">throws</span> BeansException</span>&#123;  </span><br><span class="line">          <span class="comment">//对传入的Bean name稍做处理，防止传入的Bean name名有非法字符(或则做转码)  </span></span><br><span class="line">          String beanName=transformedBeanName(name);  </span><br><span class="line">          Object bean=<span class="keyword">null</span>;  </span><br><span class="line">          <span class="comment">//手工检测单例注册表  </span></span><br><span class="line">          Object sharedInstance=<span class="keyword">null</span>;  </span><br><span class="line">          <span class="comment">//使用了代码锁定同步块，原理和同步方法相似，但是这种写法效率更高  </span></span><br><span class="line">          <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonCache)&#123;  </span><br><span class="line">             sharedInstance=<span class="keyword">this</span>.singletonCache.get(beanName);  </span><br><span class="line">           &#125;  </span><br><span class="line">          <span class="keyword">if</span>(sharedInstance!=<span class="keyword">null</span>)&#123;  </span><br><span class="line">             ...  </span><br><span class="line">             <span class="comment">//返回合适的缓存Bean实例  </span></span><br><span class="line">             bean=getObjectForSharedInstance(name,sharedInstance);  </span><br><span class="line">          &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            ...  </span><br><span class="line">            <span class="comment">//取得Bean的定义  </span></span><br><span class="line">            RootBeanDefinition mergedBeanDefinition=getMergedBeanDefinition(beanName,<span class="keyword">false</span>);  </span><br><span class="line">             ...  </span><br><span class="line">            <span class="comment">//根据Bean定义判断，此判断依据通常来自于组件配置文件的单例属性开关  </span></span><br><span class="line">            <span class="comment">//&lt;bean id="date" class="java.util.Date" scope="singleton"/&gt;  </span></span><br><span class="line">            <span class="comment">//如果是单例，做如下处理  </span></span><br><span class="line">            <span class="keyword">if</span>(mergedBeanDefinition.isSingleton())&#123;  </span><br><span class="line">               <span class="keyword">synchronized</span>(<span class="keyword">this</span>.singletonCache)&#123;  </span><br><span class="line">                <span class="comment">//再次检测单例注册表  </span></span><br><span class="line">                 sharedInstance=<span class="keyword">this</span>.singletonCache.get(beanName);  </span><br><span class="line">                 <span class="keyword">if</span>(sharedInstance==<span class="keyword">null</span>)&#123;  </span><br><span class="line">                    ...  </span><br><span class="line">                   <span class="keyword">try</span> &#123;  </span><br><span class="line">                      <span class="comment">//真正创建Bean实例  </span></span><br><span class="line">                      sharedInstance=createBean(beanName,mergedBeanDefinition,args);  </span><br><span class="line">                      <span class="comment">//向单例注册表注册Bean实例  </span></span><br><span class="line">                       addSingleton(beanName,sharedInstance);  </span><br><span class="line">                   &#125;<span class="keyword">catch</span> (Exception ex) &#123;  </span><br><span class="line">                      ...  </span><br><span class="line">                   &#125;<span class="keyword">finally</span>&#123;  </span><br><span class="line">                      ...  </span><br><span class="line">                  &#125;  </span><br><span class="line">                 &#125;  </span><br><span class="line">               &#125;  </span><br><span class="line">              bean=getObjectForSharedInstance(name,sharedInstance);  </span><br><span class="line">            &#125;  </span><br><span class="line">           <span class="comment">//如果是非单例，即prototpye，每次都要新创建一个Bean实例  </span></span><br><span class="line">           <span class="comment">//&lt;bean id="date" class="java.util.Date" scope="prototype"/&gt;  </span></span><br><span class="line">           <span class="keyword">else</span>&#123;  </span><br><span class="line">              bean=createBean(beanName,mergedBeanDefinition,args);  </span><br><span class="line">           &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ...  </span><br><span class="line">       <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种使用 Map 对象（登记薄）来维护一组单例类的实例又称为登记式单例，不管是饿汉式还是懒汉式，因为其构造函数都是私有不可继承的，Spring 为实现单例类可继承，就使用了单例注册表（登记薄）形式。</p>
<p>登记薄基本功能是：对于已经登记过的单例，则从工厂直接返回，对于没有登记的，则先登记，而后返回。基本点如下：</p>
<ul>
<li>使用 Map 实现注册表</li>
<li>使用 protect 取代原先的 private 的构造方法，确保子类可继承</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节我们学习了单例模式，单例模式在工作中使用的还是比较多的，比如要生成唯一序列号、唯一连接对象等等这些都是要用到单例模式的，然后我们又介绍了下单例模式的优缺点以及简单说了下单例注册表的相关知识点，大家可以好好练习下。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/jp3de.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>工厂模式</title>
    <url>/posts/6013/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>工厂模式，是设计模式中最为常见的模式之一。属于创建型模式，提供创建对象的最佳方式。</p>
<p>工厂模式，顾名思义，一个模型，用来大规模的生产同类产品。该模式将对象的具体实例过程抽象化，并不关心具体的创建过程。通常，工厂模式被用来定义一个对象模型，之后，便可快速规模化实例化对象。</p>
<p>简单工厂模式的实质：一个工厂类根据传入的参数，动态决定应该创建哪一类产品类（这些产品类均继承自一个父类或接口）实例。</p>
<a id="more"></a>

<h2 id="模拟场景"><a href="#模拟场景" class="headerlink" title="模拟场景"></a>模拟场景</h2><p>本来创建对象用 new 就行了，为什么要用函数或类将 new 的过程封装起来呢？</p>
<p>这里，我们引入两个角色，一个是类的设计者，一个是类的使用者。类的使用者只关心 “这个对象做这事”、“那个对象做那件事”，而不关心 “这件事如何去做？”，通常，类的设计者才会去关心 “如何去做”。</p>
<p>举个栗子，类的设计者设计了 “阿猫”、“阿狗” 两个类，类的使用者需要创建 “阿猫 1”、“阿狗 2” 两个对象，如果不使用工厂模式，类的使用者就需要明确知道 “阿猫”、“阿狗” 两个类，这无疑增加了类使用者的负担。使用工厂来代替创建这两对象，权责分开，比方说，这些动物都有 “吃东西” 的行为，这时，“吃东西” 具体行为是什么样子，这是类的设计者关心的，而何时进行该行为，是类的使用者关心的。</p>
<p>再比如，我们经常使用的数据库中间件，我们无需关心具体的底层实现类，只需将用户名密码等连接信息传过去，就会直接获取到相应的数据库连接实例，这个角度，就可以将数据库中间件看作一个大的工厂。</p>
<p>优点：</p>
<ul>
<li>一个调用者想创建某个对象，只需知道其名称即可</li>
<li>屏蔽具体行为实现，调用者只需关心产品接口，减轻调用者负担</li>
<li>拓展性高，如果想增加一个产品类，只需拓展一个工厂类即可</li>
</ul>
<h2 id="具体分类"><a href="#具体分类" class="headerlink" title="具体分类"></a>具体分类</h2><p>一般来说，工厂模式分为三种：普通简单工厂模式、多方法简单工厂、静态方法简单工厂。这三种模式从上到下逐步抽象，并且根据一般性。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/dscnw.png" alt=""></p>
<h3 id="普通简单工厂"><a href="#普通简单工厂" class="headerlink" title="普通简单工厂"></a>普通简单工厂</h3><p>就是建立一个具体工厂类，对实现了同一接口的一些类进行实例的创建，首先看下 uml 类图（这里以发送短信、邮件、快递为例）：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/8erht.png" alt=""></p>
<p>首先，创建一个三者共有的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后，创建实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送快递"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再然后，我们创建一个工厂类来产出这几种 “产品”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"email"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> EmailSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"sms"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"express"</span>.equalsIgnoreCase(type)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ExpressSender();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们试着调用下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory sendFactory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Sender senderSms = sendFactory.produce(<span class="string">"sms"</span>);</span><br><span class="line">        senderSms.Send(); <span class="comment">// 发送短信</span></span><br><span class="line"></span><br><span class="line">        Sender senderEmail = sendFactory.produce(<span class="string">"email"</span>);</span><br><span class="line">        senderEmail.Send(); <span class="comment">// 发送邮件</span></span><br><span class="line"></span><br><span class="line">        Sender senderExpress = sendFactory.produce(<span class="string">"express"</span>);</span><br><span class="line">        senderExpress.Send(); <span class="comment">// 发送快递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多方法简单工厂"><a href="#多方法简单工厂" class="headerlink" title="多方法简单工厂"></a>多方法简单工厂</h3><p>多方法简单工厂是在前者的基础上该进来的，普通工厂方法在使用时，如果 type 类型传递错误则不能正确创建对象，多方法直接将 produce 中的逻辑展开到具体的方法中，从而避免该问题。接下来看下我们的改进：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/kfl6j.png" alt=""></p>
<p>针对上面代码，我们只需调整 SendFactory 类即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceSms</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceEmail</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmailSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produceExpress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExpressSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，我们进行如下简单测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SendFactory sendFactory = <span class="keyword">new</span> SendFactory();</span><br><span class="line">        Sender senderEmail = sendFactory.produceEmail();</span><br><span class="line">        senderEmail.Send(); <span class="comment">// 发送邮件</span></span><br><span class="line"></span><br><span class="line">        Sender senderSms = sendFactory.produceSms();</span><br><span class="line">        senderSms.Send(); <span class="comment">// 发送短信</span></span><br><span class="line"></span><br><span class="line">        Sender senderExpress = sendFactory.produceExpress();</span><br><span class="line">        senderExpress.Send(); <span class="comment">// 发送快递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="静态方法简单工厂"><a href="#静态方法简单工厂" class="headerlink" title="静态方法简单工厂"></a>静态方法简单工厂</h3><p>普通工厂模式和多方法工厂模式有一个弊端，就是需要频繁的实例化工厂类，一般我们会将 “多方法” 设置为静态的，从而避免类的频繁实例化，拿来即用。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/9hrl7.png" alt=""><br>这里我们直接看修改后的 SendFactory 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//SendFactory sendFactory = new SendFactory();</span></span><br><span class="line">        Sender senderEmail = SendFactory.produceEmail();</span><br><span class="line">        senderEmail.Send(); <span class="comment">// 发送邮件</span></span><br><span class="line"></span><br><span class="line">        Sender senderSms = SendFactory.produceSms();</span><br><span class="line">        senderSms.Send(); <span class="comment">// 发送短信</span></span><br><span class="line"></span><br><span class="line">        Sender senderExpress = SendFactory.produceExpress();</span><br><span class="line">        senderExpress.Send(); <span class="comment">// 发送快递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="简单工厂的延申-—-工厂方法模式"><a href="#简单工厂的延申-—-工厂方法模式" class="headerlink" title="简单工厂的延申 — 工厂方法模式"></a>简单工厂的延申 — 工厂方法模式</h2><p>上面介绍的简单工厂模式有个比较明显的弊端：工厂类集中了所有实例的创建逻辑，明显违背高内聚的责任分配原则，违背了闭包规则。</p>
<p>而工厂方法模式则是对该问题的进一步延伸解决，差异就是将原先存在于一个工厂类中的逻辑抽调出来，创建一个接口和多个工厂类。这样，一旦功能有新增，比如说我们要加一个 “发送导弹” 的功能，只需要加一个 “导弹发送工厂类”，该类实现 produce 接口返回实例化的 “导弹发送类”，再在 “导弹发送类” 中，实现具体的发送逻辑即可，无需修改之前的业务代码，拓展性较好。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/7m4sp.png" alt=""><br>首先，我们还是创建一个 Sender 接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们创建几个具体的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送短信"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressSender</span> <span class="keyword">implements</span> <span class="title">Sender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送快递"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSender</span> <span class="keyword">implements</span> <span class="title">Sender</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"发送邮件"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后，我们统一一下工厂类的接口行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续，定义几个工厂实现上面这种 “行为约束”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ExpressSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> EmailSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSendFactory</span> <span class="keyword">implements</span> <span class="title">Provider</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Sender <span class="title">produce</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SmsSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Provider providerSms = <span class="keyword">new</span> SmsSendFactory();</span><br><span class="line">        Sender senderSms = providerSms.produce();</span><br><span class="line">        senderSms.Send(); <span class="comment">// 发送短信</span></span><br><span class="line"></span><br><span class="line">        Provider providerEmail = <span class="keyword">new</span> EmailSendFactory();</span><br><span class="line">        Sender senderEmail = providerEmail.produce();</span><br><span class="line">        senderEmail.Send(); <span class="comment">// 发送邮件</span></span><br><span class="line"></span><br><span class="line">        Provider providerExpress = <span class="keyword">new</span> ExpressSendFactory();</span><br><span class="line">        Sender senderExpress = providerExpress.produce();</span><br><span class="line">        senderExpress.Send(); <span class="comment">// 发送快递</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>工厂方法模式中，核心的工厂类（这里为 Provider 接口）不再负责所有产品的创建，而是将具体创建的工作交给子类去做，该核心类仅扮演抽象工厂的角色，负责给出具体工厂子类必须实现的接口，而不接触哪一个产品类应该被实例化的细节，拓展性较简单工厂模式提升明显。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>外观模式(门面模式)</title>
    <url>/posts/54078/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本小节我们要学习的设计模式叫做外观模式，也叫做门面模式 Facade。想象一下，我们系统随着时间的推移，系统复杂性、类之间的相互调用会变得越来越多，相比较客户角度而言，客户往往关注的是某个单一接口 API，而不会关心该 API 内部的复杂性或者内部子系统是如何运作的。</p>
<a id="more"></a>

<p>举个栗子，我们都玩过射击类游戏，游戏玩家对战的时候，需要进行射击操作，而射击牵扯到一连串的动作，比如：上子弹、瞄准、发射子弹、掉血、加分等等一系列动作，这些动作我们可以理解为各个子系统的某个接口 API，比如上子弹、发射子弹可能是武器子系统的 API，掉血、加分可能是用户子系统的 API，客户角度需要调用的接口其实只有一个，那就是射击 API，这就是具体的门面接口，门面内部的各个子系统的动作对客户是透明的，这种客户只需要调用门面接口 API 就实现了一连串内部动作（上子弹、瞄准、发射子弹、掉血、加分等）的模式其实就叫做外观模式，也叫做门面模式。</p>
<p>外观模式的定义是：<strong>为各个子系统的一组接口提供一致的调用窗口或门面，使得子系统更容易使用，使得复杂的子系统与客户端分离解耦。</strong></p>
<p>下面用一个简单的例子来说明下使用外观模式和不使用外观模式下系统设计的差别，继续看吧。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>这里还是以上面的射击游戏为例，先来看下不使用外观模式时候的类图设计</p>
<h3 id="不使用外观模式"><a href="#不使用外观模式" class="headerlink" title="不使用外观模式"></a>不使用外观模式</h3><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ycz1m.jpeg" alt=""></p>
<p>这里代码比较简单，我们直接列出武器系统和用户系统的示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FireSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fire</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开火...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"上子弹...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserSystem</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseBlood</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"掉血..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addScore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"得分..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试类 Client 角色如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FireSystem fireSystem = <span class="keyword">new</span> FireSystem();</span><br><span class="line">UserSystem userSystem = <span class="keyword">new</span> UserSystem();</span><br><span class="line"></span><br><span class="line">fireSystem.useBullet(); <span class="comment">// 上子弹</span></span><br><span class="line">fireSystem.fire(); <span class="comment">// 开火</span></span><br><span class="line">userSystem.loseBlood(); <span class="comment">// 掉血</span></span><br><span class="line">userSystem.addScore(); <span class="comment">// 加分</span></span><br></pre></td></tr></table></figure>

<p>测试结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上子弹…</span><br><span class="line">开火…</span><br><span class="line">掉血…</span><br><span class="line">得分…</span><br></pre></td></tr></table></figure>

<h3 id="使用外观模式"><a href="#使用外观模式" class="headerlink" title="使用外观模式"></a>使用外观模式</h3><p>上面不使用外观模式时，可以看到客户端需要自己去直接调用各个子系统 API，系统模块多的时候对客户端十分不友好，下面我们看下使用外观模式如何解决这种问题，外观模式的类图设计如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/kfq0a.png" alt=""></p>
<p>这里我们引入 Facade 角色，该角色内部包含各个子系统的被委托的对象，客户端的所有请求经过 Facade 角色中转，简化了客户端操作的复杂性，Facade 代码示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Facade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 被委托的对象</span></span><br><span class="line">    <span class="keyword">private</span> FireSystem fireSystem;</span><br><span class="line">    <span class="keyword">private</span> UserSystem userSystem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Facade</span><span class="params">(FireSystem fireSystem, UserSystem userSystem)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fireSystem = fireSystem;</span><br><span class="line">        <span class="keyword">this</span>.userSystem = userSystem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟射击的门面接口 API</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shooting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fireSystem.useBullet(); <span class="comment">// 上子弹</span></span><br><span class="line">        fireSystem.fire(); <span class="comment">// 开火</span></span><br><span class="line">        userSystem.loseBlood(); <span class="comment">// 敌人掉血</span></span><br><span class="line">        userSystem.addScore(); <span class="comment">// 自己加分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 Client 调整如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FireSystem fireSystem = <span class="keyword">new</span> FireSystem();</span><br><span class="line">UserSystem userSystem = <span class="keyword">new</span> UserSystem();</span><br><span class="line"></span><br><span class="line">Facade facade = <span class="keyword">new</span> Facade(fireSystem, userSystem);</span><br><span class="line">facade.shooting(); <span class="comment">// 射击</span></span><br></pre></td></tr></table></figure>

<p>结果输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">上子弹…</span><br><span class="line">开火…</span><br><span class="line">掉血…</span><br><span class="line">得分…</span><br></pre></td></tr></table></figure>

<p>可以看出，门面模式下，客户端接口调用的复杂性有所降低，并且内部系统和客户端之间解耦，使用门面模式下的“接待员”接口即可完成功能操作。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/3v5wl.png" alt=""></p>
<p>外观模式的一般类图如上所示，包含的角色列举如下：</p>
<ul>
<li>门面角色（Facade）：门面模式自然少不了门面角色，这就是我们的 Facade 类，一般情况下，该角色会将客户端的请求委派给相应的子系统去调用，也就说该角色实际没有啥实质性的业务逻辑，只是一个单纯的委派类，用来实现客户端和子系统的解耦；</li>
<li>子系统角色（SubSystem）：子系统并不是一个单一的类，而是众多类的一个系统集合。一般而言，子系统并不知道门面角色的存在，也就说对子系统而言，门面角色是完全透明的。子系统各自实现自己的功能，包括类之间的相互调用等，这些都不受门面角色的影响。</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>外观模式优点：</p>
<ul>
<li>实现了子系统与客户端之间关系的解耦；</li>
<li>客户端屏蔽了子系统组件，使得客户端所需处理的对象数目有所减少，使得子系统使用起来更加容易。</li>
</ul>
<p>外观模式缺点：</p>
<ul>
<li>增加新的子系统可能需要修改外观类或者客户端的源代码，违背了开闭原则；</li>
<li>外观类并没有阻断子系统被外部使用的可能性。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节我们介绍了什么是外观模式，以及外观模式的代码示例，总结下外观模式的特点及本节内容如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/7pp82.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/posts/29711/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>所谓万丈高楼平地起，但是我们建造（Build）高楼时，需要经历很多阶段，比如打地基、搭框架、浇筑水泥、封顶等，这些都是很难一气呵成的。所以一般我们是先建造组成高楼的各个部分，然后将其一个个地组装起来，好比搭积木一般，分阶段拼接后组装成一个完整的物体。还有个问题，就是同样的积木，同样的搭建过程，却能 Build 出不同的物体，这就叫做建造者模式。</p>
<a id="more"></a>

<p>将一个复杂的对象的构建与它的表示相分离，使得同样的构建过程可以创建出不同的表示。建造者模式（Builder Pattern）也叫做生成器模式。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>建造者模式通常有以下几部分角色组成：</p>
<ul>
<li>建造者（Builder）：Builder 角色负责定义用来生成实例的接口（API）；</li>
<li>具体的建造者（ConcreateBuilder）：ConcreateBuilder 角色是负责实现 Builder 角色定义的接口的实现类。针对不同的商业逻辑，具体化复杂对象的各部分的创建。在建造完成之后提供产品的实例；</li>
<li>监工（Director）：Director 角色负责使用 Builder 角色的接口 API 来生成实例。内部不涉及具体产品信息，只负责保证对象各部分完整创建或按照某种顺序进行创建。即 Director 是负责指挥如何 build 的，只负责调度，具体实施交给具体的建造者；</li>
<li>产品（Product）：即要创建的复杂对象；</li>
<li>使用者（Client）：实际使用 Builder 模式的角色，即下面的测试类。</li>
</ul>
<h2 id="建造者模式-UML-类图"><a href="#建造者模式-UML-类图" class="headerlink" title="建造者模式 UML 类图"></a>建造者模式 UML 类图</h2><p>我们还是以最开始讲的建造大楼为例，其 UML 类图大致如下：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/e0gqg.png" alt=""></p>
<p>建造者模式的代码实现如下，首先是产品类（Product）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ground;</span><br><span class="line">    <span class="keyword">private</span> String cement;</span><br><span class="line">    <span class="keyword">private</span> String roof;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Product</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getGround</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ground;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGround</span><span class="params">(String ground)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ground = ground;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCement</span><span class="params">(String cement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cement = cement;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> roof;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRoof</span><span class="params">(String roof)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.roof = roof;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建造者的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildGround</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"build地基"</span>);</span><br><span class="line">        product.setGround(<span class="string">"build地基"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildCement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"build水泥"</span>);</span><br><span class="line">        product.setGround(<span class="string">"build水泥"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildRoof</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"build楼顶"</span>);</span><br><span class="line">        product.setGround(<span class="string">"build楼顶"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">buildProduct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"建造完毕!"</span>);</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是我们的监工，负责指挥 builder 如何建造即如何调度：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Builder builder;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">construct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 构建顺序：建造水泥-&gt;地基-&gt;楼顶</span></span><br><span class="line">        builder.buildCement();</span><br><span class="line">        builder.buildGround();</span><br><span class="line">        builder.buildRoof();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> builder.buildProduct();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，是 Client 角色，即具体的使用者，这里的话就是测试的 Main 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Builder builder = <span class="keyword">new</span> ConcreteBuilder();</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        director.construct();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">build水泥</span><br><span class="line">build地基</span><br><span class="line">build楼顶</span><br><span class="line">建造完毕!</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul>
<li>封装性：客户端不必知道产品内部组合细节，只需关心我们要生成某个对象，具体对象产生细节不必知晓。Main 类并不知道 Builder 类，它只是调用了 Director 类的 construct 方法完成对象的获取；</li>
<li>建造者独立，易于拓展：上面我们只列举了 ConcreteBuilder 建造者类，如果需要其它建造者新建类即可。建造者之间彼此独立，系统拓展性好，符合开闭原则；</li>
<li>便于控制细节风险：由于具体建造者是独立的，因此可以对具体建造过程逐步细化，不会对其它模块产生影响。<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2></li>
<li>产品类非常复杂，不同的调度产生不同的结果时，使用建造者模式比较适合；</li>
<li>相同的组件或配件都可以装配到一个对象，但是产生的结果又不相同，可以使用建造者模式。</li>
</ul>
<h2 id="建造者模式-VS-工厂方法模式"><a href="#建造者模式-VS-工厂方法模式" class="headerlink" title="建造者模式 VS 工厂方法模式"></a>建造者模式 VS 工厂方法模式</h2><p>建造者模式关注的是零件类型和装配顺序（工艺）同为创建型模式，注重点不同。另外工厂模式只有一个建造方法，而建造者模式有多个建造零部件的方法并且强调建造顺序，而工厂模式没有顺序的概念。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>将复杂物体的构建与表现相分离，这就是建造者模式，很像生活中搭积木这种，一个个按需要按方式进行拼凑，建造者模式适应于产品类比较复杂调度方式不一的场景。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/3r1g3.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>数据访问对象模式</title>
    <url>/posts/5623/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>数据访问对象模式（Data Access Object Pattern）又称为 DAO 模式，是一种面向对象的数据访问接口，DAO 一般都是和数据库打交道，属于业务逻辑和数据库中间的环节，负责业务逻辑数据的持久化。</p>
<a id="more"></a>


<p>DAO 模式在开发 MVC 应用十分普遍，不管是 JPA 的 DAO，还是 Mybatis 的 Mapper，其实都是面向持久化的操作，我们都可以将其成为数据访问对象。</p>
<p>下图为阿里巴巴 JAVA 开发手册中介绍的应用分层，其中数据访问对象承担的就是 DAO 层工作，负责和数据源打交道。感兴趣的同学可以去看看阿里巴巴 JAVA 开发手册，比较推荐。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/nf2jq.jpg" alt=""></p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>数据访问对象模式包含角色如下：</p>
<ul>
<li>数据访问对象接口（Data Access Object Interface）：提供数据持久化或数据访问的抽象接口定义；</li>
<li>数据访问对象具体实现类（Data Access Object Concrete Class）：负责实现数据访问对象接口，真正对数据进行操作的实现类，底层数据源可以是数据库、内存、Xml、文件数据等等；</li>
<li>模型对象或值对象（Model Object/Value Object）：传统的 POJO（Plain Ordinary Java Object），可以理解为简单的实体类。</li>
</ul>
<p>数据访问对象模式的 UML 类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/8qxuj.jpg" alt=""></p>
<h2 id="数据访问对象模式代码实现"><a href="#数据访问对象模式代码实现" class="headerlink" title="数据访问对象模式代码实现"></a>数据访问对象模式代码实现</h2><p>上面的 UML 类图是以用户为模型对象进行说明的，这里我们用代码实现下：</p>
<h3 id="UserDAO-数据访问接口"><a href="#UserDAO-数据访问接口" class="headerlink" title="UserDAO 数据访问接口"></a>UserDAO 数据访问接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * DAO接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDAO</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 新增</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">addUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询单条</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">getUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(Integer id)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> user</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">User <span class="title">updateUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserDAO-访问接口实现类"><a href="#UserDAO-访问接口实现类" class="headerlink" title="UserDAO 访问接口实现类"></a>UserDAO 访问接口实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UserDAO的实现类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDAOImpl</span> <span class="keyword">implements</span> <span class="title">UserDAO</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> List&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;User&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">addUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        userList.add(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        userList.stream().forEach(System.out::println);</span><br><span class="line">        System.out.println();</span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userList.stream().filter(user -&gt; user.getUserId() == id).findFirst().get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        Iterator&lt;User&gt; iterator = userList.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            User user = (User) iterator.next();</span><br><span class="line">            <span class="keyword">if</span> (user.getUserId() == id) &#123;</span><br><span class="line">                iterator.remove();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">updateUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (User u : userList) &#123;</span><br><span class="line">            <span class="keyword">if</span> (u.getUserId() == user.getUserId()) &#123;</span><br><span class="line">                userList.set(userList.indexOf(u), user);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="User-实体类"><a href="#User-实体类" class="headerlink" title="User 实体类"></a>User 实体类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户实体类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Administrator</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer userId;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> userAge;</span><br><span class="line">    <span class="keyword">private</span> Date userBirth;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getUserId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userId = userId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userName = userName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUserAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserAge</span><span class="params">(<span class="keyword">int</span> userAge)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userAge = userAge;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">getUserBirth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userBirth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUserBirth</span><span class="params">(Date userBirth)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userBirth = userBirth;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Builder();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer userId;</span><br><span class="line">        <span class="keyword">private</span> String userName;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> userAge;</span><br><span class="line">        <span class="keyword">private</span> Date userBirth;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">userId</span><span class="params">(Integer userId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userId = userId;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">userName</span><span class="params">(String userName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userName = userName;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">userAge</span><span class="params">(<span class="keyword">int</span> userAge)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userAge = userAge;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">userBirth</span><span class="params">(Date userBirth)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.userBirth = userBirth;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setUserAge(userAge);</span><br><span class="line">            user.setUserBirth(userBirth);</span><br><span class="line">            user.setUserId(userId);</span><br><span class="line">            user.setUserName(userName);</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"User [userId="</span> + userId + <span class="string">", userName="</span> + userName + <span class="string">", userAge="</span> + userAge + <span class="string">", userBirth="</span> + userBirth</span><br><span class="line">                + <span class="string">"]"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserDAO userDAO = <span class="keyword">new</span> UserDAOImpl();</span><br><span class="line">        userDAO.addUser(User.builder().userId(<span class="number">1</span>).userAge(<span class="number">23</span>).userBirth(<span class="keyword">new</span> Date()).userName(<span class="string">"caiya"</span>).build());</span><br><span class="line">        userDAO.addUser(User.builder().userId(<span class="number">2</span>).userAge(<span class="number">24</span>).userBirth(<span class="keyword">new</span> Date()).userName(<span class="string">"laowang"</span>).build());</span><br><span class="line">        userDAO.addUser(User.builder().userId(<span class="number">3</span>).userAge(<span class="number">26</span>).userBirth(<span class="keyword">new</span> Date()).userName(<span class="string">"lily"</span>).build());</span><br><span class="line">        userDAO.getUsers();</span><br><span class="line">        </span><br><span class="line">        userDAO.deleteUserById(<span class="number">1</span>);</span><br><span class="line">        userDAO.getUsers();</span><br><span class="line">        </span><br><span class="line">        userDAO.updateUser(User.builder().userId(<span class="number">3</span>).userAge(<span class="number">40</span>).userBirth(<span class="keyword">new</span> Date()).userName(<span class="string">"修改后的"</span>).build());</span><br><span class="line">        userDAO.getUsers();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [userId=<span class="number">1</span>, userName=caiya, userAge=<span class="number">23</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br><span class="line"></span><br><span class="line">User [userId=<span class="number">2</span>, userName=laowang, userAge=<span class="number">24</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br><span class="line"></span><br><span class="line">User [userId=<span class="number">3</span>, userName=lily, userAge=<span class="number">26</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br><span class="line"></span><br><span class="line">User [userId=<span class="number">2</span>, userName=laowang, userAge=<span class="number">24</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [userId=<span class="number">3</span>, userName=lily, userAge=<span class="number">26</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [userId=<span class="number">2</span>, userName=laowang, userAge=<span class="number">24</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">User [userId=<span class="number">3</span>, userName = 修改后的，userAge=<span class="number">40</span>, userBirth=Sun Dec <span class="number">22</span> <span class="number">11</span>:<span class="number">40</span>:<span class="number">45</span> CST <span class="number">2019</span>]</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>数据访问对象模式的优点：</p>
<ul>
<li>业务层和数据持久层分离，减轻系统耦合度；</li>
<li>数据访问对象单独抽离出来，可以适配各种底层持久化类型，提高系统的拓展性。<br>数据访问对象模式的缺点：</li>
<li>每添加一个实体类，就必须添加一套 DAO 接口和一套 DAO 实现类，会导致代码重复臃肿（可以借助类似 JPA、Mybatis Plus 这种 ORM 框架可以自动帮我们实现 DAO 的实现类，这样一来只需要定义 DAO 接口即可）。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>数据访问对象模式的应用场景如下：</p>
<ul>
<li>DAO 的引入，帮助我们实现对持久化层的操作，只关心业务逻辑；</li>
<li>一切和持久化层打交道的应用场景都会感受到数据访问对象模式的影子，有数据访问就会有 DAO 的存在。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>这里我们以 Spring Data JPA 实现一套业务接口，感受下 DAO 模式带来的魅力，首先是新建 Spring Boot Web 项目，pom 依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-jpa<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.junit.vintage<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit-vintage-engine<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="application-yml-配置"><a href="#application-yml-配置" class="headerlink" title="application.yml 配置"></a>application.yml 配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">8087</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=utf8&amp;useSSL=false</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">jpa:</span></span><br><span class="line">    <span class="attr">hibernate:</span></span><br><span class="line">      <span class="attr">ddl-auto:</span> <span class="string">update</span></span><br><span class="line">    <span class="attr">show-sql:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="用户实体-UserEntity"><a href="#用户实体-UserEntity" class="headerlink" title="用户实体 UserEntity"></a>用户实体 UserEntity</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span>(name = <span class="string">"sys_user"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@GeneratedValue</span></span><br><span class="line">    <span class="meta">@Column</span>(name = <span class="string">"id"</span>, length = <span class="number">32</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">50</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Column</span>(length = <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="UserDAO-层接口"><a href="#UserDAO-层接口" class="headerlink" title="UserDAO 层接口"></a>UserDAO 层接口</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span> <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">UserEntity</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据姓名查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">List&lt;UserEntity&gt; <span class="title">findByNameLike</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们要说明下，为什么我们这里只写了一个接口，因为继承 JpaRepository 后， JPA 会自动帮我们实现很多常用的 DAO 接口以及 DAO 实现类，感兴趣的同学可以去了解下 JPA。</p>
<h3 id="UserService-实现类"><a href="#UserService-实现类" class="headerlink" title="UserService 实现类"></a>UserService 实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 插入</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userEntity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUser</span><span class="params">(UserEntity userEntity)</span> </span>&#123;</span><br><span class="line">        userDao.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 修改</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> userEntity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateUser</span><span class="params">(UserEntity userEntity)</span> </span>&#123;</span><br><span class="line">        userDao.save(userEntity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        userDao.deleteById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询所有</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title">findAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 查询单个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserEntity <span class="title">findUserById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findById(id).get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据姓名查询</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;UserEntity&gt; <span class="title">findUsersByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userDao.findByNameLike(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，UserService 引用了 UserDao 进行持久化操作，UserService 就是我们的业务逻辑处理层，UserDAO 默认实现了类似 findById、deleteById、save 等很多 JPA 自动帮我们实现的接口，十分方便。</p>
<h3 id="UserController-控制器层"><a href="#UserController-控制器层" class="headerlink" title="UserController 控制器层"></a>UserController 控制器层</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/users"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Resource</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.CREATED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">addUser</span><span class="params">(@RequestBody UserEntity user)</span> </span>&#123;</span><br><span class="line">        userService.addUser(user);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@DeleteMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.NO_CONTENT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deleteUser</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>, required = <span class="keyword">true</span>)</span> Long id) </span>&#123;</span><br><span class="line">        userService.deleteUserById(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PutMapping</span></span><br><span class="line">    <span class="meta">@ResponseStatus</span>(HttpStatus.NO_CONTENT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">updateUser</span><span class="params">(@RequestBody UserEntity user)</span> </span>&#123;</span><br><span class="line">        userService.updateUser(user);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">findAllUsers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findAll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">findUserById</span><span class="params">(@PathVariable(name = <span class="string">"id"</span>, required = <span class="keyword">true</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUserById(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/findUsersWithName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">findAllUsersByName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.findUsersByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>DAO 模式的引入，使得我们业务层和数据访问层解耦，再加上现在层出不穷的 ORM 框架，数据访问这块可以说是十分便捷，类似 JPA 这种只需要定义几个接口，JPA 就能自动帮我们实现持久化操作，可以说是很普惠了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/posts/43376/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>桥接模式 (Bridge Pattern)：将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体 (Handle and Body) 模式或接口 (Interface) 模式。</p>
<a id="more"></a>

<p>Bridge 的意思就是 “桥梁”，好比现实生活中的桥梁，它的存在就是将河流两侧的东西给连接起来，应用到软件里面 Bridge 就是将<strong>类的功能层次结构与实现层次结构</strong>连接起来。</p>
<h2 id="类的功能层次结构-VS-实现层次结构"><a href="#类的功能层次结构-VS-实现层次结构" class="headerlink" title="类的功能层次结构 VS 实现层次结构"></a>类的功能层次结构 VS 实现层次结构</h2><p>这里解释下什么叫做功能层次结构和实现层次结构。比方说，我们有一个类叫做 Abstraction，当我们想在 Abstraction 上增加新的功能时，一般我们会新建一个子类继承 Abstraction，比如叫 RefinedAbstraction 类，新类一般还会增加自定义的一些功能方法，这种就构成了一个简单的类层次结构：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/76y8k.png" alt=""><br>这种层次机构具有如下特点：</p>
<ul>
<li>父类具备基本功能</li>
<li>子类在父类基础上添加新的功能<br>这种就称为 “类的功能层次结构”，当然，当我们继续添加新的功能时，一般我们选择某一功能层级的类然后继承它，在其基础上进行新功能的追加。（类的层级太深反而不好）</li>
</ul>
<p>什么又叫做类的实现层次机构呢？我们都知道抽象类的作用，抽象类一般声明一套接口（API），然后子类继承并实现这套接口，简单来说就是父类定义接口，子类实现接口。这种接口层面的“实现”关系就会产生一套层次结构，比如如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/r1wjb.png" alt=""></p>
<p>这种基于“实现”层级有如下特点：</p>
<ul>
<li>父类声明抽象方法定义相关接口（API）</li>
<li>子类通过具体方法来实现接口（API）</li>
</ul>
<p>这种因“实现”产生的结构层级就叫做“类的实现层级”。</p>
<p>讲了这么多，Bridge 模式就是为了将<strong>类的功能层次结构与实现层次结构连接起来</strong>，充当中间桥梁的作用。</p>
<h2 id="Bridge-模式的-UML-类图"><a href="#Bridge-模式的-UML-类图" class="headerlink" title="Bridge 模式的 UML 类图"></a>Bridge 模式的 UML 类图</h2><p>上面说了那么多，可能有点云里雾里，下面是 Bridge 模式的类图，通过图来理解可能会好一些：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/475pa.png" alt=""></p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>桥接模式中包含了几种角色，分别是：</p>
<ul>
<li>抽象化（Abstraction）：该角色位于属于 “类的功能层次结构” 的最上层，用于定义抽象接口，一般是抽象类而不是抽象接口。其内部往往包含一个实现类接口实例（Implementor），使用委托方式进行内部调用；</li>
<li>改善后的抽象化，或者叫补充抽象类（RefinedAbstraction）：该角色用于补充 Abstraction 功能而存在，通常情况下不再是抽象类而是具体的实现类，在内部可以直接调用 Implementor 中的业务方法；</li>
<li>实现者（Implementor）：该角色位于 “类的实现层次结构” 的最上层，定义了用于实现 Abstraction 角色的接口（API），这里的接口并非要和 Abstraction 中定义的完全一致，Implementor 只对这些接口进行声明，具体实现还是要交给子类。通过委托，在 Abstraction 中，不仅可以调用自己方法，还可以调用到 Implementor 中定义的方法；</li>
<li>具体实现者（ConcreteImplementor）：该角色用于实现 Implementor 角色中定义的接口，不同的实现类提供不同的业务处理方法，程序运行时，ConcreteImplementor 将替换 Abstraction 中的 Implementor，提供给抽象类具体的业务操作方法。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面我们通过一个例子来理解下 Bridge 模式，我们都知道手机品牌有很多，每种手机上面又包含各种各样的软件，我们如何表示“在手机上运行软件”这一活动？手机的品牌和软件是两个维度上的东西，可以类比为上面的“功能层级”和“实现层级”，桥接模式的作用就是将这些不同的实现独立开来，从而应对不断地变化，下面是具体的类图设计：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/s035y.png" alt=""></p>
<p>这里我们定义抽象类 MobilePhoneAbstraction，表示手机抽象类，该类自带 run 方法来 “运行各种软件”，示例代码如下:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneAbstraction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SoftImplementor impl;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MobilePhoneAbstraction</span><span class="params">(SoftImplementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.impl = impl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>MobilePhoneAbstraction 为我们定义的类的功能层次结构的顶层，内部包含对 SoftImplementor 的引用，SoftImplementor 即是我们定义的手机软件的抽象类，示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftImplementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawrun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们声明 rawrun 方法供子类实现，同时又委托给 MobilePhoneAbstraction 供其调用，下面是手机品牌的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HuaWeiMobilePhone</span> <span class="keyword">extends</span> <span class="title">MobilePhoneAbstraction</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HuaWeiMobilePhone</span><span class="params">(SoftImplementor impl)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(impl);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用委托：调用HuaWeiMobilePhone的run时，实际调用的是SoftImplementor的rawrun</span></span><br><span class="line">        <span class="keyword">this</span>.impl.rawrun();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gpuTurborRun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GPU Turbo Running start..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.run();</span><br><span class="line">        System.out.println(<span class="string">"GPU Turbo Running end..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里子类添加自己独特的功能方法”GPU Turbo“ 方法类运行软件，进行 run 调用，可以看到实际调用的是 SoftImplementor 中的 rawrun 方法，该方法为我们自定义实现的基于抽象的 SoftImplementor，接下来看下 SoftImplementor 示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SoftImplementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">rawrun</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里声明 rawrun 接口（API），实现的子类有两个，分别是游戏软件 ——GameSoft，和聊天软件 ——ChatSoft，相关代码分别如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChatSoft</span> <span class="keyword">extends</span> <span class="title">SoftImplementor</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawrun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"ChatSoft rawrun..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameSoft</span> <span class="keyword">extends</span> <span class="title">SoftImplementor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rawrun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"GameSoft rawrun..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MobilePhoneAbstraction m1 = <span class="keyword">new</span> HuaWeiMobilePhone(<span class="keyword">new</span> ChatSoft());</span><br><span class="line"></span><br><span class="line">HuaWeiMobilePhone m2 = <span class="keyword">new</span> HuaWeiMobilePhone(<span class="keyword">new</span> GameSoft());</span><br><span class="line"></span><br><span class="line">m1.run();</span><br><span class="line">m2.run();</span><br><span class="line"></span><br><span class="line">m2.gpuTurborRun();</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ChatSoft rawrun...</span><br><span class="line"></span><br><span class="line">GameSoft rawrun...</span><br><span class="line"></span><br><span class="line">GPU Turbo Running start...</span><br><span class="line">GameSoft rawrun...</span><br><span class="line">GPU Turbo Running end...</span><br></pre></td></tr></table></figure>

<p>由于 m1、m2 都属于 MobilePhoneAbstraction 的类的实例，因此我们可以调用它们的 run 方法，而 m1、m2 又都属于 HuaWeiMobilePhone 的实例，所以我们还能调用其 gpuTurborRun 方法，比如后期我们 run 实现有所变动，那么只需要修改 main 方法和 SoftImplementor 的实现类即可，其它代码就可以保持不动了。</p>
<p>通过 MobilePhoneAbstraction 中的 impl 桥接，就实现了抽象与行为实现的分离，这种就是桥接模式的存在意义。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>桥接模式的优缺点总结如下：</p>
<ul>
<li>抽象与实现相分离：抽象与实现相分离，从而让抽象与实现分别独立开来，分别定义接口，有助于系统分层及产生更好的结构化系统</li>
<li>更好的拓展性：系统拓展时，因为抽象与实现已经分别独立，所以可以进行分别拓展不会相互影响，从而大大提高系统拓展性。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>桥接模式是解决一个系统有多个变化维度的一种设计模式，分离了抽象接口与实现部分，提高了系统的可拓展性，符合开闭原则，相反地，也增加了系统的理解与设计上的复杂性。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/eaf0y.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/posts/22977/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>命令模式（Command Pattern）又称为行动（Action）模式或交易（Transaction）模式。</p>
<a id="more"></a>


<p>命令模式的英文定义是：</p>
<blockquote>
<p>Encapsulate a request as an object, thereby letting you parameterize clients with different requests, queue or log requests, and support undoable operations.</p>
</blockquote>
<p>意思是：将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能。<br>简单来说，命令模式就是将发送者、接收者和调用命令封装成对象，客户端调用的时候可以选择不同的对象，从而实现发送者和接收者的完全解耦。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>命令模式包含如下角色：</p>
<ul>
<li>命令接口（Command）角色：该角色声明一个接口，定义需要执行的命令；</li>
<li>具体命令实现类（Concrete Command）角色：该角色定义一个接收者和行为之间的弱耦合，实现命令方法，并调用接收者的相应操作；</li>
<li>调用者（Invoker）角色：该角色负责调用命令对象执行请求；</li>
<li>接收者（Receiver）角色：该角色负责具体实施和执行请求动作（方法）；</li>
<li>客户端（Client）角色：串连执行整个流程。</li>
</ul>
<p>角色关系类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/j7g5e.png" alt=""></p>
<h2 id="命令模式代码实现"><a href="#命令模式代码实现" class="headerlink" title="命令模式代码实现"></a>命令模式代码实现</h2><h3 id="接收者"><a href="#接收者" class="headerlink" title="接收者"></a>接收者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行业务逻辑"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="命令对象"><a href="#命令对象" class="headerlink" title="命令对象"></a>命令对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体命令类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver.doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="请求者"><a href="#请求者" class="headerlink" title="请求者"></a>请求者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 持有命令对象</span></span><br><span class="line">    <span class="keyword">private</span> Command command;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Invoker</span><span class="params">(Command command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command = command;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 请求方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.command.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建接收者</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver();</span><br><span class="line">        <span class="comment">// 创建命令对象，设定接收者</span></span><br><span class="line">        Command command = <span class="keyword">new</span> ConcreteCommand(receiver);</span><br><span class="line">        <span class="comment">// 创建请求者，把命令对象设置进去</span></span><br><span class="line">        Invoker invoker = <span class="keyword">new</span> Invoker(command);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        invoker.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过代码我们可以看到，命令模式把一条命令分为四步，先定义接收者，再创建执行命令对象，再创建请求者，最后执行命令方法。它的耦合度要比把所有的操作都封装到一个类中要低的多，而这也正是命令模式的精髓所在：<strong>把命令的调用者与执行者分开，使双方不必关心对方是如何操作的。</strong></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>命令模式的优点：</p>
<ul>
<li>类间解耦：调用者角色与接收者角色之间没有任何依赖关系，调用者实现功能时只需要调用 Command 中的 execute() 方法即可，不需要了解是哪个接收者执行；</li>
<li>可扩展性：Command 的子类可以非常容易地扩展，而调用者 Invoker 和高层次的模块 Client 不产生严重的代码耦合。</li>
</ul>
<p>命令模式的缺点：</p>
<ul>
<li>使用命令模式会导致系统有过多的具体命令类，因为针对每一个命令都需要设计一个具体命令类。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>命令模式的典型应用场景如下：</p>
<ul>
<li>系统需要支持命令的撤销（undo），命令对象可以把状态存储起来，等到客户端需要撤销时，可以调用 undo() 方法，将命令所产生的效果撤销；</li>
<li>系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作；</li>
<li>系统需要将一组操作组合在一起，使用命令模式来实现，可以很方便的增加新的命令。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>以生活中的看电视为例，其中遥控器就是命令发送者，电视就是请求接收者，分别对应：开机、关机、切换频道三个命令，实现代码如下。</p>
<h3 id="定义遥控功能（命令接口和实现类）"><a href="#定义遥控功能（命令接口和实现类）" class="headerlink" title="定义遥控功能（命令接口和实现类）"></a>定义遥控功能（命令接口和实现类）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开电视（命令）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OpenTvCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OpenTvCommand</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.open();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 更换电视频道（命令）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChangeTvCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChangeTvCommand</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关闭电视（命令）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CloseTvCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloseTvCommand</span><span class="params">(TV tv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.tv = tv;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接收者（执行命令）"><a href="#接收者（执行命令）" class="headerlink" title="接收者（执行命令）"></a>接收者（执行命令）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电视机的具体动作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TV</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"打开电视机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关闭电视机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"切换电视频道"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="执行者（发起执行命令对象）"><a href="#执行者（发起执行命令对象）" class="headerlink" title="执行者（发起执行命令对象）"></a>执行者（发起执行命令对象）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遥控器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TvRemote</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Command openTvCommand;</span><br><span class="line">    <span class="keyword">private</span> Command closeTvCommand;</span><br><span class="line">    <span class="keyword">private</span> Command changeTvCommand;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TvRemote</span><span class="params">(Command openTvCommand, Command closeTvCommand, Command changeTvCommand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.openTvCommand = openTvCommand;</span><br><span class="line">        <span class="keyword">this</span>.closeTvCommand = closeTvCommand;</span><br><span class="line">        <span class="keyword">this</span>.changeTvCommand = changeTvCommand;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开电视</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        openTvCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭电视</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        closeTvCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 换频道</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       changeTvCommand.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端（调用）"><a href="#客户端（调用）" class="headerlink" title="客户端（调用）"></a>客户端（调用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TV tv = <span class="keyword">new</span> TV();</span><br><span class="line">        Command openTvCommand = <span class="keyword">new</span> OpenTvCommand(tv);</span><br><span class="line">        Command closeTvCommand = <span class="keyword">new</span> CloseTvCommand(tv);</span><br><span class="line">        Command changeTvCommand = <span class="keyword">new</span> ChangeTvCommand(tv);</span><br><span class="line">        TvRemote control = <span class="keyword">new</span> TvRemote(openTvCommand,closeTvCommand,changeTvCommand);</span><br><span class="line">        control.open();</span><br><span class="line">        control.change();</span><br><span class="line">        control.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>命令模式是通过封装命令类来实现解耦调用者（发送命令）和接收者（执行命令），它的优点是可扩展性好，缺点是需要为不同的命令需要制定单独的命令类。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/posts/56455/</url>
    <content><![CDATA[<p>这回我们讲下抽象工厂模式，抽象工厂模式是工厂模式（简单工厂、工厂方法）中最具抽象和一般性的一种形态。抽象工厂模式可以向客户端提供一个接口，使客户端在不必指定产品的具体的情况下，创建多个产品族中的产品对象。</p>
<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>抽象工厂模式的定义：<strong>为创建一组相关或相互依赖的对象提供一个接口，而且无须指定它们的具体类。</strong></p>
<p>通俗一点理解，即对一组具有相同主题的工厂进行封装。比如说：生产一台 PC 机，如果使用工厂方法模式的话，就会有主板工厂、显卡工厂、CPU 工厂等，而使用抽象工厂的话，只会有一个 PC 工厂，而 PC 工厂中又涵盖了主板工厂、显卡工厂、CPU 工厂。所以，工厂方法模式针对的是同一类或同等级产品，而抽象工厂模式针对的是多种类（多等级）的产品设计</p>
<a id="more"></a>


<h2 id="何为产品族"><a href="#何为产品族" class="headerlink" title="何为产品族"></a>何为产品族</h2><p>上面我们讲到一组相关或相互依赖的对象，这个怎么理解？比如，PC 机的主板和显卡就是两个相互依赖的产品线（也叫做产品族）。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/i169r.png" alt=""></p>
<h2 id="模式特点"><a href="#模式特点" class="headerlink" title="模式特点"></a>模式特点</h2><p>抽象工厂模式使用时，一般具有如下特点：</p>
<ul>
<li>系统中有多个产品族，每个具体工厂负责创建同一族但属于不同产品等级（产品种类）的产品</li>
<li>系统一次只能消费某一族产品，即相同产品族的产品是一起被使用的</li>
</ul>
<p>当系统需要新增一个产品族时，只需要增加新的工厂类即可，无需修改源代码；但是如果需要产品族中增加一个新种类的产品时，则所有的工厂类都需要修改。</p>
<p><strong>抽象工厂模式中的抽象工厂类的职责就是定义每个工厂要实现的功能，即定义多个产品族的产品的创建。这里，同一产品族下有多个产品时，对应的抽象工厂就会有多个抽象方法用来提供创建这些产品的接口。</strong></p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>抽象工厂一般包含四种角色，分别是：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，包含多个创建产品的方法，即包含多个类似 new Product () 的方法；</li>
<li>具体工厂（Concrete Factory）：实现抽象工厂定义的接口，完成某个具体产品的创建；</li>
<li>抽象产品（Abstract Product）：抽象产品定义，一般有多少抽象产品，抽象工厂中就包含多少个创建产品的方法；</li>
<li>具体产品（Concrete Product）：抽象产品的实现类。</li>
</ul>
<p>实现抽象产品所定义的接口，和具体工厂是多对一的关系：</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>这里继续以上面的冰箱、电视为例进行说明，其结构图如下所示：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/wwylz.png" alt=""></p>
<p>本例中，使用抽象工厂模式来设计两个工厂，一个是 TCL 厂另一个是美的厂，分别用来生产 TCL 和美的的电视、冰箱这两种产品，工厂类中使用 newTelevision()、newRefrigerator() 分别表示对其的创建。</p>
<p>程序代码如下，先是抽象工厂定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function">Television <span class="title">newTelevision</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Refrigerator <span class="title">newRefrigerator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是两个抽象产品：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再就是两个具体工厂类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Television <span class="title">newTelevision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCLTelevision();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Refrigerator <span class="title">newRefrigerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> TCLRefrigerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiDFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Television <span class="title">newTelevision</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MeiDTelevision();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Refrigerator <span class="title">newRefrigerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MeiDRefrigerator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，是四个具体的产品类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLTelevision</span> <span class="keyword">implements</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是TCL电视机，我可以看电视"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiDTelevision</span> <span class="keyword">implements</span> <span class="title">Television</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是美的电视机，我可以看电视"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCLRefrigerator</span> <span class="keyword">implements</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是TCL冰箱，我可以洗衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiDRefrigerator</span> <span class="keyword">implements</span> <span class="title">Refrigerator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dosomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我是美的冰箱，我可以洗衣服"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面，就是我们的测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Factory factory = <span class="keyword">new</span> TCLFactory();</span><br><span class="line">        Television television = factory.newTelevision();</span><br><span class="line">        Refrigerator refrigerator = factory.newRefrigerator();</span><br><span class="line"></span><br><span class="line">        television.dosomething(); <span class="comment">// 我是TCL电视机，我可以看电视</span></span><br><span class="line">        refrigerator.dosomething(); <span class="comment">// 我是TCL冰箱，我可以洗衣服</span></span><br><span class="line"></span><br><span class="line">        factory = <span class="keyword">new</span> MeiDFactory();</span><br><span class="line">        television = factory.newTelevision();</span><br><span class="line">        refrigerator = factory.newRefrigerator();</span><br><span class="line"></span><br><span class="line">        television.dosomething(); <span class="comment">// 我是美的电视机，我可以看电视</span></span><br><span class="line">        refrigerator.dosomething(); <span class="comment">// 我是美的冰箱，我可以洗衣服</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="模块拓展"><a href="#模块拓展" class="headerlink" title="模块拓展"></a>模块拓展</h2><p>假设某一天，我们要新增一个产品族，比如加一个海尔的电视机和冰箱，这时的做法就是直接新增一个海尔工厂，新增后的结构图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/z0ljg.png" alt=""><br>这个时候，就很好的体现了开闭原则，对修改关闭，对拓展开放，不需要修改源代码即可实现功能拓展。</p>
<p>当产品族中需要增加一个新种类的产品时，比如新增产品 “风扇”，新的结构图简单罗列如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/s7de0.png" alt=""></p>
<p>由图中可以清晰看到，当需要增加一个新的产品时，所有的工厂类都需要进行修改，不满足开闭原则。所以，这也是抽象工厂的一个弊端。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节主要介绍了抽象工厂模式的概念、特点，以及产品族的概念，另外说明了抽象工厂模式的通用设计类图，优缺点等，大家可以好好理解下。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/mqjx3.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>模板模式</title>
    <url>/posts/14568/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>模板模式（Template Pattern）又被称作模板方法模式（Template Method Pattern），它是一种简单的、常见的且应用非常广泛的模式。</p>
<a id="more"></a>

<blockquote>
<p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p>
</blockquote>
<p>意思是：定义一个操作中的算法的框架，而将一些步骤延迟到子类中。使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<p>简单来说，就是为子类设计一个模板，以便在子类中可以复用这些方法。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>模板模式包含如下角色：</p>
<ul>
<li>抽象模板（Abstract Template）角色：该角色定义一个或多个抽象操作，以便让子类实现；这些抽象操作是基本操作，是一个顶级逻辑的组成步骤，该角色还需要定义一个或几个模板方法（模板方法的介绍，请看下文）；</li>
<li>具体模板（Concrete Template）角色：该角色实现抽象模板中定义的一个或多个抽象方法，每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法的不同实现，从而使得顶级逻辑的实现各不相同。</li>
</ul>
<p>角色之间的 UML 关系图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ewr01.jpg" alt=""></p>
<h2 id="模板模式代码实现"><a href="#模板模式代码实现" class="headerlink" title="模板模式代码实现"></a>模板模式代码实现</h2><h3 id="抽象模板"><a href="#抽象模板" class="headerlink" title="抽象模板"></a>抽象模板</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象模板</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//（所有）基本方法</span></span><br><span class="line">        abstractMethod();</span><br><span class="line">        hookMethod();</span><br><span class="line">        concreteMethod();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抽象方法，必须有子类实现</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 钩子方法，子类可以选择重写或不重写</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">hookMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 具体方法，子类不可修改</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">concreteMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"抽象类中的具体方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="具体模板-A"><a href="#具体模板-A" class="headerlink" title="具体模板 A"></a>具体模板 A</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体模板 A 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplateA</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"A 子类中重写的抽象方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="具体模板-B"><a href="#具体模板-B" class="headerlink" title="具体模板 B"></a>具体模板 B</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体模板 B 类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteTemplateB</span> <span class="keyword">extends</span> <span class="title">AbstractTemplate</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">abstractMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"B 子类中重写的抽象方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractTemplate tp = <span class="keyword">new</span> ConcreteTemplateA();</span><br><span class="line">        <span class="comment">// 调用子类 A 的模板方法</span></span><br><span class="line">        tp.templateMethod();</span><br><span class="line">        tp = <span class="keyword">new</span> ConcreteTemplateB();</span><br><span class="line">        <span class="comment">// 调用子类 B 的模板方法</span></span><br><span class="line">        tp.templateMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A 子类中重写的抽象方法</span><br><span class="line"></span><br><span class="line">抽象类中的具体方法</span><br><span class="line"></span><br><span class="line">B 子类中重写的抽象方法</span><br><span class="line"></span><br><span class="line">抽象类中的具体方法</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，在模板模式中，方法分为两类：模版方法和基本方法，而基本方法又分为：抽象方法，具体方法，钩子方法。</p>
<ul>
<li>抽象方法：一个抽象方法由抽象类声明，由具体子类实现。在 Java 语言里抽象方法以 abstract 关键字声明；</li>
<li>具体方法：一个具体方法由抽象类声明并实现，而子类并不能修改或重写，此方法通常会被声明为 final；</li>
<li>钩子方法：在抽象类中预留一个 “钩子”，也就是实现一个空方法，作为方法的默认实现，子类可以选择重写（重新构建）或者不重写。</li>
</ul>
<blockquote>
<p>小贴士：一个模板方法是定义在抽象类中的，把基本操作方法组合在一起形成一个总算法或一个总行为的方法。<br>一个抽象类可以有任意多个模板方法，而不限于一个，每一个模板方法都可以调用任意多个具体方法。</p>
</blockquote>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>模板模式的优点：</p>
<ul>
<li>提高了代码的复用性，将相同部分的代码放在抽象的父类中；</li>
<li>提高了拓展性：将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为；</li>
<li>符合开闭原则：行为由父类控制，通过子类扩展新的行为。</li>
</ul>
<p>模板模式的缺点：</p>
<ul>
<li>每个不同的行为都要新增一个子类来完成，抽象类中的抽象方法越多，子类增加成本就越高。而且新增的子类越多，系统就越复杂。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>模板模式的典型应用场景如下：</p>
<ul>
<li>多个子类有公共方法，并且逻辑基本相同时；</li>
<li>可以把重要的、复杂的、核心算法设计为模板方法，其他的相关细节功能则由各个子类实现；</li>
<li>重构时，模板方法模式是一个经常使用的模式，把相同的代码抽取到父类中，然后通过钩子函数约束其行为。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>以生活中上班的过程为例，我们上班的通常流程是：起床洗漱 -&gt; 通勤（开车、坐公交、打车） -&gt; 到达公司。从以上步骤可以看出，只有通勤部分是不一样的，其他都一样，因为开车可能会被限号，就只能打车或坐公交去公司了，下面我们用代码（模板模式）来实现一下。</p>
<h3 id="上班抽象类"><a href="#上班抽象类" class="headerlink" title="上班抽象类"></a>上班抽象类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 上班抽象（模板）类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractWork</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 模板方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">gotoWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getup();</span><br><span class="line">        commute();</span><br><span class="line">        arrive();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 起床洗漱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"1.起床洗漱"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通勤</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">commute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 到达公司</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">arrive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3.到达公司"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="开车上班"><a href="#开车上班" class="headerlink" title="开车上班"></a>开车上班</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 开车上班</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DriveToWork</span> <span class="keyword">extends</span> <span class="title">AbstractWork</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2.开车去公司"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="坐公交上班"><a href="#坐公交上班" class="headerlink" title="坐公交上班"></a>坐公交上班</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 坐公交上班</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BusToWork</span> <span class="keyword">extends</span> <span class="title">AbstractWork</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"2.坐公交去公司"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractWork work = <span class="keyword">new</span> DriveToWork();</span><br><span class="line">        <span class="comment">// 开车上班</span></span><br><span class="line">        work.gotoWork();</span><br><span class="line">        work = <span class="keyword">new</span> BusToWork();</span><br><span class="line">        <span class="comment">// 坐公交上班</span></span><br><span class="line">        work.gotoWork();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>. 起床洗漱</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 开车去公司</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 到达公司</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 起床洗漱</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 坐公交去公司</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 到达公司</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>模板模式的精髓是复用抽象类中的公共方法，重写抽象类中的基础（抽象）方法，选择性使用抽象类中的钩子（hook Method）方法。使用模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>空对象模式</title>
    <url>/posts/31880/</url>
    <content><![CDATA[<p>受 GOF（Gang of Four，四人组）《设计模式》一书的影响，让人误以为设计模式只有 23 种，其实不然，除了《设计模式》介绍的 23 种设计模式外，还有很多经典的设计模式，例如我们本文将要介绍的空对象模式。</p>
<a id="more"></a>


<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>在空对象模式（Null Object Pattern）中，一个空对象取代 NULL 对象实例的检查。</p>
<p>英文定义如下：</p>
<blockquote>
<p>Provide an object as a surrogate for the lack of an object of a given type. The Null Object provides intelligent do nothing behavior, hiding the details from its collaborators.<br>意思是：为缺少的对象提供一个默认的无意义对象，用来避免 Null 对象的产生。</p>
</blockquote>
<p>简单来说，就是用一个空对象，来取代程序中的 Null 值判断，从而让调用者可以直接使用对象，而无需关心对象是否为 Null。</p>
<p>例如，在没用空对象模式之前，要正确的获取以下值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String isocode = user.getAddress().getCountry().getIsocode().toUpperCase();</span><br></pre></td></tr></table></figure>

<p>它的实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (user != <span class="keyword">null</span>) &#123;(img)</span><br><span class="line">    Address address = user.getAddress();</span><br><span class="line">    <span class="keyword">if</span> (address != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Country country = address.getCountry();</span><br><span class="line">        <span class="keyword">if</span> (country != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String isocode = country.getIsocode();</span><br><span class="line">            <span class="keyword">if</span> (isocode != <span class="keyword">null</span>) &#123;</span><br><span class="line">                isocode = isocode.toUpperCase();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非空判断已经多到令我们崩溃了，如果属性中还有更多的对象，那 Null 值判断就更多了，为了解决这个问题，就要使用本文将要介绍的空对象模式了。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>空对象模式包含如下角色：</p>
<ul>
<li>抽象对象（Abstract Object）角色：声明统一的对象行为（属性和方法）；</li>
<li>具体对象（Concrete Object）角色：确实存在的具体对象，程序中的非 Null 对象；</li>
<li>空对象（Null Object）角色：非具体存在的对象，Null 对象；</li>
<li>对象工厂（Object Factory）角色：根据传递的标识得到相关类的工厂类，返回值可以是具体对象或 Null 对象。</li>
</ul>
<p>角色之间的 UML 关系图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/c277h.png" alt=""></p>
<h2 id="观察者模式代码实现"><a href="#观察者模式代码实现" class="headerlink" title="观察者模式代码实现"></a>观察者模式代码实现</h2><h3 id="抽象对象"><a href="#抽象对象" class="headerlink" title="抽象对象"></a>抽象对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体对象"><a href="#具体对象" class="headerlink" title="具体对象"></a>具体对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteObject</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空对象"><a href="#空对象" class="headerlink" title="空对象"></a>空对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullObject</span> <span class="keyword">extends</span> <span class="title">AbstractObject</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Not Available in Customer Database"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象工厂"><a href="#对象工厂" class="headerlink" title="对象工厂"></a>对象工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象生成工厂</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractObject <span class="title">creator</span><span class="params">(<span class="keyword">final</span> String name)</span> </span>&#123;</span><br><span class="line">        AbstractObject result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (name) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"Java"</span>:</span><br><span class="line">                result = <span class="keyword">new</span> ConcreteObject(<span class="string">"Java"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"SQL"</span>:</span><br><span class="line">                result = <span class="keyword">new</span> ConcreteObject(<span class="string">"SQL"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="keyword">new</span> NullObject();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"></span><br><span class="line">Not Available in Customer Database</span><br><span class="line"></span><br><span class="line">SQL</span><br></pre></td></tr></table></figure>
<p>从以上的代码可以看出，其中 getName () 为所有对象需要执行的公共方法，如果没使用空对象模式的情况下，每次在调用 getName () 之前，我们需要先判空再使用，而如果使用的是空对象模式的话，则可以直接使用（该方法）。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>空对象模式的优点：</p>
<ul>
<li>省去代码中对 Null 值的判断和检查；</li>
<li>让代码显的更加优雅和可读性更高；</li>
<li>让系统更加稳定，避免程序抛出 NullPointerException 异常。<br>空对象模式的缺点：</li>
<li>因为增加了更多的类信息，从而使系统更复杂。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>JDK 8 中的 Optional 对象使用的就是空对象模式，避免空指针的异常，同时又能写出优雅而简洁的 Java 代码。<br>Optional 类中有以下几个重要的方法：</p>
<ul>
<li>ofNullable () 方法：为指定的值创建一个 Optional, 如果指定的值为 null，则返回一个空的 Optional 对象；</li>
<li>orElse () 方法：如果有值则将其返回，否则返回指定的其它值；</li>
<li>map () 方法：如果创建的 Optional 中的值存在，对该值执行提供的 Function 函数调用；</li>
<li>flagMap () 方法：如果创建的 Optional 中的值存在，就对该值执行提供的 Function 函数调用，返回一个 Optional 类型的值，否则就返回一个空的 Optional 对象。</li>
</ul>
<blockquote>
<p>小贴士：很多人可能对 “对该值执行提供的 Function 函数调用” 这句话不太理解，它的意思是说，例如下面代码：<br>Optional.ofNullable(concreteUser).flatMap(u -&gt; u.getAddress())<br>其中 “(u -&gt; u.getAddress ())” 这部分代码就是 “该值执行提供的 Function 函数”。</p>
</blockquote>
<p>接下来我们就是用 Optional 对象，优雅的实现判空操作，优雅的实现文章开头 4 层令人崩溃的 Null 值判断，实现代码如下。</p>
<h3 id="用户类"><a href="#用户类" class="headerlink" title="用户类"></a>用户类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用户类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Address&gt; <span class="title">getAddress</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(address);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAddress</span><span class="params">(Address address)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="地址类"><a href="#地址类" class="headerlink" title="地址类"></a>地址类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 地址类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Address</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Address</span><span class="params">(Country country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Country country;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Optional&lt;Country&gt; <span class="title">getCountry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.ofNullable(country);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCountry</span><span class="params">(Country country)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.country = country;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="国际编码类"><a href="#国际编码类" class="headerlink" title="国际编码类"></a>国际编码类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 国际编码类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Country</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Country</span><span class="params">(String isocode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isocode = isocode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String isocode;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getIsocode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isocode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setIsocode</span><span class="params">(String isocode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isocode = isocode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// JDK 8 Optional 对象判空示例</span></span><br><span class="line">        <span class="comment">// 具体对象</span></span><br><span class="line">        User concreteUser = <span class="keyword">new</span> User(<span class="keyword">new</span> Address(<span class="keyword">new</span> Country(<span class="string">"china"</span>)));</span><br><span class="line">        <span class="comment">// 空对象</span></span><br><span class="line">        User nullUser = <span class="keyword">new</span> User(<span class="keyword">null</span>);</span><br><span class="line">        <span class="comment">// 具体对象编码获取</span></span><br><span class="line">        String concreteIsocode = Optional.ofNullable(concreteUser)</span><br><span class="line">                .flatMap(u -&gt; u.getAddress())</span><br><span class="line">                .flatMap(a -&gt; a.getCountry())</span><br><span class="line">                .map(c -&gt; c.getIsocode())</span><br><span class="line">                .orElse(<span class="string">"暂无"</span>).toUpperCase();</span><br><span class="line">        <span class="comment">// 空对象编码获取</span></span><br><span class="line">        String nullIsocode = Optional.ofNullable(nullUser)</span><br><span class="line">                .flatMap(u -&gt; u.getAddress())</span><br><span class="line">                .flatMap(a -&gt; a.getCountry())</span><br><span class="line">                .map(c -&gt; c.getIsocode())</span><br><span class="line">                .orElse(<span class="string">"暂无"</span>).toUpperCase();</span><br><span class="line">        System.out.println(<span class="string">"Concrete User："</span> + concreteIsocode);</span><br><span class="line">        System.out.println(<span class="string">"Null User："</span> + nullIsocode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序直接结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Concrete User：CHINA</span><br><span class="line"></span><br><span class="line">Null User：暂无</span><br></pre></td></tr></table></figure>

<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>以生活中场景为例，例如，在一个小商店里，售货员可以根据商品的编码，得到商品的具体名称和价格等信息，实现代码如下。</p>
<h3 id="抽象商品类"><a href="#抽象商品类" class="headerlink" title="抽象商品类"></a>抽象商品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象商品类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGoods</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String isbn; <span class="comment">// 商品编码</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Double price;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体商品类"><a href="#具体商品类" class="headerlink" title="具体商品类"></a>具体商品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体商品</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteGoods</span> <span class="keyword">extends</span> <span class="title">AbstractGoods</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteGoods</span><span class="params">(String isbn, String name, Double price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.isbn = isbn;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"商品名："</span> + <span class="keyword">this</span>.name + <span class="string">"，价格："</span> + <span class="keyword">this</span>.price + <span class="string">"元"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空商品类"><a href="#空商品类" class="headerlink" title="空商品类"></a>空商品类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 空商品类</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NullGoods</span> <span class="keyword">extends</span> <span class="title">AbstractGoods</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"商品信息暂无！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="商品工厂"><a href="#商品工厂" class="headerlink" title="商品工厂"></a>商品工厂</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 商品查询工厂</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GoodsFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractGoods <span class="title">find</span><span class="params">(<span class="keyword">final</span> String isbn)</span> </span>&#123;</span><br><span class="line">        AbstractGoods result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (isbn) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"001"</span>:</span><br><span class="line">                result = <span class="keyword">new</span> ConcreteGoods(<span class="string">"001"</span>, <span class="string">"Java面试全解析"</span>, <span class="number">69.0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"002"</span>:</span><br><span class="line">                result = <span class="keyword">new</span> ConcreteGoods(<span class="string">"002"</span>, <span class="string">"MySQL面试金典"</span>, <span class="number">19.0</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                result = <span class="keyword">new</span> NullGoods();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端调用-1"><a href="#客户端调用-1" class="headerlink" title="客户端调用"></a>客户端调用</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">final</span> String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractGoods goods1 = GoodsFactory.find(<span class="string">"001"</span>);</span><br><span class="line">        <span class="keyword">final</span> AbstractGoods goods2 = GoodsFactory.find(<span class="string">"003"</span>);</span><br><span class="line">        goods1.show();</span><br><span class="line">        goods2.show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">商品名：Java 面试全解析，价格：<span class="number">69.0</span> 元</span><br><span class="line"></span><br><span class="line">商品信息暂无！</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在 Java 语言中，解决 NullPointerException 异常的常见方法是使用空对象模式，空对象模式可以省去代码中对 Null 值的判断，从而使代码更加的简洁和优雅。在 JDK 8 之后，Java API 给我们提供了 Optional 类，使用它可以优雅且有效的，规避空对象产生 NullPointerException 的问题。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/posts/58639/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>策略模式（Strategy Pattern：Define a family of algorithms,encapsulate each one,and make them interchangeable.）中文解释为：定义一组算法，然后将这些算法封装起来，以便它们之间可以互换，属于一种对象行为型模式。总的来说策略模式是一种比较简单的模式，听起来可能有点费劲，其实就是定义一组通用算法的上层接口，各个算法实现类实现该算法接口，封装模块使用类似于 Context 的概念，Context 暴漏一组接口，Context 内部接口委托到抽象算法层。</p>
<a id="more"></a>


<p>大家在实际编程中，可能会用到 TreeSet 这种对象，TreeSet 构造时可以传入一个排序实现类以便指定集合元素被遍历时的顺序，当然不传使用默认的自然排序，如下，我们定义一个 TreeSet 并指定排序规则为自然排序的逆序：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">TreeSet&lt;String&gt; treeSet = <span class="keyword">new</span> TreeSet&lt;&gt;(<span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用自然排序的逆序排列</span></span><br><span class="line">        <span class="keyword">return</span> o2.compareTo(o1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">treeSet.add(<span class="string">"lily"</span>);</span><br><span class="line">treeSet.add(<span class="string">"yerkim"</span>);</span><br><span class="line">treeSet.add(<span class="string">"admin"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (String s : treeSet) &#123;</span><br><span class="line">    System.out.println(s); <span class="comment">// yerkim lily admin</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果比较明显，依次打印：yerkim lily admin，为什么要提到 TreeSet 这种数据结构，其实策略模式有点类似这种，我们上面所说的通用算法接口就好比 compare 接口，具体算法实现类就好比我们上面自行实现的排序类，而所谓的 Context 就好比一个调用入口，隔离底层算法实现。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>策略模式的通用类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/qw4dk.jpg" alt=""></p>
<p>包含的角色罗列如下：</p>
<ul>
<li>上下文角色（Context）：该角色一般是一个实现类或者封装类，起到一定的封装及隔离作用，实际接受请求并将请求委托给实际的算法实现类处理，避免外界对底层策略的直接访问;</li>
<li>抽象策略角色（Strategy）：该角色一般是一个抽象角色，为接口或者抽象类扮演，定义具体策略角色的公共接口；</li>
<li>具体策略角色（ConcreteStrategy）：实现抽象策略角色的接口，为策略的具体实现类。</li>
</ul>
<h2 id="策略模式代码实现"><a href="#策略模式代码实现" class="headerlink" title="策略模式代码实现"></a>策略模式代码实现</h2><p>上文中的类图我们来看下如下用代码实现：<br>首先是抽象策略角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象策略角色</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是具体策略角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体策略角色1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy1</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体策略角色2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategy2</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"具体策略2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们上下文角色，比较简单，直接贴代码了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Strategy strategy = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(Strategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy.algorithmInterface();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>策略模式的优点如下：</p>
<ul>
<li>所有策略放入一组抽象策略接口中，方便统一管理与实现；<br>策略模式的缺点如下：</li>
<li>策略模式每种策略都是单独类，策略很多时策略实现类也很可观；</li>
<li>客户端初始化 Context 的时候需要指定策略类，这样就要求客户端要熟悉各个策略，对调用方要求较高。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>策略模式的应用场景如下：</p>
<ul>
<li>需要自由切换算法的场景</li>
<li>需要屏蔽算法实现细节的场景</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>还是拿我们最上面的排序为例进行说明，对于一个 List 的字符串集合，我们使用不同的排序策略，比如自然排序、逆序两种策略，注意我们这里把排序规则称之为一种排序策略或算法实现，首先是要定义我们的抽象策略角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 字符串的抽象排序策略</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IStringSortStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function">List&lt;String&gt; <span class="title">sort</span><span class="params">(List&lt;String&gt; list)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我们只定义了一个排序的策略接口，入参出参均是字符串列表，下面看看该策略的两种实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 排序策略——正序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSortStrategyNormal</span> <span class="keyword">implements</span> <span class="title">IStringSortStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 排序策略——倒序</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSortStrategyReverse</span> <span class="keyword">implements</span> <span class="title">IStringSortStrategy</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">sort</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        Collections.reverse(list);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是我们的上下文角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringSortContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IStringSortStrategy strategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringSortContext</span><span class="params">(IStringSortStrategy strategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.strategy = strategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取排序结果</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getSortList</span><span class="params">(List&lt;String&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.strategy.sort(list);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上下文角色中定义了一个外部调用的 api 接口 getSortList，这样我们只需要初始化 StringSortContext 的时候指定排序策略，再调用 getSortList 即可获取排序结果，具体的排序策略如何实现对客户端是不可见的。测试类就是我们的 main 方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="string">"admin"</span>);</span><br><span class="line">list.add(<span class="string">"code-shop"</span>);</span><br><span class="line">list.add(<span class="string">"lucy"</span>);</span><br><span class="line"></span><br><span class="line">StringSortContext context = <span class="keyword">new</span> StringSortContext(<span class="keyword">new</span> StringSortStrategyReverse());</span><br><span class="line">List&lt;String&gt; reverseSortedList = context.getSortList(list);</span><br><span class="line">System.out.println(reverseSortedList); <span class="comment">// [lucy, code-shop, admin]</span></span><br><span class="line"></span><br><span class="line">StringSortContext context2 = <span class="keyword">new</span> StringSortContext(<span class="keyword">new</span> StringSortStrategyNormal());</span><br><span class="line">List&lt;String&gt; normalSortedList = context2.getSortList(list);</span><br><span class="line">System.out.println(normalSortedList); <span class="comment">// [admin, code-shop, lucy]</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节我们介绍了策略模式，总的来说比较简单，重点在于策略的切换，虽然说具体策略的实现如何客户端是不可见的，但是客户端进行初始化 Context 上下文角色的时候需要明确知晓系统有多少策略，这就对客户端要求较高了。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/2c39z.jpg" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/posts/39447/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>状态模式（Allow an object to alter its behavior when its internal state changes.The object will appear to change its class.）翻译过来就是：允许一个对象在其内部状态改变时改变其行为，这个对象看起来好像是改变了其类。状态模式是一种对象行为型模式。</p>
<a id="more"></a>


<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>状态模式的通用类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/81e2u.png" alt=""></p>
<p>状态模式包含角色如下：</p>
<ul>
<li>上下文角色（Context）：上下文角色一般是一个类，上下文角色会聚合很多和 state，这些 state 使用静态常量修饰，并且负责 state 的状态切换；另外上下文角色还会包含抽象状态角色中定义的所有行为如 request，然后内部将请求委托给 state 的 handle 处理；</li>
<li>抽象状态角色（State）：抽象状态角色一般是一个抽象类，用来定义具体状态的公共行为比如 handle，任何具体状态都必须实现该抽象类中的抽象方法；</li>
<li>具体状态角色（ConcreteState）：继承抽象状态角色，实现抽象方法，实际处理来自 Context 的委托请求，当 Context 改变状态时行为也跟着改变。</li>
</ul>
<h2 id="状态模式代码实现"><a href="#状态模式代码实现" class="headerlink" title="状态模式代码实现"></a>状态模式代码实现</h2><p>状态模式的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象状态角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上下文角色，负责状态切换</span></span><br><span class="line">    <span class="keyword">protected</span> Ctx context;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Ctx context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 状态的公共行为，需要子类自行实现其状态对应的行为</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体状态1</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState1</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本状态ConcreteState1时的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置当前状态为state2</span></span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Ctx.state2);</span><br><span class="line">        <span class="keyword">super</span>.context.request2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 具体状态2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteState2</span> <span class="keyword">extends</span> <span class="title">State</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.context.setCurrentState(Ctx.state1);</span><br><span class="line">        <span class="keyword">super</span>.context.request1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handle2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 本状态ConcreteState2时的业务逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ctx</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 上下文角色一般会包含全部状态，使用静态常量修饰</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State state1 = <span class="keyword">new</span> ConcreteState1();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> State state2 = <span class="keyword">new</span> ConcreteState2();</span><br><span class="line">    <span class="comment">// 定义上下文保存的当前状态</span></span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(State currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">        <span class="comment">// 初始化state中的上下文</span></span><br><span class="line">        <span class="keyword">this</span>.currentState.setContext(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上下文一般包含抽象状态中的所有行为，然后委托给state</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.handle1();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.handle2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试方法一般如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Ctx context = <span class="keyword">new</span> Ctx(); <span class="comment">// 新建一个上下文</span></span><br><span class="line">context.setCurrentState(<span class="keyword">new</span> ConcreteState1()); <span class="comment">// 设置当前状态</span></span><br><span class="line">context.request1(); <span class="comment">// 调用request动作</span></span><br><span class="line">context.request2();</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>状态模式的优缺点总结如下：</p>
<ul>
<li>减少代码体积，利于拓展：状态模式可以消除繁杂的条件判断语句块，使得业务逻辑清晰，很好地应对对象状态的增加、删除的业务场景，因为添加新的状态只需要增加新的状态类就好了；</li>
<li>状态模式状态很多时会导致状态类比较多，子类太多的时候就不方便维护管理了。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>状态模式的应用场景如下：</p>
<ul>
<li>行为随状态改变而改变的场景；</li>
<li>化繁为简，如果代码中包含大量的条件语句块比如 switch…case、if 等，这些语句块的出现会导致业务逻辑变更时代码块也会变更，对状态的增加、删除时的调整修改起来比较吃力时就可以考虑状态模式；</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="不引入状态模式时"><a href="#不引入状态模式时" class="headerlink" title="不引入状态模式时"></a>不引入状态模式时</h3><p>状态模式的重点在于状态切换，往往一个对象的内部状态发生变化时，该对象的具体行为也会发生改变，开起来就像对象的状态在控制着行为的变化一样。比如我们家里熟悉的电视机，其状态可以分为待机、关机以及正常播放三种状态，各个状态下对应的行为用下表描述如下</p>
<table>
<thead>
<tr>
<th></th>
<th>开机</th>
<th>关机</th>
<th>播放</th>
<th>待机</th>
</tr>
</thead>
<tbody><tr>
<td>待机状态</td>
<td></td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>关机状态</td>
<td>√</td>
<td></td>
<td></td>
<td>√</td>
</tr>
<tr>
<td>播放状态</td>
<td></td>
<td>√</td>
<td></td>
<td>√</td>
</tr>
</tbody></table>
<p>如上表格，我们将电视机的状态以及各个状态可以进行的行为罗列了下（其中√代表可以进行的行为，空白代表不可以进行或者进行了无效果的行为），假设我们有一个电视机对象，当然首先是定义一个电视机的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个电视机接口</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ITelevision</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 待机</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来就是我们的电视机的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电视机的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Telev</span> <span class="keyword">implements</span> <span class="title">ITelevision</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开机..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关机..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"播放..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"待机..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没错，这里我们只是简单的实现了下接口中的各个行为，我们在 main 方法中模拟电视机进行下测试：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ITelevision tv = <span class="keyword">new</span> Telev();</span><br><span class="line">    tv.powerOn();</span><br><span class="line">    tv.play();</span><br><span class="line">    tv.standby();</span><br><span class="line">    tv.powerOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行效果相比大家都知道了吧，上述测试输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">开机...</span><br><span class="line">播放...</span><br><span class="line">待机...</span><br><span class="line">关机...</span><br></pre></td></tr></table></figure>

<p>但是我们一开始也说了，电视机的各个行为是在其状态约束下才有的，比如待机行为，你总不能在电视机正处于关机状态直接按遥控器待机吧。这里我们将上面的代码进行下改造，在电视机中加入其状态，以便我们的行为可以根据状态进行一些操作，首先定义一个表示电视机对象状态的枚举 TVStateEnum：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个电视机状态的枚举</span></span><br><span class="line"><span class="keyword">enum</span> TVStateEnum &#123;</span><br><span class="line">    <span class="comment">// 分别定义待机、关机、播放三种状态</span></span><br><span class="line">    STANDBY_STATE(<span class="number">1</span>), POWER_OFF_STATE(<span class="number">2</span>), PLAY_STATE(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> state;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TVStateEnum</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们在电视机对象中引入电视机状态的概念，同时修改我们的行为逻辑，在内部加入状态判断，修改下电视机类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 电视机的实现类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Telev</span> <span class="keyword">implements</span> <span class="title">ITelevision</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里加入电视机的状态字段，构造中传入</span></span><br><span class="line">    <span class="keyword">private</span> TVStateEnum state;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Telev</span><span class="params">(TVStateEnum state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TVStateEnum <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(TVStateEnum state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="comment">// 待机状态</span></span><br><span class="line">            <span class="keyword">case</span> STANDBY_STATE:</span><br><span class="line">                <span class="comment">// 待机状态进行开机，没有任何效果，所以这里什么也不做，以下同理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 关机状态</span></span><br><span class="line">            <span class="keyword">case</span> POWER_OFF_STATE:</span><br><span class="line">                <span class="comment">// 关机状态进行开机，是允许的，开机之后默认属于standby待机状态</span></span><br><span class="line">                System.out.println(<span class="string">"开机..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(TVStateEnum.STANDBY_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 播放状态</span></span><br><span class="line">            <span class="keyword">case</span> PLAY_STATE:</span><br><span class="line">                <span class="comment">// 播放状态进行开机，没有任何效果，所以这里什么也不做，以下同理</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="comment">// 待机状态 &amp; 播放状态 都可以进行关机操作</span></span><br><span class="line">            <span class="keyword">case</span> STANDBY_STATE:</span><br><span class="line">            <span class="keyword">case</span> PLAY_STATE:</span><br><span class="line">                System.out.println(<span class="string">"关机..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(TVStateEnum.POWER_OFF_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 关机状态</span></span><br><span class="line">            <span class="keyword">case</span> POWER_OFF_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="comment">// 待机状态</span></span><br><span class="line">            <span class="keyword">case</span> STANDBY_STATE:</span><br><span class="line">                System.out.println(<span class="string">"播放..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(TVStateEnum.PLAY_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 关机状态</span></span><br><span class="line">            <span class="keyword">case</span> POWER_OFF_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 播放状态</span></span><br><span class="line">            <span class="keyword">case</span> PLAY_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 待机</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.state) &#123;</span><br><span class="line">            <span class="comment">// 待机状态</span></span><br><span class="line">            <span class="keyword">case</span> STANDBY_STATE:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 关机状态</span></span><br><span class="line">            <span class="keyword">case</span> POWER_OFF_STATE:</span><br><span class="line">                System.out.println(<span class="string">"关机..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(TVStateEnum.POWER_OFF_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 播放状态</span></span><br><span class="line">            <span class="keyword">case</span> PLAY_STATE:</span><br><span class="line">                System.out.println(<span class="string">"待机..."</span>);</span><br><span class="line">                <span class="keyword">this</span>.setState(TVStateEnum.STANDBY_STATE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的电视机的行为中，我们加入了电视机状态的判断，使用了冗长的 switch…case 语句，目的就是控制电视机对象的行为不至于脱离其状态而随意执行，当然测试代码也要同步修改下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    ITelevision tv = <span class="keyword">new</span> Telev(TVStateEnum.POWER_OFF_STATE);</span><br><span class="line">    tv.play(); <span class="comment">// 如果直接进行播放的话，因为电视机处于待机状态，所以没有任何输出</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 必须先开机，才能播放</span></span><br><span class="line">    tv.powerOn();</span><br><span class="line">    tv.play();</span><br><span class="line">    tv.standby();</span><br><span class="line">    tv.powerOff();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，加入了状态判断之后，如果直接调用 play 的话是不被允许的，因为电视机的默认状态是关机，上述测试输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">开机...</span><br><span class="line">播放...</span><br><span class="line">待机...</span><br><span class="line">关机...</span><br></pre></td></tr></table></figure>

<h3 id="引入状态模式"><a href="#引入状态模式" class="headerlink" title="引入状态模式"></a>引入状态模式</h3><p>在上面的电视机例子中，我们发现，行为操作前需要进行各种状态判断，而这些判断使用了比较冗余的 switch…case 语句来实现的，假设我们后面电视机的状态不止如上三种了，比如加入了死机状态，那么我们的行为都要对该状态做出处理（尽管死机状态下我们的操作行为是无效的，case 语句中不必做任何响应，但这不代表我们可以省略 case 判断逻辑）。</p>
<p>状态模式的出现就刚好可以解决冗余的 switch…case 逻辑，就好比之前我们讲工厂方法模式的出现解决了简单工厂模式中的冗余的 if 判断一样，避免了巨大的条件语句块的出现，了解过规则引擎的朋友应该都听说过 Drools，规则引擎的出现也是为了解决冗余多变的业务逻辑判断问题，从这一角度来讲，状态模式也是如此。下面一起看下引入了状态模式之后我们的类图设计：</p>
<p>电视机的抽象状态：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的电视机状态角色</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TVState</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 使用遥控器作为上下文，控制电视机状态的切换</span></span><br><span class="line">    <span class="keyword">protected</span> RemoteControlMachine remoteControlMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRemoteControlMachine</span><span class="params">(RemoteControlMachine remoteControlMachine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.remoteControlMachine = remoteControlMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 开机</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 关机</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 播放</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 待机</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>待机状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 待机状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StandByState</span> <span class="keyword">extends</span> <span class="title">TVState</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关机..."</span>);</span><br><span class="line">        <span class="comment">// 使用遥控器设置电视机状态为 关机</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.setCurrentState(RemoteControlMachine.POWER_OFF_STATE);</span><br><span class="line">        <span class="comment">// 执行关机的行为</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"播放..."</span>);</span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.setCurrentState(RemoteControlMachine.PLAY_STATE);</span><br><span class="line">        <span class="comment">// 执行播放的行为</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.play();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关机状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关机状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PowerOffState</span> <span class="keyword">extends</span> <span class="title">TVState</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开机..."</span>);</span><br><span class="line">        <span class="comment">// 开机后状态默认为 待机</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.setCurrentState(RemoteControlMachine.STANDBY_STATE);</span><br><span class="line">        <span class="comment">// 执行待机的行为</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.standby();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>播放状态:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 播放状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PlayState</span> <span class="keyword">extends</span> <span class="title">TVState</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"关机..."</span>);</span><br><span class="line">        <span class="comment">// 使用遥控器设置电视机状态为 关机</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.setCurrentState(RemoteControlMachine.POWER_OFF_STATE);</span><br><span class="line">        <span class="comment">// 执行关机的行为</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"待机..."</span>);</span><br><span class="line">        <span class="comment">// 使用遥控器设置电视机状态为 待机</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.setCurrentState(RemoteControlMachine.STANDBY_STATE);</span><br><span class="line">        <span class="comment">// 执行待机的行为</span></span><br><span class="line">        <span class="keyword">super</span>.remoteControlMachine.standby();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>遥控器角色（上下文角色）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 遥控器，扮演上下文角色，负责电视机状态切换</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteControlMachine</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包含电视机的三种状态：待机、关机、播放</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> TVState STANDBY_STATE = <span class="keyword">new</span> StandByState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> TVState POWER_OFF_STATE = <span class="keyword">new</span> PowerOffState();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> TVState PLAY_STATE = <span class="keyword">new</span> PlayState();</span><br><span class="line">    <span class="comment">// 标识当前状态</span></span><br><span class="line">    <span class="keyword">private</span> TVState currentState;</span><br><span class="line">    <span class="comment">// 获取当前状态</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TVState <span class="title">getCurrentState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置当前状态，遥控器负责电视机的具体状态切换</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(TVState currentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">        <span class="keyword">this</span>.currentState.setRemoteControlMachine(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 委托给state统一去处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOn</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前状态下如何powerOn，由state去确定</span></span><br><span class="line">        <span class="keyword">this</span>.currentState.powerOn();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">powerOff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.powerOff();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.play();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">standby</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.standby();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RemoteControlMachine context = <span class="keyword">new</span> RemoteControlMachine();</span><br><span class="line">context.setCurrentState(<span class="keyword">new</span> PowerOffState());</span><br><span class="line">context.play(); <span class="comment">// 如果直接进行播放的话，因为电视机处于待机状态，所以没有任何输出</span></span><br><span class="line"></span><br><span class="line">context.powerOn();</span><br><span class="line">context.play();</span><br><span class="line">context.standby();</span><br><span class="line">context.powerOff();</span><br></pre></td></tr></table></figure>

<p>上面测试输出如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">开机...</span><br><span class="line">播放...</span><br><span class="line">待机...</span><br><span class="line">关机...</span><br></pre></td></tr></table></figure>

<p>可以看到，测试结果没有任何不同，但是我们没有写一行 switch…case 语句块，反而是将对象的各个状态抽出来做成状态类，然后各个状态类在对各个行为做出实现，代码更加精简。</p>
<p>状态模式具体的状态类在对状态做出变更时其行为也跟着做出变更，其实代码量减少并不十分明显，但是对于状态拓展十分友好，只需要增加状态类再实现各个行为即可拓展新的状态出来，也体现了开闭原则及单一职责原则；状态模式将对象状态的变更放到类的内部进行，外部调用者无需关心对象的状态及行为的变化，也体现了更好的封装性；另外对代码的 cpd（代码重复率检测）也是很有提升明显。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本小节我们介绍了状态模式的定义，优缺点已经使用场景，然后用电视机的例子帮大家更好地理解模式，状态模式的出现，一定程度解决了繁杂的语句块的硬编码的形式，成为条件分支、判断的终结者，另外状态模式下代码结构更加清晰，面向拓展更加友好。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ndmh6.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/posts/44993/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>这节我们将介绍一种全新的设计模式——组合模式。想起“组合”二字，自然联想到了很多，比如：文件和文件夹、容器和组件、火车和车厢、大树的枝干和叶子等等，大自然中组合的例子数不胜数。</p>
<a id="more"></a>


<blockquote>
<p>什么是组合关系？组合关系：部分与整体的关系，有了整体才有部分，部分不能脱离整体而存在，比如脱离了火车，车厢也无法运转。与组合关系经常做类比的是聚合关系：整体和部分的关系，部分可以单独存在，比如班级和学生，学生脱离班级后还可以加入其他团体而存在。</p>
</blockquote>
<p>这种表示“整体与部分”的关系的数据结构，类似于我们经常接触到的树形结构，想象一下：容器里可以包含组件，比如 Panel 面板中可以包含 Button 组件和子面板 Panel，子 Panel 中同样又可以包含 Panel 和 Button，简单的图例关系如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/mrx7w.png" alt=""></p>
<p>这是一个理想情况下可无限循环的结构体，组合模式的出现就是为了让我们以一致的方式来处理个别对象亦或者组合对象，而不必区分对象类型。</p>
<p>也就是说，我们要对树上的节点和叶子进行操作时，它能够提供一种一致的方式，不必纠结它是叶子类型还是节点类型。这里的一致怎么理解呢？其实有一个很重要的知识点或者共识要说明下，那就是不管是 Panel 还是 Button，我们都可以把它归为“页面元素”，也就是说我们不考虑对象类型的情况下，实际上我们都把它当作“页面元素”来处理；另外，我们的Button虽然和 Panel 是同级，但是 Button 可以作为 Panel 的子“页面元素”来存在，这也是很重要的共识。所以这里的一致，就指的是容器和内容的一致。</p>
<p><strong>基于以上几点共识，我们便能使用组合模式来解决类似问题，也就说，当我们的案例牵扯到树形结构或者类似的“部分-整体”关系的时候，我们就能够使用组合模式。</strong></p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/oc8n8.png" alt=""></p>
<h2 id="组合模式的-UML-类图"><a href="#组合模式的-UML-类图" class="headerlink" title="组合模式的 UML 类图"></a>组合模式的 UML 类图</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/vsufq.png" alt=""></p>
<p>这理解释下，Component 为容器和内容的抽象类型，除了最基本的add、remove、getChild 方法之外，还可能定义其它 operation，比如 getSize、printList等；Leaf 为叶子节点对象，该对象因为没有叶子节点，所以不能定义类似 add 这种针对容器的方法，但是可以定义叶子节点自身行为的一些方法，比如 getName 获取节点名称；Composite 为容器类，一般包含容器元素 children、操作容器的部分方法比如给容器添加元素的 add 方法。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>在组合模式中常常包含如下几个角色：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/wrcln.png" alt=""></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>接下来，我们通过一个实例来说明下什么是组合模式？比方拿我们以前实验室来说，说我们有很多实验部门，每个部门底下会管理多台实验设备，每个部门底下又会存在多个子部门，使用图例描述如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/y1b89.png" alt=""></p>
<p>抽象构件（设备和部门的抽象）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象构件Component：可以是抽象接口也可以是抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 设备或部门名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Component</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span></span>; <span class="comment">// 采购设备或添加子部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span></span>; <span class="comment">// 移除设备或子部门</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span></span>; <span class="comment">// 查询该节点下所有“设备”和“部门”</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>叶子构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 叶子节点Leaf类：树叶节点，模拟某个单台设备</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leaf</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Leaf</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点（设备）不能挂载设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"叶子节点（设备）不能移除设备"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//输出树形结构的叶子节点，这里直接输出设备名称</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;  i &lt; depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>复合构件：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复合组件构建类，模拟某个组织部门</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Composite</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Composite</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个容器，用来保存该节点下所有的“设备”和“组织”</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;Component&gt; componentArrayList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 采购设备时，只需要将“设备”加入到已有的“设备”列表</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.componentArrayList.add(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 移除设备时，只需要将“设备”从已有的“设备”列表中移除</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.componentArrayList.remove(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 该容器内部，递归查询depth深度的节点下的列表内容</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(<span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 输出树形结构（根据depth深度模拟输出多少个-）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; depth; i++) &#123;</span><br><span class="line">            System.out.print(<span class="string">"*"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(getName());</span><br><span class="line">        <span class="comment">// 递归显示</span></span><br><span class="line">        <span class="keyword">for</span>(Component component: componentArrayList) &#123;</span><br><span class="line">            component.display(depth + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建根节点及其子节点</span></span><br><span class="line">Composite root = <span class="keyword">new</span> Composite(<span class="string">"综合实验室"</span>);</span><br><span class="line">root.add(<span class="keyword">new</span> Leaf(<span class="string">"综合设备1"</span>));</span><br><span class="line">root.add(<span class="keyword">new</span> Leaf(<span class="string">"综合设备2"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建二级节点及其子节点</span></span><br><span class="line">Composite branchLevel21 = <span class="keyword">new</span> Composite(<span class="string">"化学实验室"</span>);</span><br><span class="line">branchLevel21.add(<span class="keyword">new</span> Leaf(<span class="string">"试管"</span>));</span><br><span class="line">branchLevel21.add(<span class="keyword">new</span> Leaf(<span class="string">"烧杯"</span>));</span><br><span class="line">branchLevel21.add(<span class="keyword">new</span> Leaf(<span class="string">"锥形瓶"</span>));</span><br><span class="line">root.add(branchLevel21);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 并列的二级节点</span></span><br><span class="line">Composite branchLevel22 = <span class="keyword">new</span> Composite(<span class="string">"物理实验室"</span>);</span><br><span class="line">branchLevel22.add(<span class="keyword">new</span> Leaf(<span class="string">"单刀单至开关设备"</span>));</span><br><span class="line">branchLevel22.add(<span class="keyword">new</span> Leaf(<span class="string">"电磁箱"</span>));</span><br><span class="line"></span><br><span class="line">Composite branchLevel221 = <span class="keyword">new</span> Composite(<span class="string">"精密仪器实验组"</span>);</span><br><span class="line">branchLevel221.add(<span class="keyword">new</span> Leaf(<span class="string">"精密光学测量仪"</span>));</span><br><span class="line">branchLevel221.add(<span class="keyword">new</span> Leaf(<span class="string">"精密机床"</span>));</span><br><span class="line">branchLevel22.add(branchLevel221);</span><br><span class="line"></span><br><span class="line">root.add(branchLevel22);</span><br><span class="line"></span><br><span class="line">root.display(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>测试输出结果如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/maiu0.png" alt=""></p>
<p>可以看到，我们输出一个树形结构数据的时候并不会去关心节点的类型，容器和内容的一致性使我们能像操作一个对象一样来完成这种数据结构的输出。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>组合模式组合多个对象成树形结构以表示“部分-整体”关系的层次结构，使得我们能以一致的方式来处理单个对象及对象的组合，而无需关心处理的是单个对象还是某个复合对象。</p>
<p>本节中，我们可以看到容器和内容的一致性是如何方便快捷地创建出递归结构的 Composite 模式，最后用一张图小结下：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/6ez7y.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>装饰器模式</title>
    <url>/posts/64336/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>本节我们要学习的设计模式叫做——装饰器模式，何为装饰器模式？</p>
<a id="more"></a>


<p>假如我们现在有一个视频 video 需要播放，如果在 video 播放上加上弹幕，那我们的视频播放还是之前的播放，只不过在原有播放功能上加入了弹幕功能，同样地，我们可以在视频播放上加入 3D 效果，这样就有了 3D 播放功能。<strong>这种在原有基础上进行装饰，来添加新的功能的模式其实就叫做装饰器模式，简称装饰模式。</strong>最直观地就是我们买房后的装修，无非是对原有对象（房子）的一种额外装饰，我们在开头就讲过，软件设计模式其实是从建筑领域延申过来的，这样看来，一点没错。</p>
<p>下面我们列举一个比较简单的例子，争取以最通俗的语言进行模式的讲解。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>本节中示例程序的功能是为了给视频播放添加弹幕功能，所谓的弹幕，我们这里比较简单只是单纯的演示使用，就是在原有视频内容的基础上添加弹幕内容，听起来是不是很炫，其实比较简单，我们一步步来看，首先是我们的示例程序的类图说明：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ddib9.png" alt=""></p>
<h3 id="MediaPlay-媒体播放抽象类"><a href="#MediaPlay-媒体播放抽象类" class="headerlink" title="MediaPlay 媒体播放抽象类"></a>MediaPlay 媒体播放抽象类</h3><p>媒体播放抽象类是具有媒体播放功能的抽象类。</p>
<p>getMediaName 用于获取播放的媒体文件名，属于抽象方法，需要子类去实现；getMediaSeconds 用于获取播放的媒体的播放时长，也属于抽象方法，需要子类自行实现；getMediaContent 用于获取播放的媒体的内容，同样需要子类实现。play 是模拟的媒体播放方法，这里我们每隔一秒打印输出媒体内容，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 定义 媒体播放 抽象类，用于模拟多媒体播放功能（Component 抽象构件角色）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getMediaName</span><span class="params">()</span></span>; <span class="comment">// 获取要播放的媒体文件名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">getMediaSeconds</span><span class="params">()</span></span>; <span class="comment">// 获取要播放的媒体文件的播放时长（s）</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getMediaContent</span><span class="params">()</span></span>; <span class="comment">// 获取需要播放的媒体文件内容</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 模拟媒体播放</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Media："</span> + getMediaName() + <span class="string">"(累计时长："</span> + getMediaSeconds() + <span class="string">" 秒) 正在播放"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= getMediaSeconds(); i++) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"当前播放第 "</span> + i + <span class="string">" 秒，"</span> + getMediaContent() + <span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VideoPlay-具体被装饰的类"><a href="#VideoPlay-具体被装饰的类" class="headerlink" title="VideoPlay 具体被装饰的类"></a>VideoPlay 具体被装饰的类</h3><p>上面的 MediaPlay 抽象类，如果仅仅查看代码是看不出完整端倪的，所以我们再看下它的子类——VideoPlay 具体实现类，该类的构造接收两个参数，分别是：视频名、视频内容。VideoPlay 类代表视频播放具体类，属于被装饰的角色，我们后面的弹幕视频播放就是修饰的该视频播放类，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 视频播放类，模拟视频播放功能，属于真正被装饰的角色</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VideoPlay</span> <span class="keyword">extends</span> <span class="title">MediaPlay</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String videoContent; <span class="comment">// 播放的视频内容</span></span><br><span class="line">    <span class="keyword">private</span> String videoName; <span class="comment">// 播放的视频名称</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VideoPlay</span><span class="params">(String videoName, String videoContent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.videoName = videoName;</span><br><span class="line">        <span class="keyword">this</span>.videoContent = videoContent;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMediaName</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取媒体文件（视频）名称</span></span><br><span class="line">        <span class="keyword">return</span> videoName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMediaSeconds</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取媒体文件的播放时长</span></span><br><span class="line">        <span class="keyword">return</span> videoContent.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMediaContent</span><span class="params">()</span> </span>&#123; <span class="comment">// 获取媒体文件的播放内容</span></span><br><span class="line">        <span class="keyword">return</span> videoContent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="BarrageVideoPlay-弹幕播放抽象类"><a href="#BarrageVideoPlay-弹幕播放抽象类" class="headerlink" title="BarrageVideoPlay 弹幕播放抽象类"></a>BarrageVideoPlay 弹幕播放抽象类</h3><p>原有的视频播放太过单调，我们现在想在其基础上加入弹幕播放的功能，BarrageVideoPlay 抽象类用于定义我们要实现的弹幕播放功能，该类往往只是一个抽象类，内部持有 MediaPlay 类的引用，所以其子类可以比较方便的保留使用 MediaPlay 的既有功能，该类的代码实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 弹幕视频播放：定义弹幕播放的抽象角色，具体的弹幕实现交给子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrageVideoPlay</span> <span class="keyword">extends</span> <span class="title">MediaPlay</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> MediaPlay mediaPlay;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrageVideoPlay</span><span class="params">(MediaPlay mediaPlay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediaPlay = mediaPlay;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="BarrageRedVideoPlay-弹幕播放的具体实现类"><a href="#BarrageRedVideoPlay-弹幕播放的具体实现类" class="headerlink" title="BarrageRedVideoPlay 弹幕播放的具体实现类"></a>BarrageRedVideoPlay 弹幕播放的具体实现类</h3><p>该类是 BarrageVideoPlay 抽象类的子类，内部具体实现了“弹幕功能”，父类持有 MediaPlay 类的引用，可以直接调用父类方法，只不过在方法内部可以实现装饰功能，添加一些装饰操作，具体实现类如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现弹幕播放的类，具体的装饰器的实现类，这里我们使用红色字体进行弹幕视频播放</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BarrageRedVideoPlay</span> <span class="keyword">extends</span> <span class="title">BarrageVideoPlay</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BarrageRedVideoPlay</span><span class="params">(MediaPlay mediaPlay)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mediaPlay);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMediaName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediaPlay.getMediaName() + <span class="string">"（已开启弹幕）"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMediaSeconds</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mediaPlay.getMediaSeconds();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMediaContent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"---+++*** "</span> + mediaPlay.getMediaContent() + <span class="string">"（弹幕中）---+++***"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Main-测试类"><a href="#Main-测试类" class="headerlink" title="Main 测试类"></a>Main 测试类</h3><p>接下来，我们进行测试，分别测试不加弹幕和添加弹幕的视频播放功能，测试代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MediaPlay mediaPlay = <span class="keyword">new</span> VideoPlay(<span class="string">"射雕英雄传"</span>, <span class="string">"郭靖大战欧阳锋"</span>);</span><br><span class="line">MediaPlay mediaPlay1 = <span class="keyword">new</span> BarrageRedVideoPlay(mediaPlay);</span><br><span class="line">mediaPlay.play(); <span class="comment">// 不加装饰时</span></span><br><span class="line">mediaPlay1.play(); <span class="comment">// 添加弹幕装饰时</span></span><br></pre></td></tr></table></figure>

<p>测试结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Media：射雕英雄传(累计时长：7 秒) 正在播放</span><br><span class="line">当前播放第 1 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 2 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 3 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 4 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 5 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 6 秒，郭靖大战欧阳锋…</span><br><span class="line">当前播放第 7 秒，郭靖大战欧阳锋…</span><br><span class="line">…</span><br><span class="line">Media：射雕英雄传（已开启弹幕）(累计时长：7 秒) 正在播放</span><br><span class="line">当前播放第 1 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 2 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 3 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 4 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 5 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 6 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br><span class="line">当前播放第 7 秒，—+*** 郭靖大战欧阳锋（弹幕中）—+***…</span><br></pre></td></tr></table></figure>

<p>可以看到，添加弹幕装饰之后，我们的视频播放起来功能更加丰富了，这就是装饰器模式的好处，在不改变原有功能的基础上添加额外的装饰功能。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/e558e.png" alt=""></p>
<p>装饰器模式类图如上图所示，其中包含如下几个角色：</p>
<ul>
<li>抽象构件（Component ）：Component 是一个接口或者抽象类，也是最原始的对象，属于模式核心角色。用于定义一些抽象的接口或功能，以便后面的 ConcreteComponent 和 ConcreteDecorator 角色去实现；</li>
<li>具体构件（ConcreteComponent）：ConcreteComponent 是最原始、最基本的接口或抽象类 Component 的实现，在模式中充当被装饰的角色，也就说我们模式要装饰的对象就是 ConcreteComponent；</li>
<li>抽象装饰角色（Decorator）：Decorator 一般是一个抽象类，实现接口或者抽象方法，其内部不一定有抽象方法定义，有可能只是单纯继承下 Component 抽象构件；但是其内部一般都有一个 Component 角色的引用，表示 Decorator 需要装饰的对象，一般该对象是 private 或者 protected 声明；</li>
<li>具体装饰器角色<strong>（</strong>ConcreteDecorator）：具体的装饰器类，继承 Decorator 抽象装饰器角色，实现了 Component 抽象角色中定义的接口（API）。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节，我们学习了装饰器模式的简单使用，总结下如下所示<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/0ot69.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/posts/14565/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>访问者模式（Visitor Pattern）的英文定义如下：</p>
<blockquote>
<p>Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates.<br>意思是：封装一些作用于某种数据结构中的各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。简单地来说，就是将数据结构和数据操作相分离。</p>
</blockquote>
<a id="more"></a>


<p>比如说，做过开发的都知道，普通用户和 Root 用户在 Linux 机器上对文件或者文件夹进行操作时，Root 用户往往不受限制，而普通用户却需要各种访问权限才能正常进行，这种同样是访问文件或文件夹，不同的访问者表现出的行为不同的现象就是我们的访问者模式，文件或文件夹就是被访问的元素，Root 用户或者普通用户就是我们的访问者，而文件或文件夹往往是位于计算机或者其它存储设备上的，这里的存储设备就是访问者模式中的 ObjectStructure，可以类比为元素的容器对象。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>访问者模式包含角色如下：</p>
<ul>
<li>访问者（Visitor）：定义对不同的元素进行访问时的抽象行为，一般来说，有多少个具体元素，就有多少个抽象接口；</li>
<li>具体访问者（ConcreteVisitor）：实现上面 Visitor 定义的所有接口，用来指定该访问者对各个元素进行访问时的具体行为，在本文中由 Root 用户和普通用户扮演该角色；</li>
<li>元素（Element）：抽象的被访问的元素，一般会定义一个 accept 方法，指定其被访问时的抽象行为；</li>
<li>具体元素（ConcreteElement）：具体的被访问的元素，实现上面 Element 的 accept 方法，各个元素负责定义自己的 accept 行为，来表示其被访问时的行为，本文中由 FileElement 和 DictionaryElement 类扮演；</li>
<li>对象结构（ObjectStructure）：对象结构实际上是一个被访问元素的集合，好比一个元素容器，对容器的具体元素的访问表现出的行为如何，这是由访问者模式决定的。</li>
</ul>
<p>角色之间的 UML 关系图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/6jzht.jpg" alt=""></p>
<h2 id="访问者模式代码实现"><a href="#访问者模式代码实现" class="headerlink" title="访问者模式代码实现"></a>访问者模式代码实现</h2><h3 id="抽象访问者"><a href="#抽象访问者" class="headerlink" title="抽象访问者"></a>抽象访问者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象的访问者角色，需要针对每个被访问元素都定义一个接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体访问者"><a href="#具体访问者" class="headerlink" title="具体访问者"></a>具体访问者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 具体的访问者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteVisitorA</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(ConcreteElementA element)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 实现自己的对元素ConcreteElementA的访问行为</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="抽象元素"><a href="#抽象元素" class="headerlink" title="抽象元素"></a>抽象元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被访问元素的抽象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 声明 accept 方法，代表元素可以被访问</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体元素"><a href="#具体元素" class="headerlink" title="具体元素"></a>具体元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实现抽象元素接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteElementA</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 传入对象自身</span></span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="对象结构"><a href="#对象结构" class="headerlink" title="对象结构"></a>对象结构</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elements;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObjectStructure</span><span class="params">(List&lt;Element&gt; elements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = elements;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义方法，该方法往往要对 elements 进行遍历</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Element element: elements) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>访问者模式的优点：</p>
<ul>
<li>数据结构和数据操作相分离；</li>
<li>对访问者拓展性良好，只需要增加新的访问者类即可；</li>
<li>各个角色职责明确，符合单一职责原则。</li>
</ul>
<p>访问者模式的缺点：</p>
<ul>
<li>元素变更时会导致整个代码都要调整。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>访问者模式的典型应用场景如下：</p>
<ul>
<li>对象的结构（元素）比较稳定，而访问者频繁变动的场景；</li>
<li>数据操作和数据结构分离的场景。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>还是以文章开始讲的 Root 用户和普通用户访问文件或文件夹为例，下面我们以访问者模式来实现一下：</p>
<h3 id="抽象的访问元素"><a href="#抽象的访问元素" class="headerlink" title="抽象的访问元素"></a>抽象的访问元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 被访问的元素</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体访问元素-——-文件元素"><a href="#具体访问元素-——-文件元素" class="headerlink" title="具体访问元素 —— 文件元素"></a>具体访问元素 —— 文件元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件元素</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FileElement</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前元素的访问权限</span></span><br><span class="line">    <span class="keyword">private</span> String lookPerms;</span><br><span class="line">    <span class="comment">// 文件名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    FileElement(String name, String lookPerms) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lookPerms = lookPerms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getLookPerms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookPerms;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="具体访问元素-——-文件夹元素"><a href="#具体访问元素-——-文件夹元素" class="headerlink" title="具体访问元素 —— 文件夹元素"></a>具体访问元素 —— 文件夹元素</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件夹</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DictionaryElement</span> <span class="keyword">implements</span> <span class="title">Element</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 当前元素的访问权限</span></span><br><span class="line">    <span class="keyword">private</span> String lookPerms;</span><br><span class="line">    <span class="comment">// 文件夹名</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    DictionaryElement(String name, String lookPerms) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.lookPerms = lookPerms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">String <span class="title">getLookPerms</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lookPerms;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象的访问者"><a href="#抽象的访问者" class="headerlink" title="抽象的访问者"></a>抽象的访问者</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 访问者</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义对不同的元素（文件）进行访问时的具体行为</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(FileElement fileElement)</span></span>;</span><br><span class="line">    <span class="comment">// 定义对不同的元素（文件夹）进行访问时的具体行为</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(DictionaryElement dictionaryElement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体访问者-——Root-用户"><a href="#具体访问者-——Root-用户" class="headerlink" title="具体访问者 ——Root 用户"></a>具体访问者 ——Root 用户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// root用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RootVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(FileElement fileElement)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前：Root "</span> + <span class="string">"要访问的文件名："</span> + fileElement.getName() + <span class="string">" 允许访问!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(DictionaryElement dictionaryElement)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"当前：Root "</span> + <span class="string">"要访问的文件夹名："</span> + dictionaryElement.getName() + <span class="string">" 允许访问!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="具体访问者-——-普通用户"><a href="#具体访问者-——-普通用户" class="headerlink" title="具体访问者 —— 普通用户"></a>具体访问者 —— 普通用户</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 普通用户</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NormalVisitor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义该用户具备的权限集合</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; lookPerms;</span><br><span class="line">    NormalVisitor(List&lt;String&gt; lookPerms) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lookPerms = lookPerms;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(FileElement fileElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lookPerms.indexOf(fileElement.getLookPerms()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前：普通用户"</span> + <span class="string">" 具备权限："</span> + <span class="keyword">this</span>.lookPerms.toString() + <span class="string">" 要访问的文件名："</span> + fileElement.getName()  + <span class="string">" 允许访问!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前：普通用户"</span> + <span class="string">" 具备权限："</span> + <span class="keyword">this</span>.lookPerms.toString() +<span class="string">" 要访问的文件名："</span> + fileElement.getName() + <span class="string">" 权限不足，禁止访问!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(DictionaryElement dictionaryElement)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.lookPerms.indexOf(dictionaryElement.getLookPerms()) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前：普通用户"</span> + <span class="string">" 具备权限："</span> + <span class="keyword">this</span>.lookPerms.toString() + <span class="string">" 要访问的文件夹名："</span> + dictionaryElement.getName()  + <span class="string">" 允许访问!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"当前：普通用户"</span> + <span class="string">" 具备权限："</span> + <span class="keyword">this</span>.lookPerms.toString() +<span class="string">" 要访问的文件夹名："</span> + dictionaryElement.getName() + <span class="string">" 权限不足，禁止访问!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="存储设备"><a href="#存储设备" class="headerlink" title="存储设备"></a>存储设备</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ObjectStructure角色</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算机中的文件和文件夹List</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Element&gt; elementList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#123;</span><br><span class="line">        elementList.add(<span class="keyword">new</span> FileElement(<span class="string">"Java讲义.pdf"</span>, <span class="string">"look-file"</span>));</span><br><span class="line">        elementList.add(<span class="keyword">new</span> DictionaryElement(<span class="string">"program"</span>, <span class="string">"look-dictionary"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 展示该电脑中的文件和文件夹</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">showFileAndDict</span><span class="params">(Visitor visitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Element element: elementList) &#123;</span><br><span class="line">            element.accept(visitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Computor computor = <span class="keyword">new</span> Computor();</span><br><span class="line">    computor.showFileAndDict(<span class="keyword">new</span> NormalVisitor(Collections.singletonList(<span class="string">"look-dictionary"</span>)));</span><br><span class="line">    computor.showFileAndDict(<span class="keyword">new</span> RootVisitor());</span><br><span class="line">    computor.showFileAndDict(<span class="keyword">new</span> NormalVisitor(Arrays.asList(<span class="string">"look-file"</span>, <span class="string">"look-dictionary"</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">当前：普通用户 具备权限：[look-dictionary] 要访问的文件名：Java 讲义.pdf 权限不足，禁止访问！</span><br><span class="line"></span><br><span class="line">当前：普通用户 具备权限：[look-dictionary] 要访问的文件夹名：program 允许访问！</span><br><span class="line"></span><br><span class="line">当前：Root 要访问的文件名：Java 讲义.pdf 允许访问！</span><br><span class="line"></span><br><span class="line">当前：Root 要访问的文件夹名：program 允许访问！</span><br><span class="line"></span><br><span class="line">当前：普通用户 具备权限：[look-file, look-dictionary] 要访问的文件名：Java 讲义.pdf 允许访问！</span><br><span class="line"></span><br><span class="line">当前：普通用户 具备权限：[look-file, look-dictionary] 要访问的文件夹名：program 允许访问！</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>访问者模式适应于元素种类基本不变但是 visit 行为变化的场景，或者说访问者不断增加的场景，访问者增加时我们只需要增加新的访问者类即可，一定程度上避免了在 visit 上进行 if…else 的繁杂逻辑判断，减少了代码体积。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/posts/7738/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>观察者模式（Observer Pattern）也称发布订阅模式。</p>
<a id="more"></a>


<p>观察者模式的英文定义如下：</p>
<blockquote>
<p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.<br>意思是：定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖于它的对象都会得到通知并被自动更新。</p>
</blockquote>
<p>以生活中的例子来说，就像我们订阅报纸一样，每天有多少人订阅，当有新报纸发布的时候，就会有多少人收到新发布的报纸，这种模式就是订阅 - 发布模式，而报社和订阅者就满足定义中说是的，一对多的依赖关系。</p>
<p>“观察者模式” 这个词可能不太好理解，但如果用 “发布 — 订阅模式” 来替代的话，就相对好理解一些。</p>
<blockquote>
<p>小贴士：本文会采用“观察者模式”来编写内容，但读者可以用“发布 - 订阅模式”来理解本文的内容，两者所说的是同一种模式。</p>
</blockquote>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>观察者模式包含如下角色：</p>
<ul>
<li>抽象主题（Subject）角色：该角色又称为 “发布者” 或” 被观察者 “，可以增加和删除观察者对象；</li>
<li>具体主题（Concrete Subject）角色：该角色又称为 “具体发布者” 或 “具体被观察者”，它将有关状态存入具体观察者对象，在具体主题的内部状态改变时，给所有登记过（关联了观察关系）的观察者发出通知；</li>
<li>抽象观察者（Observer）角色：该角色又称为 “订阅者”，定义一个接收通知的接口，在得到主题的通知时更新自己；</li>
<li>具体观察者（Concrete Observer）角色：该角色又称为 “具体订阅者”，它会实现一个接收通知的方法，用来使自身的状态与主题的状态相协调。</li>
</ul>
<p>角色之间的 UML 关系图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/dqxch.png" alt=""></p>
<h2 id="观察者模式代码实现"><a href="#观察者模式代码实现" class="headerlink" title="观察者模式代码实现"></a>观察者模式代码实现</h2><h3 id="抽象主题（发布者接口）"><a href="#抽象主题（发布者接口）" class="headerlink" title="抽象主题（发布者接口）"></a>抽象主题（发布者接口）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象主题（发布者接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 添加观察者（订阅者）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">// 删除观察者（订阅者）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer o)</span></span>;</span><br><span class="line">    <span class="comment">// 通知所有观察者（订阅者）</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体主题（发布者）"><a href="#具体主题（发布者）" class="headerlink" title="具体主题（发布者）"></a>具体主题（发布者）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体主题（发布者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放观察者（订阅者）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加观察者（订阅者）</span></span><br><span class="line">        list.add(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除观察者（订阅者）</span></span><br><span class="line">        list.remove(o);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通知所有观察者（订阅者）</span></span><br><span class="line">        <span class="keyword">for</span> (Observer o : list) &#123;</span><br><span class="line">            o.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象观察者（订阅者接口）"><a href="#抽象观察者（订阅者接口）" class="headerlink" title="抽象观察者（订阅者接口）"></a>抽象观察者（订阅者接口）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象观察者（订阅者接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="具体观察者（订阅者）"><a href="#具体观察者（订阅者）" class="headerlink" title="具体观察者（订阅者）"></a>具体观察者（订阅者）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体观察者（订阅者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 主题有更新之后，执行的具体订阅（通知）方法</span></span><br><span class="line">        System.out.println(<span class="string">"我收到了通知~"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="客户端（调用）"><a href="#客户端（调用）" class="headerlink" title="客户端（调用）"></a>客户端（调用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 观察者模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建主题（发布者）</span></span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        <span class="comment">// 创建观察者（订阅者）</span></span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        <span class="comment">// 关联订阅</span></span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        <span class="comment">// 改变主题（发布者）状态，发送通知</span></span><br><span class="line">        subject.change();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">我收到了通知～</span><br></pre></td></tr></table></figure>

<p>从以上代码可以看出，当主题（ConcreteSubject）的状态发生变化时，就会触发通知方法，通知方法会通知所有的观察者对象（ConcreteObserver），这样就完成了整个发布 — 订阅的过程。</p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>观察者模式的优点：</p>
<ul>
<li>观察者和被观察者之间，实现了抽象耦合。被观察者角色所知道的只是一个具体观察者集合，每一个具体观察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体的观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密的耦合在一起，因此它们可以属于不同的抽象化层次，且都非常容易扩展；</li>
<li>此模式为广播模式，所有的观察者只需要订阅相应的主题，就能收到此主题下的所有广播。</li>
</ul>
<p>观察者模式的缺点：</p>
<ul>
<li>观察者只知道被观察者会发生变化，但不知道何时会发生变化；</li>
<li>如果主题之间有循环依赖，会导致系统崩溃，所以在使用时要特别注意此种情况；</li>
<li>如果有很多个观察者，则每个通知会比较耗时。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>使用观察模式的典型应用场景如下：</p>
<ul>
<li>关联行为的场景，例如，在一个系统中，如果用户完善了个人资料，就会增加积分、添加日志、开放一些功能权限等，就比较适合用观察者模式；</li>
<li>消息队列，例如，需要隔离发布者和订阅者，需要处理一对多关系的时候。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>以生活中的读者订阅为例，假设，读者 A 和 读者 B 订阅了某平台的图书，当有新的图书发布时就会给两位读者发送图书，实现代码如下。</p>
<h3 id="读者接口和实现类"><a href="#读者接口和实现类" class="headerlink" title="读者接口和实现类"></a>读者接口和实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读者接口（订阅接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String bookName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 读者类（订阅者）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> <span class="keyword">implements</span> <span class="title">IReader</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Reader</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"-收到了图书："</span> + bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="平台接口和实现类"><a href="#平台接口和实现类" class="headerlink" title="平台接口和实现类"></a>平台接口和实现类</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 平台接口（发布方接口）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPlatform</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(IReader reader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(IReader reader)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String bookName)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 具体平台类（发布方）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Platform</span> <span class="keyword">implements</span> <span class="title">IPlatform</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存放读者（订阅者）</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;IReader&gt; list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(IReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 添加读者（订阅者）</span></span><br><span class="line">        list.add(reader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(IReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 删除读者（订阅者）</span></span><br><span class="line">        list.remove(reader);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通知所有读者（订阅者）</span></span><br><span class="line">        <span class="keyword">for</span> (IReader reader : list) &#123;</span><br><span class="line">            reader.update(bookName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.notifyObservers(bookName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端（调用）-1"><a href="#客户端（调用）-1" class="headerlink" title="客户端（调用）"></a>客户端（调用）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建图书平台（发布者）</span></span><br><span class="line">        Platform platform = <span class="keyword">new</span> Platform();</span><br><span class="line">        <span class="comment">// 创建读者 A（订阅者）</span></span><br><span class="line">        Reader reader = <span class="keyword">new</span> Reader(<span class="string">"A"</span>);</span><br><span class="line">        <span class="comment">// 读者 A 订阅图书通知</span></span><br><span class="line">        platform.attach(reader);</span><br><span class="line">        <span class="comment">// 创建读者 （订阅者）</span></span><br><span class="line">        Reader reader2 = <span class="keyword">new</span> Reader(<span class="string">"B"</span>);</span><br><span class="line">        <span class="comment">// 读者 B 订阅图书通知</span></span><br><span class="line">        platform.attach(reader2);</span><br><span class="line">        platform.change(<span class="string">"《Java面试全解析》"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">A - 收到了图书：《Java 面试全解析》</span><br><span class="line"></span><br><span class="line">B - 收到了图书：《Java 面试全解析》</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>观察者模式就是一个发布者对应多个订阅者的模式，发布者对应的角色就是主题（Subject），而订阅者对应的角色就是观察者（Observer），只要订阅者订阅了发布者（对象），当发布者的状态发生变化时，就会通知所有的订阅者。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/posts/16035/</url>
    <content><![CDATA[<p>解释器模式，这个模式我觉得是这些模式中最不好理解的模式，解释器模式是用来干啥的呢？比如说我们有一段英文或者一段公式，我们需要知道其中表达的意思到底是啥？（假如我们起初并不理解）也就是说，我们需要一个”解释人”，该角色就是我们的联络官或者叫做解释器，用来翻译我们的文本或者公式，翻译成我们能理解的最小的基础单元，听着是不是还云里雾里地？大家都知道编译器吧，一般的编译器分为词法分析器、语法分析器、语义分析器、中间代码优化器以及最终的代码生成器等，而我的理解，解释器就类似于其中的语法分析器的作用，专门负责语法文本的解析作用。</p>
<a id="more"></a>


<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>解释器模式（Interpreter Pattern）提供了评估语言的语法或者表达式的方式，属于一种行为型的设计模式。<br>解释器模式的英文原话是：</p>
<blockquote>
<p>Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.<br>意思是：给定一门语言，定义它的文法的一种表示，并定义一个解释器，该解释器使用该表示来解释语言中的句子。</p>
</blockquote>
<p>简单来说，就是我们可以定义一种语法比如就是一个表达式如：a-b+c，起初我们并不知道这个句子想要携带信息或者执行什么操作，然后我们要定义一个解析器来进行表达式解析，以便得到正确的结果。</p>
<p>对于表达式：a-b+c 这种，我们做个简单的分析，a、b、c 这种我们又叫做运算参数，+、- 符号这种我们称之为运算符号，也就说这类表达式我们可以将其抽象为两种角色：运算参数、运算符号。运算参数一般就是英文字母，执行时各个参数需要赋上具体的数字值去替代英文字母执行，运算参数有一个共同点就是不管是 a、b 或者其它参数，除了被赋值之外不需要做其它任何处理，是执行时的最小单元，在解释器模式中被称为终结符号。运算符号是进行运算时具体要被解释器解释执行的部分，想象一下，加入我们计算机不知道如何处理类似 +、- 这种符号，我们是不要针对每一个符号写一个解释方法，以便告诉计算机该符号需要进行何种操作，这也就是解释器模式的核心——需要完成逻辑的解释执行操作，而运算符号在解释器模式中也被称为非终结符号。</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>解释器模式的通用类图设计如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/yj4oz.png" alt=""></p>
<p>通常包含如下角色：</p>
<ul>
<li>抽象解释器（AbstractExpression）：抽象解释器是一个上层抽象类，用来抽取定义公共的解释方法：interpreter，具体的解释任务交给子类去完成；</li>
<li>终结符表达式（TerminalExpression）：是抽象解释器的子类，实现了与文法中的元素相关的解释操作。一般模式中只会有一个终结符表达式也就是终结符的类，但是会有多个实例，比如：a、b、c，这些终结符号可以任意多种但是只有一个类来描述；</li>
<li>非终结符表达式（NonTerminalExpression）：也是抽象解释器的子类，用来实现文法中与终结符相关的操作。该角色一般会有多个实现类，比如 +、- 运算符号就各自对应一种类实现，分别对应加法解释类和减法解释类，非终结符表达式的类的个数一般会有很多，因为我们可执行的操作一般会有很多，这也从侧面加剧了该模式下类设计的复杂性；</li>
<li>上下文（Context）：上下文一般用来定义各个解释器需要的数据或公共功能，比如上面的表达式，我们使用上下文来保存各个参数的值，一般是一个 HashMap 对象，以便后面所有解释器都可以使用该上下文来获取参数值；</li>
</ul>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>解释器模式的优点：</p>
<ul>
<li>拓展性强：修改文法规则只需要修改相应的非终结符表达式就可以了，即增加非终结符类就可以了。<br>解释器模式的缺点：</li>
<li>采用递归调用方法，不利于调试，增加了系统的复杂性以及降低了系统执行的效率；</li>
<li>解释器模式比较容易造成类设计的膨胀，主要是非终结符表达式类会随着系统的复杂性而膨胀；</li>
<li>可利用的场景比较少；</li>
<li>对于比较复杂的文法不好解析。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul>
<li>一个简单语法需要解释的场景，如：sql语法分析，用来解析那种比较标准的字符集；</li>
<li>重复发生的问题可以使用解释器模式，如：日志分析，日志分析时基础数据是相同的类似于我们的终结符，但是日志格式往往是各异的，类似于非终结符，只需要指定具体的实现类即可。</li>
</ul>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>现在我们以一个最简单的例子：a+b，我们要做的就是解释执行这段语法文本，a 和 b是两个字母也叫做两个变量，我们需要使用一个 “+” 符号来将这俩变量连接起来，假设我们的语言并不知道符号 “+”是什么作用，具体作用需要我们去实现（假设我们并不知道 + 其实是加法的意思），示例比较简单，只是为了说明解释器模式没别的意思。</p>
<p>首先是我们的上下文类，该类负责模式中一些上下文数据的存储，这里我们使用 context 存储运算符号 +，实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上下文类，这里只是简单说明下，实际的context可没这么简单</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String symbol = <span class="string">""</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Context</span><span class="params">(String symbol)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.symbol = symbol;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSymbol</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> symbol;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是我们的抽象解释器角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象解释器</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 解释器接口</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(Context context)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是我们的终结符和非终结符类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 终结符，即我们的参数构造类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer arg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TerminalExpression</span><span class="params">(Integer arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.arg;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非终结符，即我们的运算符构造类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NonTerminalExpression</span> <span class="keyword">extends</span> <span class="title">AbstractExpression</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 代表运算符两侧的参数，即a、b</span></span><br><span class="line">    <span class="keyword">private</span> AbstractExpression left;</span><br><span class="line">    <span class="keyword">private</span> AbstractExpression right;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NonTerminalExpression</span><span class="params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.left = left;</span><br><span class="line">        <span class="keyword">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">interpreter</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 实现具体的 a +b 的解释执行操作</span></span><br><span class="line">        <span class="keyword">if</span> (!context.getSymbol().equalsIgnoreCase(<span class="string">""</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.left.interpreter(context) + <span class="keyword">this</span>.right.interpreter(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AbstractExpression left = <span class="keyword">new</span> TerminalExpression(<span class="number">12</span>);</span><br><span class="line">AbstractExpression right = <span class="keyword">new</span> TerminalExpression(<span class="number">34</span>);</span><br><span class="line">AbstractExpression calExpression = <span class="keyword">new</span> NonTerminalExpression(left, right);</span><br><span class="line">Context context = <span class="keyword">new</span> Context(<span class="string">"+"</span>);</span><br><span class="line">Integer result = calExpression.interpreter(context);</span><br><span class="line">System.out.println(result); <span class="comment">// 46</span></span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这节我们主要介绍了解释器模式的定义以及使用示例，解释器模式实际使用的场景并不多，但是又是一种比较复杂的设计模式，需要引起我们的重视，最后大家可以思考下，上面只是实现了最简单的 a + b，如果要实现 a + b - c 这种文法解析，又该如何实现呢，欢迎大家积极思考。<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/jois5.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/posts/60015/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>什么是责任链模式？生活中我们经常遇到这样的问题，比如请假审批需要层层上报处理、遇到问题各个部门甩赖扯皮，像这种，在事情没有被处理之前，会经过一系列阶段，类似于“踢皮球”似的。同样地，当一个请求到达时，在程序无法直接决定由哪个对象负责处理时，客户的请求就会形成一种链式传递，在链上的各个处理对象如果无法直接决定是否由其处理时，就会将请求再传递至下一个链对象，直到请求被处理或者被丢弃等等。这种处理链我们形象称其为“责任链”。</p>
<a id="more"></a>


<p>责任链模式的定义是：<strong>使多个对象都有机会处理请求，从而避免了请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</strong></p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>举个例子，初级、中级、高级开发工程师分别处理问题的能力不同，我们假设初级工程师只能处理难度级别为 1 的问题，中级工程师能处理难度为 1、2 的问题，高级工程师能处理难度级别为 1、2、3 的问题，另外我们有一个 Request 请求代表要处理的请求，内部包含一个难度级别和要请求的内容，我们先来看下类图的设计：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/1w1vo.png" alt=""></p>
<p>首先我们先定义一个请求接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取请求级别</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取要请求的内容</span></span><br><span class="line">    <span class="function">String <span class="title">getRequest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该接口包括一个难度级别和要请求的内容，这就是我们需要链式处理的请求，链上的处理对象根据请求难度级别获取请求内容选择是否进行处理，接下来是 IRequest 的实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span> <span class="keyword">implements</span> <span class="title">IRequest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 难度级别1--初级工程师解决</span></span><br><span class="line"><span class="comment">     * 难度级别2--中级工程师解决</span></span><br><span class="line"><span class="comment">     * 难度级别3--高级工程师解决</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level;</span><br><span class="line">    <span class="comment">// 要请求的内容或要解决的问题</span></span><br><span class="line">    <span class="keyword">private</span> String request = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    Request(<span class="keyword">int</span> _level, String _request) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = _level;</span><br><span class="line">        <span class="keyword">switch</span> (<span class="keyword">this</span>.level) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">this</span>.request = <span class="string">"难度级别为1的请求是："</span> + _request;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="keyword">this</span>.request = <span class="string">"难度级别为2的请求是："</span> + _request;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="keyword">this</span>.request = <span class="string">"难度级别为3的请求是："</span> + _request;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getRequestLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现类比较简单，类中的难度级别和请求内容从构造中传入，接下来是我们的核心类 Handler 抽象类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Difficulty_LEVEL_1_REQUEST = <span class="number">1</span>; <span class="comment">// 难度级别为1</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Difficulty_LEVEL_2_REQUEST = <span class="number">2</span>; <span class="comment">// 难度级别为2</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> Difficulty_LEVEL_3_REQUEST = <span class="number">3</span>; <span class="comment">// 难度级别为3</span></span><br><span class="line">    <span class="comment">// 能处理的级别</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 责任传递，下一个责任人是谁</span></span><br><span class="line">    <span class="keyword">private</span> Handler nextHandler;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每个类都要说明一下自己能处理哪些请求</span></span><br><span class="line">    Handler(<span class="keyword">int</span> level) &#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 负责Request的请求处理，final关键字声明不允许被子类覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">HandleMessage</span><span class="params">(IRequest request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果请求级别小于可以处理的级别就直接处理，比如：高级工程师也可以处理难度级别为1的请求</span></span><br><span class="line">        <span class="keyword">if</span> (request.getRequestLevel() &lt;= <span class="keyword">this</span>.level) &#123;</span><br><span class="line">            <span class="keyword">this</span>.response(request);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.nextHandler != <span class="keyword">null</span>) &#123; <span class="comment">// 有后续环节，请求传递</span></span><br><span class="line">                <span class="keyword">this</span>.nextHandler.HandleMessage(request);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 无后续环节了，按照不同意处理</span></span><br><span class="line">                System.out.println(<span class="string">"--------难度级别为"</span> + request.getRequestLevel() + <span class="string">"的请求-------"</span>);</span><br><span class="line">                System.out.println(<span class="string">"---抱歉，没有工程师可以处理---\n"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果不属于你处理的请求，你应该让请求路由到下一个环节的责任人</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setNextHandler</span><span class="params">(Handler nextHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextHandler = nextHandler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 有请示那当然要回应</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(IRequest request)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Handler 类是链中对象的抽象类，链上的所有的责任对象都需要继承该对象，我们定义 HandleMessage 方法来进行请求的链式处理，可以看到：如果请求的难度级别不高于链对象可处理的难度级别时，由链对象直接负责处理，也就实现了前面讲到的高级工程师也可以处理难度级别为1的初级问题；如果请求难度级别过高超出可处理级别则请求继续向下传递，直至没有责任人可以处理为止，这就是责任链模式的核心。最后是 Handler 类的三个具体实现类，分别代表三个责任人对象：初级工程师、中级工程师及高级工程师，来看下怎么写的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 初级难度的责任人</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Primary</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初级工程师可以处理难度等级为1的请求</span></span><br><span class="line">    Primary() &#123;</span><br><span class="line">        <span class="keyword">super</span>(Handler.Difficulty_LEVEL_1_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(IRequest request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------难度级别为1的请求-------"</span>);</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line">        System.out.println(<span class="string">"初级工程师处理结果: 已处理\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Middle</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 中级工程师可以处理难度等级为2的请求</span></span><br><span class="line">    Middle() &#123;</span><br><span class="line">        <span class="keyword">super</span>(Handler.Difficulty_LEVEL_2_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(IRequest request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------难度级别为2的请求-------"</span>);</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line">        System.out.println(<span class="string">"中级工程师处理结果: 已处理\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Senior</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 高级工程师可以处理难度级别为3的请求</span></span><br><span class="line">    Senior() &#123;</span><br><span class="line">        <span class="keyword">super</span>(Handler.Difficulty_LEVEL_3_REQUEST);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 处理结果</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">response</span><span class="params">(IRequest request)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"--------难度级别为3的请求-------"</span>);</span><br><span class="line">        System.out.println(request.getRequest());</span><br><span class="line">        System.out.println(<span class="string">"高级工程师处理结果: 已处理\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里，我们定义四个难度级别不同的请求，请求进入处理链后，各个责任对象就会根据难度级别选择处理，直至不能处理为止，测试结果输出如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--------难度级别为1的请求-------</span><br><span class="line">难度级别为1的请求是：1+1&#x3D;？</span><br><span class="line">初级工程师处理结果: 已处理</span><br><span class="line"></span><br><span class="line">--------难度级别为2的请求-------</span><br><span class="line">难度级别为2的请求是：3*4&#x3D;？</span><br><span class="line">中级工程师处理结果: 已处理</span><br><span class="line"></span><br><span class="line">--------难度级别为3的请求-------</span><br><span class="line">难度级别为3的请求是：87834*765&#x3D;？</span><br><span class="line">高级工程师处理结果: 已处理</span><br><span class="line"></span><br><span class="line">--------难度级别为4的请求-------</span><br><span class="line">---抱歉，没有工程师可以处理---</span><br></pre></td></tr></table></figure>

<p>可以看到，对于难度级别不同的请求，责任链上各个对象可以根据难度级别自行处理，对于不能处理的级别，也可以按照预期正常响应，责任链模式的魅力就在于此：_客户端不需要关心请求被谁处理，链上的各个责任人会根据预先设定的链的顺序依次处理，直至不能处理为止。_</p>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>通过上面的实例，想必我们已经了解了什么是责任链模式，责任链模式的通用类图如下：</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/uiut1.png" alt=""></p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/1713p.png" alt=""></p>
<p>责任链模式的核心就是 Handler 链抽象对象，该对象包含一个指向下一个链对象的私有属性，“链”是责任链的核心，就是使用该属性进行链式调用实现的。责任链模式的包含的角色如下：</p>
<ul>
<li>请求者（Client）：Client 角色就是向链发送请求的角色，在上面的例子中，Main 函数扮演这个角色；</li>
<li>责任人的抽象类角色（Handler）：Handler 角色是模式的核心，Handler 知道下一个责任人是谁，并根据责任人的处理能力选择是否将请求转发至下一个责任人。上面例子中，由 Handler 类扮演该角色；</li>
<li>具体责任人对象（ConcreteHandler）：该角色是具体处理请求的对象，上面例子中，由 Primary、Middle、Senior 类扮演。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本节介绍了责任链模式的概念、示例，责任链模式很好的降低了请求者和处理者的耦合度，弱化了前后关系，使得请求者不必关心请求真正是被哪个环节的哪个责任人处理，另外责任链模式下，链的调用顺序也是可控的，这也很好的实现了有序性。</p>
<p>责任人链模式的链式调用，有个非常明显的缺点就是：每个请求可能都是从头到尾走一遍，特别是调用链比较长时，这就加剧了系统的响应时间及导致调试的复杂性。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/638c2.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>过滤器模式</title>
    <url>/posts/6526/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><h3 id="模式引入"><a href="#模式引入" class="headerlink" title="模式引入"></a>模式引入</h3><p>首先，什么是过滤器模式？这种模式生活中比较常见，比如移动推出某项优惠套餐，但是套餐可使用的用户群体有限，必须满足入网 5 年以上这种条件，我们可以将 “入网五年” 作为客户群体的过滤条件，这种就是简单的过滤器模式应用。</p>
<a id="more"></a>

<p>又比如，现在的垃圾分类，很多城市从上海开始，已经运行起来，着实让人头大，这种垃圾过滤分类的思想其实本身就是一种过滤模式。再比如我们设计日志系统时，并非所有日志都要收集，而是选择性过滤收集，这种实现了日志过滤的东西本身就是过滤器模式的一种体现。讲了这么多，到底什么是过滤器模式？</p>
<h3 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h3><p>过滤器模式（Filter Pattern）又称为标准模式 （Criteria Pattern）是一种设计模式，这种模式允许开发人员使用不同的标准来过滤一组对象，通过运算逻辑以解耦的方式将它们联系起来。这种类型的设计模式属于结构型模式，说白了，就是按条件筛选一组对象出来。</p>
<blockquote>
<p>目的：使用不同标准来过滤一组对象<br>实现：制定不同的规则来实现过滤，然后对过滤结果进行分组</p>
</blockquote>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>过滤器模式一般有如下角色：</p>
<ul>
<li>抽象过滤器角色（AbstractFilter）：负责定义过滤器的实现接口，具体的实现还要具体过滤器角色去参与，客户端可以调用抽象过滤器角色中定义好的方法，将客户端的所有请求委派到具体的实现类去，从而让实现类去处理；</li>
<li>ConcreteFilter（具体过滤器角色）：该角色负责具体筛选规则的逻辑实现，最后再返回一个过滤后的数据集合，标准的过滤器只对数据做过滤，当然也可以对集合中的数据做某项处理，再将处理后的集合返回；</li>
<li>Subject（被过滤的主体角色）：一个软件系统中可以有一个或多个目标角色，在具体过滤器角色中会对指定感兴趣的目标进行处理，以确保后面的数据确实是我想要的</li>
</ul>
<h2 id="过滤器延伸-——-管道和过滤器"><a href="#过滤器延伸-——-管道和过滤器" class="headerlink" title="过滤器延伸 —— 管道和过滤器"></a>过滤器延伸 —— 管道和过滤器</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/ca2jz.png" alt=""></p>
<p>这里的管道，其实比较好理解，就类似于一根根的水管或者一个个的流水线，将一个个的过滤器连接起来，形成一个过滤器链（过滤器链可以携带多个过滤器，并且可以以自定义顺序执行它们），原始数据经过一道道的加工工序，最后形成我们需要的数据或产品。一般情况下我们还存在一个过滤器管理器的角色，过滤器管理器负责管理过滤器和过滤器链。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>下面我们通过一个例子来了解下过滤器模式，我们就以垃圾分类为例进行说明，使用不同的垃圾桶进行垃圾分类过滤，“垃圾” 就是我们的被过滤的角色，垃圾桶可以充当我们的绝体过滤器角色，实例的类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/tj7z7.png" alt=""></p>
<p>首先是 “垃圾” 类，也就是我们的被过滤的主体角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rubbish</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 垃圾名称</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isHarm; <span class="comment">// 是否有害垃圾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isRecycled; <span class="comment">// 是否可回收</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isDry; <span class="comment">// 是否干垃圾</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isWet; <span class="comment">// 是否湿垃圾</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Rubbish</span><span class="params">(String name, <span class="keyword">boolean</span> isHarm, <span class="keyword">boolean</span> isRecycled, <span class="keyword">boolean</span> isDry, <span class="keyword">boolean</span> isWet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.isHarm = isHarm;</span><br><span class="line">        <span class="keyword">this</span>.isRecycled = isRecycled;</span><br><span class="line">        <span class="keyword">this</span>.isDry = isDry;</span><br><span class="line">        <span class="keyword">this</span>.isWet = isWet;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... getter、setter省略，或者直接使用lombok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后是我们的过滤标准的接口，即抽象过滤器角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Criteria</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义过滤的标准</span></span><br><span class="line">    <span class="function">List&lt;Rubbish&gt; <span class="title">rubbishFilter</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们继续创建实现了 Criteria 接口的几个实体类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 干垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DryRubbishCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Rubbish&gt; <span class="title">rubbishFilter</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span> </span>&#123;</span><br><span class="line">        List&lt;Rubbish&gt; rubbishList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Rubbish rubbish: rubbishes) &#123;</span><br><span class="line">            <span class="comment">// 这里只过滤出所有干垃圾</span></span><br><span class="line">            <span class="keyword">if</span> (rubbish.isDry()) &#123;</span><br><span class="line">                rubbishList.add(rubbish);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rubbishList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 有害垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HarmfulRubbishCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Rubbish&gt; <span class="title">rubbishFilter</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span> </span>&#123;</span><br><span class="line">        List&lt;Rubbish&gt; rubbishList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Rubbish rubbish: rubbishes) &#123;</span><br><span class="line">            <span class="comment">// 这里只过滤出所有有害垃圾</span></span><br><span class="line">            <span class="keyword">if</span> (rubbish.isHarm()) &#123;</span><br><span class="line">                rubbishList.add(rubbish);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rubbishList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 可回收垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RecycledRubbishCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Rubbish&gt; <span class="title">rubbishFilter</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span> </span>&#123;</span><br><span class="line">        List&lt;Rubbish&gt; rubbishList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Rubbish rubbish: rubbishes) &#123;</span><br><span class="line">            <span class="comment">// 这里只过滤出所有可回收垃圾</span></span><br><span class="line">            <span class="keyword">if</span> (rubbish.isRecycled()) &#123;</span><br><span class="line">                rubbishList.add(rubbish);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rubbishList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 湿垃圾</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WetRubbishCriteria</span> <span class="keyword">implements</span> <span class="title">Criteria</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Rubbish&gt; <span class="title">rubbishFilter</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span> </span>&#123;</span><br><span class="line">        List&lt;Rubbish&gt; rubbishList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Rubbish rubbish: rubbishes) &#123;</span><br><span class="line">            <span class="comment">// 这里只过滤出所有湿垃圾</span></span><br><span class="line">            <span class="keyword">if</span> (rubbish.isWet()) &#123;</span><br><span class="line">                rubbishList.add(rubbish);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rubbishList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用不同的标准（Criteria）来过滤 Rubbish 对象的列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 原始数据集合</span></span><br><span class="line">        List&lt;Rubbish&gt; rubbishList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"果壳"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"陶瓷"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"菜根菜叶"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"果皮"</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"水银温度计"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"电池"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"灯泡"</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"废纸塑料"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"金属和布料"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line">        rubbishList.add(<span class="keyword">new</span> Rubbish(<span class="string">"玻璃"</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 四种不同的过滤标准</span></span><br><span class="line">        Criteria dryRubbishCriteria = <span class="keyword">new</span> DryRubbishCriteria();</span><br><span class="line">        Criteria wetRubbishCriteria = <span class="keyword">new</span> WetRubbishCriteria();</span><br><span class="line">        Criteria harmfulRubbishCriteria = <span class="keyword">new</span> HarmfulRubbishCriteria();</span><br><span class="line">        Criteria recycledRubbishCriteria = <span class="keyword">new</span> RecycledRubbishCriteria();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"干垃圾: "</span>);</span><br><span class="line">        printRubbishes(dryRubbishCriteria.rubbishFilter(rubbishList));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"湿垃圾: "</span>);</span><br><span class="line">        printRubbishes(wetRubbishCriteria.rubbishFilter(rubbishList));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"有害垃圾: "</span>);</span><br><span class="line">        printRubbishes(harmfulRubbishCriteria.rubbishFilter(rubbishList));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"可回收垃圾: "</span>);</span><br><span class="line">        printRubbishes(recycledRubbishCriteria.rubbishFilter(rubbishList));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printRubbishes</span><span class="params">(List&lt;Rubbish&gt; rubbishes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Rubbish rubbish: rubbishes) &#123;</span><br><span class="line">            System.out.println(rubbish);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">干垃圾: </span><br><span class="line">Rubbish&#123;name&#x3D;&#39;果壳&#39;, isHarm&#x3D;false, isRecycled&#x3D;false, isDry&#x3D;true, isWet&#x3D;false&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;陶瓷&#39;, isHarm&#x3D;false, isRecycled&#x3D;false, isDry&#x3D;true, isWet&#x3D;false&#125;</span><br><span class="line"></span><br><span class="line">湿垃圾: </span><br><span class="line">Rubbish&#123;name&#x3D;&#39;菜根菜叶&#39;, isHarm&#x3D;false, isRecycled&#x3D;false, isDry&#x3D;false, isWet&#x3D;true&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;果皮&#39;, isHarm&#x3D;false, isRecycled&#x3D;false, isDry&#x3D;false, isWet&#x3D;true&#125;</span><br><span class="line"></span><br><span class="line">有害垃圾: </span><br><span class="line">Rubbish&#123;name&#x3D;&#39;水银温度计&#39;, isHarm&#x3D;true, isRecycled&#x3D;false, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;电池&#39;, isHarm&#x3D;true, isRecycled&#x3D;false, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;灯泡&#39;, isHarm&#x3D;true, isRecycled&#x3D;false, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br><span class="line"></span><br><span class="line">可回收垃圾: </span><br><span class="line">Rubbish&#123;name&#x3D;&#39;废纸塑料&#39;, isHarm&#x3D;false, isRecycled&#x3D;true, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;金属和布料&#39;, isHarm&#x3D;false, isRecycled&#x3D;true, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br><span class="line">Rubbish&#123;name&#x3D;&#39;玻璃&#39;, isHarm&#x3D;false, isRecycled&#x3D;true, isDry&#x3D;false, isWet&#x3D;false&#125;</span><br></pre></td></tr></table></figure>

<p>这样过滤器模式的简单应用就一目了然了吧</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总结下过滤器模式的特点：</p>
<ul>
<li>可插拔：过滤器的设计概念要求其是支持可插拔设计的；</li>
<li>有序性：过滤器是被设计为一组组的过滤装置，要实现数据过滤，就必须有顺序性要求，比如我们要设计编解码过滤器，用户请求过来的 xml 数据会优先通过 xml2json 过滤器进行数据处理，完了再在响应发出前进行相应的 json2xml 过滤处理，以保证客户端交互以 xml 数据格式为准的同时系统内部数据交互还是维持 json 格式不变；</li>
<li>过滤器的独立性：每种过滤器必须是独立的实体，其状态不受其它过滤器的影响，每个过滤器都有自己独立的数据输入输出接口，只要各个过滤器之间传送的数据遵守共同的规约就可以相连接。</li>
</ul>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/5bp8b.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/posts/39554/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>适配器，其实很好理解，生活中也随处可见，比如电源适配器、usb 适配器等等，那么适配器模式，也被称为Wrapper 模式。</p>
<a id="more"></a>


<p>Wrapper 有“包装器”的意思，适配器模式的定义是：<strong>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，解决的痛点便是因接口不兼容导致的类不能正常工作的问题。</strong></p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/y0bt7.png" alt=""></p>
<p>如上图所示，A、B 代表已经塑模成型的物体 A 和 B，如果想将这两种物体安装在一起，因为两者的接口是不兼容的，不可能直接安装在一起，这个时候该怎么办？这里，我们可以引入物体 C，物体 C 既要适配 A 的接口，又要适配 B 的接口，经过 C 的无缝“衔接”，便将 A、B 完美结合在了一起。</p>
<p>这里的物体 C 就是我们要说的适配器角色，起到了一定的角色转换的作用。再举个例子，如果想让直流 12v 的笔记本电脑工作在交流 220v 的电源下，就必须要一个电源适配器，该适配器的作用就是将 220v 的 AC 交流转为 12v 的 DC 直流，这就是适配器该干的工作，弥补两者之间的空白——承上启下。</p>
<p>什么时候使用适配器模式，从上面的案例我们也可以看出一点端倪：</p>
<ul>
<li>现有的类或接口不能满足需求，且一般无法直接修改现有类或接口。比方该类为三方提供，就无法修改，亦或者像A、B 这种已经塑模成型的物件，可能已大规模在使用中，所以不允许修改。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作，这些源类不一定有一致的接口。</li>
</ul>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>适配器模式，根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p>
<p>适配器模式的通用类图如下：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/fl8kf.png" alt=""></p>
<p>适配器模式包含的角色如下：</p>
<ul>
<li>目标角色（Target）：该角色定义把其它类转换为何种接口，也就是我们的期望接口，可以是一个抽象类或接口，也可以是具体类。以上文中笔记本电脑为例，即指让笔记本正常工作的直流 12v 电源；</li>
<li>适配器角色（Adapter）：适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，通常都是一个具体的类。以上文中笔记本电脑为例，即指电源适配器；</li>
<li>源角色（被适配 Adaptee ）：你想把谁转换成目标角色，这个“谁”就是源角色，它是已经存在的、运行良好的类或对象，经过适配器角色的包装，它会成为一个崭新、靓丽的角色。以上文中笔记本电脑为例，即指 220v 的 AC 电源；</li>
<li>请求者（Client）：该角色负责使用 Target 定义的方法进行具体处理，以上文中笔记本电脑为例，即指使用 12v 电源驱动的笔记本电脑。</li>
</ul>
<p>总的一句话，Adapter 就是一个在 Client 中使用 Target 定义的接口来使用 Adaptee 角色（调用 Adaptee 中的方法）的存在。</p>
<h2 id="类适配器（使用继承）"><a href="#类适配器（使用继承）" class="headerlink" title="类适配器（使用继承）"></a>类适配器（使用继承）</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/nw66a.png" alt=""></p>
<p>如上图为使用类适配器实现的适配器模式，具体代码如下：</p>
<p>首先是 Target 接口，也就是我们要适配的目标接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">targetMethod1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">targetMethod2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来是要被适配的“接口”，即 Adaptee：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodA</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee methodA invoked."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodB</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adaptee methodB invoked."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>然后是我们的适配器，关键代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adapter targetMethod1 inkoked."</span>);</span><br><span class="line">        methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adapter targetMethod2 inkoked."</span>);</span><br><span class="line">        methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们的 Client，在这里就是 Main 类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通过Adapter继承Adaptee实现了Adaptee角色的调用</span></span><br><span class="line">        Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">        target.targetMethod1();</span><br><span class="line">        target.targetMethod2();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Adapter targetMethod1 inkoked.</span><br><span class="line">Adaptee methodA invoked.</span><br><span class="line">Adapter targetMethod2 inkoked.</span><br><span class="line">Adaptee methodB invoked.</span><br></pre></td></tr></table></figure>

<p>这里，Client 使用者并不知道 Adaper 适配器是如何工作的，就好比笔记本电脑只需要在 12v 电压下正常工作即可，具体适配器如何适配实现电压转换，笔记本电脑无需关心。</p>
<h2 id="对象适配器（使用委托）"><a href="#对象适配器（使用委托）" class="headerlink" title="对象适配器（使用委托）"></a>对象适配器（使用委托）</h2><p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/mx21e.png" alt=""></p>
<p>如上图为使用对象适配器实现的适配器模式，具体代码如下：<br>首先是我们要适配的目标类，这里不是接口了注意：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">targetMethod1</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">targetMethod2</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 java 的类不支持多继承，但是在单继承模式下我们可以使用委托来实现方法的调用，修改后的 Adapter 适配器代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Target</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetMethod1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adapter targetMethod1 inkoked."</span>);</span><br><span class="line">        adaptee.methodA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetMethod2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Adapter targetMethod2 inkoked."</span>);</span><br><span class="line">        adaptee.methodB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client 调用的时候没有变化，还是如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过Adapter使用委托，实现了Adaptee角色的调用</span></span><br><span class="line">    Target target = <span class="keyword">new</span> Adapter();</span><br><span class="line">    target.targetMethod1();</span><br><span class="line">    target.targetMethod2();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Adapter targetMethod1 inkoked.</span><br><span class="line">Adaptee methodA invoked.</span><br><span class="line">Adapter targetMethod2 inkoked.</span><br><span class="line">Adaptee methodB invoked.</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>主要优点：</p>
<ul>
<li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构；</li>
<li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用；</li>
<li>可以将两个互不相干的类关联在一起；</li>
<li>增强系统灵活性。</li>
</ul>
<p>主要缺点：</p>
<ul>
<li>类适配器对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>类适配器与对象适配器的使用场景一致，主要应用于如下场景：</p>
<ul>
<li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码，这时创建一个适配器就能间接去改造这个类中的方法；</li>
<li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>适配器模式，本身属于一种结构型模式，用于在两个对象或者系统之间建立适配链接，使得前后系统衔接更加平滑，适配器模式的实现主要有继承方式的类适配器，和委托方式的对象适配器。</p>
<p><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/etjgx.png" alt=""></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/posts/16036/</url>
    <content><![CDATA[<p>迭代器模式（Iterator Pattern）又称为游标（Cursor）模式，是最常被使用的几个模式之一，被广泛地应用到 Java 的 API 中。例如，Java 的集合（Collection）框架中，就广泛使用迭代器来遍历集合中的元素。</p>
<a id="more"></a>


<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>迭代器模式的英文定义如下：</p>
<blockquote>
<p>Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.<br>意思是：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。<br>迭代器是为容器服务的，容器是指用来容纳其他对象的对象，例如，Collection 集合类型、Set 类等。</p>
</blockquote>
<h2 id="组成角色"><a href="#组成角色" class="headerlink" title="组成角色"></a>组成角色</h2><p>迭代器模式有以下 4 个角色：</p>
<ul>
<li>抽象迭代器（Iterator）角色：该角色负责定义访问和遍历元素的接口；</li>
<li>具体迭代器（Concrete Iterator）角色：该角色实现 Iterator 接口，完成容器元素的遍历；</li>
<li>抽象聚集（Aggregate）角色：该角色提供创建迭代器角色的接口；</li>
<li>具体聚集（Concrete Aggregate）角色：该角色实现抽象聚集接口，创建出容纳迭代器的对象。<br>角色之间的关系，如下图所示：<br><img src="https://story-has-you.oss-cn-shanghai.aliyuncs.com/blog/hz29s.png" alt=""></li>
</ul>
<h2 id="迭代器模式代码实现"><a href="#迭代器模式代码实现" class="headerlink" title="迭代器模式代码实现"></a>迭代器模式代码实现</h2><h3 id="抽象迭代器"><a href="#抽象迭代器" class="headerlink" title="抽象迭代器"></a>抽象迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体迭代器"><a href="#具体迭代器" class="headerlink" title="具体迭代器"></a>具体迭代器</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcreteAggregate aggregate;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> index;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteIterator</span><span class="params">(ConcreteAggregate aggregate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aggregate = aggregate;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = aggregate.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 是否有下一个元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index &lt; size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回下一个元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; size) &#123;</span><br><span class="line">            <span class="keyword">return</span> aggregate.getElement(index++);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="抽象聚集"><a href="#抽象聚集" class="headerlink" title="抽象聚集"></a>抽象聚集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="具体聚集"><a href="#具体聚集" class="headerlink" title="具体聚集"></a>具体聚集</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcreteAggregate</span> <span class="keyword">implements</span> <span class="title">Aggregate</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 私有存储容器</span></span><br><span class="line">    <span class="keyword">private</span> Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">    <span class="comment">// 添加元素</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.vector.add(obj);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据下标获取元素</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getElement</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vector.get(index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取集合长度</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> vector.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建迭代器</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ConcreteIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义聚族对象</span></span><br><span class="line">        Aggregate aggregate = <span class="keyword">new</span> ConcreteAggregate();</span><br><span class="line">        aggregate.add(<span class="string">"Java"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"MySQL"</span>);</span><br><span class="line">        aggregate.add(<span class="string">"Spring"</span>);</span><br><span class="line">        <span class="comment">// 遍历</span></span><br><span class="line">        Iterator iterator = aggregate.createIterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Java</span><br><span class="line"></span><br><span class="line">MySQL</span><br><span class="line"></span><br><span class="line">Spring</span><br></pre></td></tr></table></figure>

<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>迭代器模式的优点：</p>
<ul>
<li>迭代器模式将数据存储和数据遍历的职责进行分离；</li>
<li>迭代器模式简化了遍历容器元素的操作；</li>
<li>迭代器模式使不同的容器，具备一个统一的遍历接口；</li>
<li>迭代器模式封装了遍历算法，使算法独立于聚集角色，调用者无须知道聚集对象的类型，即使聚集对象的类型发生变化，也不会影响遍历过程。<br>迭代器模式的缺点：</li>
<li>由于迭代器模式将数据存储和数据遍历的职责进行分离，如果增加新的聚合类，同时需要增加与之相对应的迭代器类，这使得类的个数会成对增加，在某种程度上来说增加了系统的复杂性。</li>
</ul>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>迭代器的应用很广泛，已经发展成为程序开发中最基础的工具类了。在 Java 语言中，从 JDK 1.2 开始，增加了 java.util.Iterator 接口，并将 Iterator 应用到各个聚集类（Collection）中，如 ArrayList、Vector、Stack、HashSet 等集合类都实现了 iterator() 方法，返回一个迭代器 Iterator，用于对集合中的元素进行遍历。这使我们在项目中无须在独立地写迭代器，直接使用即可，这样既轻松又便捷。</p>
<p>注意：要尽可能地使用编程语言自身提供的迭代器，而非自己写的迭代器。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><p>下面将会使用 Java API 提供的迭代器模式，演示迭代器的具体使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lesson19</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用迭代器应用示例</span></span><br><span class="line">        <span class="keyword">new</span> IteratorUseDemo().doIterator();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 迭代器应用——演示示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IteratorUseDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义 Vector 集合</span></span><br><span class="line">        Vector vector = <span class="keyword">new</span> Vector();</span><br><span class="line">        vector.add(<span class="string">"Vector 1"</span>);</span><br><span class="line">        vector.add(<span class="string">"Vector 2"</span>);</span><br><span class="line">        vector.add(<span class="string">"Vector 3"</span>);</span><br><span class="line">        <span class="comment">// 定义 ArrayList 集合</span></span><br><span class="line">        ArrayList list = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        list.add(<span class="string">"ArrayList 1"</span>);</span><br><span class="line">        list.add(<span class="string">"ArrayList 2"</span>);</span><br><span class="line">        list.add(<span class="string">"ArrayList 3"</span>);</span><br><span class="line">        <span class="comment">// 使用迭代器循环 Vector</span></span><br><span class="line">        java.util.Iterator vIterator = vector.iterator();</span><br><span class="line">        <span class="keyword">while</span> (vIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(vIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 使用迭代器循环 ArrayList</span></span><br><span class="line">        java.util.Iterator lIterator = list.iterator();</span><br><span class="line">        <span class="keyword">while</span> (lIterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(lIterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程序执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Vector 1</span><br><span class="line"></span><br><span class="line">Vector 2</span><br><span class="line"></span><br><span class="line">Vector 3</span><br><span class="line"></span><br><span class="line">ArrayList 1</span><br><span class="line"></span><br><span class="line">ArrayList 2</span><br><span class="line"></span><br><span class="line">ArrayList 3</span><br></pre></td></tr></table></figure>

<p>从上面示例可以看出，集合都可以通过 iterator() 方法，获得统一的迭代器对象 java.util.Iterator，然后进行循环遍历。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>迭代器模式是最常用的设计模式之一，已经被广泛应用到 Java 的 API 中，比如在 Java 的集合中，使用 iterator() 方法就可以获得统一的迭代器对象 java.util.Iterator，使用这个对象就可以很方便地实现集合的遍历功能。迭代器包含四个角色（抽象迭代器、具体迭代器、抽象聚集和具体聚集）和两个重要的方法：hasNext() 方法用来判断是否还有下一个未遍历的元素，next() 方法用来获取此次遍历的对象。要注意的是，如果编程语言中已经提供了内置的迭代器，并且能满足现有需求的情况下，开发者就不必自己再写迭代器了。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
  </entry>
</search>
